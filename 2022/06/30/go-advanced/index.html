<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <meta name="google-site-verification" content="xitt2fbphh1nTeWLiTWc0lCggHuxJ5heMcAzkHW2vno">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"cyun.tech","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":10,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Advancedstructtags1234567891011121314151617181920212223package mainimport (    &quot;fmt&quot;    &quot;reflect&quot;)type Person struct &amp;#123;    Name string &#96;k1:&quot;v1&quot; k2:&quot;v2&quot;&#96;&amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="go-advanced">
<meta property="og:url" content="http://cyun.tech/2022/06/30/go-advanced/index.html">
<meta property="og:site_name" content="CYun">
<meta property="og:description" content="Advancedstructtags1234567891011121314151617181920212223package mainimport (    &quot;fmt&quot;    &quot;reflect&quot;)type Person struct &amp;#123;    Name string &#96;k1:&quot;v1&quot; k2:&quot;v2&quot;&#96;&amp;#12">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.halfrost.com/Blog/ArticleImage/148_6_0.png">
<meta property="article:published_time" content="2022-06-30T09:13:40.000Z">
<meta property="article:modified_time" content="2023-08-16T15:02:01.143Z">
<meta property="article:author" content="Jason">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.halfrost.com/Blog/ArticleImage/148_6_0.png">


<link rel="canonical" href="http://cyun.tech/2022/06/30/go-advanced/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://cyun.tech/2022/06/30/go-advanced/","path":"2022/06/30/go-advanced/","title":"go-advanced"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go-advanced | CYun</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148730544-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-148730544-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?a510d1f580c8231f8f867d14f42bb8ea"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CYun</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Advanced"><span class="nav-number">1.</span> <span class="nav-text">Advanced</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#struct"><span class="nav-number">1.1.</span> <span class="nav-text">struct</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tags"><span class="nav-number">1.1.1.</span> <span class="nav-text">tags</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#anonymous-fields"><span class="nav-number">1.1.2.</span> <span class="nav-text">anonymous fields</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promoted-fields"><span class="nav-number">1.1.3.</span> <span class="nav-text">Promoted fields</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class"><span class="nav-number">1.1.4.</span> <span class="nav-text">class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interface"><span class="nav-number">1.1.5.</span> <span class="nav-text">Interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#embedding-and-composing-struct"><span class="nav-number">1.1.6.</span> <span class="nav-text">embedding and composing struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#empty-struct"><span class="nav-number">1.1.7.</span> <span class="nav-text">empty struct</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#package"><span class="nav-number">1.2.</span> <span class="nav-text">package</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#inside-import-statement"><span class="nav-number">1.2.1.</span> <span class="nav-text">inside import statement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#searching-package"><span class="nav-number">1.2.2.</span> <span class="nav-text">searching package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import-package"><span class="nav-number">1.2.3.</span> <span class="nav-text">import package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-env"><span class="nav-number">1.2.4.</span> <span class="nav-text">go env</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#workspace"><span class="nav-number">1.2.5.</span> <span class="nav-text">workspace</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#module"><span class="nav-number">1.3.</span> <span class="nav-text">module</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#go-mod"><span class="nav-number">1.3.1.</span> <span class="nav-text">go.mod</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#creating-a-module-library-used-by-others"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">creating a module(library) used by others</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#creating-a-module-runnable-application"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">creating a module(runnable application)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Importing-packages-from-your-module"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">Importing packages from your module</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vendor"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">vendor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exception"><span class="nav-number">1.4.</span> <span class="nav-text">exception</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#recover-from-panic"><span class="nav-number">1.4.1.</span> <span class="nav-text">recover from panic</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cgo-call-C-in-Go"><span class="nav-number">1.5.</span> <span class="nav-text">cgo(call C in Go)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#type-mapping-between-C-and-go"><span class="nav-number">1.5.1.</span> <span class="nav-text">type mapping between C and go</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-C-within-go-file"><span class="nav-number">1.5.2.</span> <span class="nav-text">write C within go file</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-C-out-of-go-compile-as-library-go-import-the-library"><span class="nav-number">1.5.3.</span> <span class="nav-text">write C out of go, compile as library, go import the library</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime"><span class="nav-number">1.6.</span> <span class="nav-text">Runtime</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concurrency-multiple-threads"><span class="nav-number">1.7.</span> <span class="nav-text">concurrency(multiple threads)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#multiple-channels"><span class="nav-number">1.7.1.</span> <span class="nav-text">multiple channels</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mutex"><span class="nav-number">1.7.2.</span> <span class="nav-text">Mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WaitGroup"><span class="nav-number">1.7.3.</span> <span class="nav-text">WaitGroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Once"><span class="nav-number">1.7.4.</span> <span class="nav-text">Once</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cond"><span class="nav-number">1.7.5.</span> <span class="nav-text">Cond</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#atomic"><span class="nav-number">1.7.6.</span> <span class="nav-text">atomic</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reflection"><span class="nav-number">1.8.</span> <span class="nav-text">reflection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#from-specific-type-to-generic-type"><span class="nav-number">1.8.1.</span> <span class="nav-text">from specific type to generic type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#from-interface-to-specific-type"><span class="nav-number">1.8.2.</span> <span class="nav-text">from interface to specific type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Advanced-feature-between-interface-and-specfic-type"><span class="nav-number">1.8.3.</span> <span class="nav-text">Advanced feature between interface and specfic type</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#import-cycle"><span class="nav-number">1.9.</span> <span class="nav-text">import cycle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deep-copy"><span class="nav-number">1.10.</span> <span class="nav-text">Deep copy</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tips"><span class="nav-number">2.</span> <span class="nav-text">Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Anonymous-struct-type"><span class="nav-number">2.1.</span> <span class="nav-text">Anonymous struct type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Anonymous-function"><span class="nav-number">2.2.</span> <span class="nav-text">Anonymous function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reader-and-Writer"><span class="nav-number">2.3.</span> <span class="nav-text">Reader and Writer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#never-use-break-for-each-case-in-switch-x2F-select"><span class="nav-number">2.4.</span> <span class="nav-text">never use break for each case in switch&#x2F;select</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handle-OS-difference"><span class="nav-number">2.5.</span> <span class="nav-text">Handle OS difference</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-over-Unix"><span class="nav-number">2.6.</span> <span class="nav-text">HTTP over Unix</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WaitGroup-vs-Channel"><span class="nav-number">2.7.</span> <span class="nav-text">WaitGroup vs Channel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#do-we-need-to-close-channel-explicitly"><span class="nav-number">2.8.</span> <span class="nav-text">do we need to close(channel) explicitly</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#print-value-of-struct-pointer-embeded-in-another-struct"><span class="nav-number">2.9.</span> <span class="nav-text">print value of struct pointer embeded in another struct</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block-forever-in-go"><span class="nav-number">2.10.</span> <span class="nav-text">block forever in go</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel-with-timeout"><span class="nav-number">2.11.</span> <span class="nav-text">Channel with timeout</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ref"><span class="nav-number">3.</span> <span class="nav-text">Ref</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jason"
      src="/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">146</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">150</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jason-cyun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jason-cyun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jason_lkm@163.com" title="E-Mail → mailto:jason_lkm@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cyun.tech/2022/06/30/go-advanced/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="Jason">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CYun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="go-advanced | CYun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go-advanced
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-30 17:13:40" itemprop="dateCreated datePublished" datetime="2022-06-30T17:13:40+08:00">2022-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-16 23:02:01" itemprop="dateModified" datetime="2023-08-16T23:02:01+08:00">2023-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/program/" itemprop="url" rel="index"><span itemprop="name">program</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h1><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><h3 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`k1:&quot;v1&quot; k2:&quot;v2&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    tp := reflect.TypeOf(p)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tp.NumField(); i++ &#123;</span><br><span class="line">        f := tp.Field(i)</span><br><span class="line">        fmt.Println(f.Tag.Get(<span class="string">&quot;k1&quot;</span>))</span><br><span class="line">        fmt.Println(f.Tag.Get(<span class="string">&quot;k2&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">v1</span><br><span class="line">v2</span><br></pre></td></tr></table></figure>

<p><strong>Rules for writing tag</strong></p>
<span id="more"></span>

<ul>
<li><p><code>whitespace, double quote &quot;, colon :</code> are special in tags.</p>
</li>
<li><p>Tag <code>keys must not contain</code> space (Unicode value 32), quote <code>&quot;</code>(Unicode value 34) and <code>:</code> colon (Unicode value 58) characters.</p>
</li>
<li><p>To form a valid key-value pair, <strong>no space characters are allowed to follow the colon in the supposed key-value pair</strong>. So</p>
<blockquote>
<p><code>optional: &quot;yes&quot;</code> doesn’t form key-value pairs.</p>
</blockquote>
</li>
<li><p>different key-value pairs are separated by whitespace </p>
</li>
<li><p><strong><font color='red'>space characters in tag values are important</font></strong>. So</p>
<blockquote>
<p><code>json:&quot;author, omitempty&quot;</code>,<br><code>json:&quot; author,omitempty&quot;</code> and<br><code>json:&quot;author,omitempty&quot;</code> are different from each other.</p>
</blockquote>
</li>
<li><p>each struct field <code>tag should present as a single line</code> to be wholly meaningful.</p>
</li>
</ul>
<p><strong>Exported struct</strong><br>If a <code>struct type</code> starts with a capital letter, then it is an exported type and it can be accessed from other packages. Similar the <code>fields of a struct</code> start with caps, they can be accessed from other packages.</p>
<p><strong>Structs Equality</strong><br>Structs are value types and are comparable if each of their fields are comparable. Two struct variables are considered equal if their <code>corresponding fields(field with same name)</code> are equal.</p>
<h3 id="anonymous-fields"><a href="#anonymous-fields" class="headerlink" title="anonymous fields"></a>anonymous fields</h3><p>It is possible to <code>create structs with fields that contain only a type without the field name</code>. These kinds of fields are called anonymous fields. Even though anonymous fields do not have an explicit name, <code>by default the name of an anonymous field is the name of its type.</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">string</span></span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// same as </span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">string</span> <span class="type">string</span></span><br><span class="line">    <span class="type">int</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person struct has <code>2 fields with name string and int</code>!!!</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">string</span></span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := Person&#123;</span><br><span class="line">        <span class="type">string</span>: <span class="string">&quot;naveen&quot;</span>,</span><br><span class="line">        <span class="type">int</span>:    <span class="number">50</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(p1.<span class="type">string</span>)</span><br><span class="line">    fmt.Println(p1.<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Promoted-fields"><a href="#Promoted-fields" class="headerlink" title="Promoted fields"></a>Promoted fields</h3><p><code>Fields that belong to an anonymous field which is also a struct are called promoted fields</code> since they can be accessed as if they belong to the struct which holds the anonymous struct. <font color='red'>promoted fields can be functions as well!!!</font></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    city  <span class="type">string</span></span><br><span class="line">    state <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Address)</span></span> City() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.city</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="type">string</span></span><br><span class="line">    age     <span class="type">int</span></span><br><span class="line">    Address <span class="comment">//anonymous struct field</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Personx <span class="keyword">struct</span> &#123;</span><br><span class="line">    name     <span class="type">string</span></span><br><span class="line">    age      <span class="type">int</span></span><br><span class="line">    *Address <span class="comment">//anonymous struct field *Address is new type.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;</span><br><span class="line">        name: <span class="string">&quot;Naveen&quot;</span>,</span><br><span class="line">        age:  <span class="number">50</span>,</span><br><span class="line">        Address: Address&#123;</span><br><span class="line">            city:  <span class="string">&quot;Chicago&quot;</span>,</span><br><span class="line">            state: <span class="string">&quot;Illinois&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    px := Personx&#123;</span><br><span class="line">        name: <span class="string">&quot;Naveen&quot;</span>,</span><br><span class="line">        age:  <span class="number">50</span>,</span><br><span class="line">        Address: &amp;Address&#123; <span class="comment">// different ways for assigning</span></span><br><span class="line">            city:  <span class="string">&quot;Chicago&quot;</span>,</span><br><span class="line">            state: <span class="string">&quot;Illinois&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Name:&quot;</span>, p.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Age:&quot;</span>, p.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>, p.Address.city)  <span class="comment">// can access this way as well</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>, p.Address.state) <span class="comment">// can access this way as well</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>, p.city)          <span class="comment">//city is promoted field</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>, p.City())        <span class="comment">//City() function is promoted field</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;State:&quot;</span>, p.state)        <span class="comment">//state is promoted field</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// same way as above for accessing pointer</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Name:&quot;</span>, px.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Age:&quot;</span>, px.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>, px.Address.city)  <span class="comment">// can access this way as well</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>, px.Address.state) <span class="comment">// can access this way as well</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>, px.city)          <span class="comment">//city is promoted field</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>, px.City())        <span class="comment">//City() is promoted field</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;State:&quot;</span>, px.state)        <span class="comment">//state is promoted field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>There is <code>no class in Go</code>, but you can <strong>bind functions with struct, hence it behaves like a class.</strong><br><code>func (p Person) speak() string &#123;&#125;</code> The receiver appears in its own argument list <code>between the func keyword and the method name</code>.</p>
<p>You <strong>can only declare a method with a receiver whose type is defined in the same package as the method</strong>. You cannot declare a method with a receiver whose type is defined in another package</p>
<ul>
<li><p><code>Value receiver makes a copy of the type and pass it to the function</code>. The function stack now holds an equal object but at a different location on memory. That means any changes done on the passed object will remain local to the method. The original object will remain unchanged.</p>
</li>
<li><p><code>Pointer receiver passes the address of a type to the function</code>. The function stack has a reference to the original object. So any modifications on the passed object will modify the original object.</p>
</li>
</ul>
<p>If you want to change the state of the receiver in a method, manipulating the value of it, use a pointer receiver. It’s not possible with a value receiver, which copies by value. Any modification to a value receiver is local to that copy. If you don’t need to manipulate the receiver value, use a value receiver(pointer receiver can be used as well).</p>
<p>The Pointer receiver avoids copying the value on each method call. This can be more efficient if the receiver is a large struct.</p>
<p>Value receivers are concurrency safe, while pointer receivers are not concurrency safe. Hence a programmer needs to take care of it.</p>
<p><strong>RULES for receivers</strong></p>
<ul>
<li>Try to use <strong>same receiver type for all your methods as much as possible, not use both</strong>.</li>
<li>If state modification needed, use pointer receiver if not use value receiver(but can use pointer receive as well, good case for large struct).</li>
</ul>
<p><strong>Specific class(not interface) method supports</strong></p>
<ul>
<li><font color='red' size=4>call pointer receiver on non-pointer object(which is converted to pointer automatically)</font></li>
<li><font color='red' size=4>call value receiver on pointer object(which is converted to value object automatically)</font></li>
</ul>
<p><strong>Note: Above supports only work for class method, NOT normal function, as normal function with a pointer argument must take a pointer, normal function with a value argument must take a value object not a pointer</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T and type *T are different types but *T contains method of T!!!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> speak() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Speak() called by &quot;</span> + p.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> say() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;say() called by &quot;</span> + p.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := Person&#123;<span class="string">&quot;Jack&quot;</span>&#125;</span><br><span class="line">    p1.speak() <span class="comment">// (&amp;p).speak() automatically done by Go, but speak() is not a method of Person!!</span></span><br><span class="line">    </span><br><span class="line">    p2 := &amp;Person&#123;<span class="string">&quot;jason&quot;</span>&#125;</span><br><span class="line">    p2.say() <span class="comment">//(*p2).say() automatically done by Go, but say() is a method of Person!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you were to call p.speak(), the compiler would automatically change that to (&amp;p).speak(). A similar conversion happens in the other direction if you have a method with a non-pointer receiver and you call it on a pointer, easier to use.</p>
<p><strong>Call method on struct nil pointer, no exception in Go, nil return</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">  x, y <span class="type">int</span></span><br><span class="line">  <span class="comment">// this is no method delcare here!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad way if want to update, but it&#x27;s ok if not updating caller object</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Update() &#123; <span class="comment">// value receiver</span></span><br><span class="line">  v.x = <span class="number">10</span></span><br><span class="line">  v.y = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good way use (v *Vertex) to bind with struct Vertex</span></span><br><span class="line"><span class="comment">// bound with Vertex struct</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">int</span>) &#123; <span class="comment">// pointer receiver</span></span><br><span class="line">  v.x = v.x * f</span><br><span class="line">  v.y = v.x * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">classDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// call pointer receiver on non-pointer object</span></span><br><span class="line">    v1 := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    </span><br><span class="line">    v1.Update() <span class="comment">// copy of v1 is passed!!!</span></span><br><span class="line">    fmt.Println(v1) <span class="comment">// v1 is not changed at all</span></span><br><span class="line">    </span><br><span class="line">    v1.Scale(<span class="number">2</span>) <span class="comment">// pointer receiver (&amp;v1).Scale() is called automatcially by Go</span></span><br><span class="line">    fmt.Println(v1)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call value receiver on pointer object</span></span><br><span class="line">    v2 := &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    </span><br><span class="line">    v2.Update() <span class="comment">// value receiver (*v2).Update() is called automatcially by Go</span></span><br><span class="line">    fmt.Println(*v2) <span class="comment">// v2 is not changed at all</span></span><br><span class="line">    </span><br><span class="line">    v2.Scale(<span class="number">2</span>)</span><br><span class="line">    fmt.Println(*v2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">classDemo()</span><br></pre></td></tr></table></figure>

<pre><code>&#123;1 2&#125;
&#123;2 4&#125;
&#123;1 2&#125;
&#123;2 4&#125;
</code></pre>
<h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>Types implicitly satisfy an interface if they <strong><code>implement all required methods defined by that interface</code>.</strong></p>
<p><strong><code>type T and type *T are different types but *T contains all methods of T, but the other side is not true, even not true you still can call *T method from T object like above(actually implicit conversion happened)</code></strong>  </p>
<p>The method set of any other <code>type T consists of all methods declared with receiver type T</code>. The method set of the corresponding pointer <code>type *T is the set of all methods declared with receiver *T or T</code> (that is, it also contains the method set of T). </p>
<p>That means:</p>
<ul>
<li><p>If a type <code>T</code> implements all methods of an interface using value receiver, then both value <code>T</code> and pointer of that type <code>*T</code> can be used while assigning to that interface variable or while passing to a function which accept an argument as that interface.  </p>
</li>
<li><p>If a type <code>T</code> implements all methods of an interface using pointer receiver, then the only pointer of that type <code>*T</code> can be used while assigning to that interface variable or while passing to a function that accepts an argument as that interface.</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;</span><br><span class="line">    speak() <span class="type">string</span> <span class="comment">// no func keyword at the beginning</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// two common used interface var</span></span><br><span class="line"><span class="keyword">var</span> hi Humaner = struct_object</span><br><span class="line"><span class="keyword">var</span> hi Humaner = &amp;struct_object</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hi *Humaner = &amp;struct_object <span class="comment">// Never see such way used!!!</span></span><br></pre></td></tr></table></figure>


<p><strong><code>interface &#123;&#125;</code> is a special type which has no method, hence all types can be converted to it, it looks like void* in C but it’s not an pointer in Go, an string, int, object, &amp;object can assign to it as well</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">12</span>)</span><br><span class="line">test(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// both are ok!!</span></span><br><span class="line">test(Person&#123;Name: <span class="string">&quot;Jason&quot;</span>&#125;)</span><br><span class="line">test(&amp;Person&#123;<span class="string">&quot;Jason&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>Call method on interface nil pointer, runtime error!!!</strong></p>
<p><strong>More details, refer to <a target="_blank" rel="noopener" href="https://halfrost.com/go_interface/">inside interface</a></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;</span><br><span class="line">    speak() <span class="type">string</span></span><br><span class="line">    say() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> say() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;say() called by &quot;</span> + p.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> speak() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;speak() called by &quot;</span> + p.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">speakSomething</span><span class="params">(h Humaner)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;area&quot;</span>, h.speak())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saySomething</span><span class="params">(h Humaner)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;area&quot;</span>, h.say())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demoInterface</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">&quot;harsh&quot;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//works</span></span><br><span class="line">    speakSomething(&amp;p)</span><br><span class="line">    <span class="comment">// works because *person has method implemented by person as well.</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// both do NOT work(compiler error) because type person does not implment speak() method</span></span><br><span class="line">    <span class="comment">// hence can&#x27;t convert type person to human interface</span></span><br><span class="line">    <span class="comment">// speakSomething(p) compiler error</span></span><br><span class="line">    <span class="comment">// saySomething(p)   compiler error.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//works, as for specific class p.speak() converted to (&amp;p).speak() by Go automatically</span></span><br><span class="line">    fmt.Println(p.speak())</span><br><span class="line">    </span><br><span class="line">    fmt.Println(p.say())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demoInterface()</span><br></pre></td></tr></table></figure>

<pre><code>area speak() called by harsh
speak() called by harsh
say() called by harsh
</code></pre>
<h3 id="embedding-and-composing-struct"><a href="#embedding-and-composing-struct" class="headerlink" title="embedding and composing struct"></a>embedding and composing struct</h3><p><strong>Embedding old way used like C</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Admin <span class="keyword">struct</span> &#123;</span><br><span class="line">  u User</span><br><span class="line">  permissions <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Embedding go supported new way</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Admin <span class="keyword">struct</span> &#123;</span><br><span class="line">  User  <span class="comment">//anonymous fields</span></span><br><span class="line">  <span class="comment">/* all its methods are “promoted” to the Admin as well. </span></span><br><span class="line"><span class="comment">   * That means one can reference the name of the user via admin.Name no intermediate call to the u needed, like Admin.u.Name</span></span><br><span class="line"><span class="comment">   // short way: Admin.Name</span></span><br><span class="line"><span class="comment">   // another way: Admin.User.Name </span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  permissions <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Composing types</strong><br>which consists of embedding various types to create other types&#x2F;interfaces</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader <span class="comment">//anonymous fields</span></span><br><span class="line">    Writer <span class="comment">//anonymous fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What I can see from the above definition is that a <code>ReadWriter is an interface which must contain all the functions defined on both Reader and Writer</code>, which are defined elsewhere.</p>
<p><strong>NOTE</strong></p>
<ul>
<li><font color='red'>There is no function signature in struct type like we did for C</font></li>
<li><font color='red'>If you embed a Interface in struct, that means you declare a Interface variable of the struct!!!</font></li>
</ul>
<h3 id="empty-struct"><a href="#empty-struct" class="headerlink" title="empty struct"></a>empty struct</h3><p>Instance of empty struct <code>struct&#123;&#125; in doesn’t occupy any memory</code>. It is of zero byte. it’s used mostly in two cases:</p>
<ul>
<li><p>Empty struct is a very good use case in a channel when you only want to use a <code>channel for notification and not for actually passing in any data</code>. but some one uses bool channel, which is accepted, but empty struct is better choice!!!</p>
</li>
<li><p>Implementation of Set data structure. A set is a data structure that holds elements without any particular order. An element only appears once in a set. We use <code>map[keyType]struct&#123;&#125; for set</code>. struct{} is only just to let us know if an element exists in the set or not.</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Add(key <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="comment">// struct &#123;&#125; is type, while struct&#123;&#125;&#123;&#125; is an instance of this type.</span></span><br><span class="line">    s[key] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Delete(key <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="built_in">delete</span>(s, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span></span> Has(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    _, ok := s[key]</span><br><span class="line">    <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Set&#123;&#125;</span><br><span class="line">    s.Add(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// save slot for same key</span></span><br><span class="line">    s.Add(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    s.Add(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    s.Delete(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// no error even for no exist!!!</span></span><br><span class="line">    s.Delete(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;set %v has &#x27;a&#x27;: %v\n&quot;</span>, s, s.Has(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;set %v has &#x27;b&#x27;: %v\n&quot;</span>, s, s.Has(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>set map[a:&#123;&#125;] has &#39;a&#39;: true
set map[a:&#123;&#125;] has &#39;b&#39;: false
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// send</span></span><br><span class="line">    time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;after 1s, sent notification, data is ready&quot;</span>)</span><br><span class="line">    ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// channel buffer is zero</span></span><br><span class="line">    <span class="comment">// some one use ch := make(chan bool) but empty struct is better!!!</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> worker(ch)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;blocked due to no data&quot;</span>)</span><br><span class="line">    <span class="comment">// read from channel, if no data block here</span></span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;wake up after 1s as data is ready&quot;</span>)</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>blocked due to no data
after 1s, sent notification, data is ready
wake up after 1s as data is ready
</code></pre>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>A package is a <strong><code>collection of source files in the same directory</code></strong> that are compiled together. <code>Functions, types, variables, and constants defined in one source file are visible to all other source files within the same package</code>. </p>
<p><strong><font color='red'>one package per directory, you can NOT have multiple packages in same directory</font></strong></p>
<p><strong>create a runnable program</strong><br>A standalone executable Go program must have package main declaration. <strong>If a program is part of the main package, then go build(go install) will create a binary file; which upon execution calls main function of the program, binary file is created only for man package</strong>  </p>
<p><strong>create a library</strong><br>If a program is part of a package other than main, then a package archive file is created with go build(go install) command</p>
<p><code>Package declaration(package xxx at beginning of xx.go) which should be first line of code</code>, <strong>file name can be different than package name</strong>. When you import a package, <strong><code>package declaration is used to create package reference variable.</code></strong></p>
<p><strong>Export name(var or method from a package)</strong><br>A name is exported if it <code>begins with a capital letter</code>, exported means it can be accessed from other package.</p>
<p><strong>package scope</strong><br>A package scope is a region within a package where a declared variable(<strong>even it’s not exported</strong>) is accessible from within a package (<code>across all the files in the package</code>).</p>
<p><strong>package init()</strong><br><code>func init()&#123;&#125;</code> is called by Go when a package is initialized. It does not take any arguments and does not return any value, hence <code>func init()&#123;&#125;</code> is a special function of xx.go file should be only one for a package.</p>
<p><strong>Package alias</strong><br>When you import a package, <code>Go creates a variable using the package declaration of the package</code>. If you are importing multiple packages with the same name, this will lead to a conflict, use alias to avoid conflict if happens.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    log <span class="string">&quot;fmt&quot;</span> <span class="comment">// log is alias for fmt package.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>Publish your package</strong><br><code>Publish it on GitHub and you are good to go</code>. If your package is executable, people can use it as a command-line tool else they can import it in a program and use it as a utility module.</p>
<h3 id="inside-import-statement"><a href="#inside-import-statement" class="headerlink" title="inside import statement"></a>inside import statement</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> github.com/example/hello</span><br><span class="line"><span class="comment">// github.com/example is a path!!!</span></span><br><span class="line"><span class="comment">// hello is also a path under example/</span></span><br><span class="line"><span class="comment">// as you know package name can be different with dir who contains it, but most of time it&#x27;s same.</span></span><br></pre></td></tr></table></figure>

<p>Above statement essentially means that <strong>import package present at directory <code>hello</code>. It doesn’t mean import package hello, it import package under <code>hello/</code></strong>, that also means package name can be different with its directory.</p>
<p><strong>Note</strong></p>
<ul>
<li>Go does NOT allow multiple packages at same directory</li>
<li><strong>import is not recursive</strong>, if you have packages under subdirectory, you should import that subdirectory as well.</li>
<li><font color='red'>dot import</font>: If an explicit period (.) appears instead of a name, all the package’s exported identifiers declared in that package’s package block will be declared in the importing source file’s file block and must be accessed without a qualifier. <code>import . &quot;fmt&quot;</code>, then use <code>Println(&quot;hello&quot;)</code>. but it’s not good way.</li>
</ul>
<h3 id="searching-package"><a href="#searching-package" class="headerlink" title="searching package"></a>searching package</h3><p><strong>Path of searching packages depends on GO111MODULE is enabled or not but both way check standard library firstly</strong></p>
<p><code>$GOROOT=/usr/local/go</code> for standard library like <code>fmt, path, cmd, buffio etc</code>.<br><code>$GOPATH=/home/go</code> for third-party library.</p>
<p><font color='red'><strong>GO111MODULE&#x3D;on you must have go.mod in your project to build and run!!!</strong>  </font></p>
<ul>
<li><font color='red'><code>$CURRENT_DIR/vendor</code> is NOT checked anymore!!!</font></li>
<li><code>$GOROOT/pkg/&#123;arch&#125;/xxx.a</code>  precompiled</li>
<li><code>$GOROOT/src</code> standard library for source code</li>
<li><code>$GOPATH/pkg/mod/xxx</code> workspace for source code</li>
</ul>
<p><strong>GO111MODULE&#x3D;off</strong>  </p>
<ul>
<li><code>$CURRENT_DIR/vendor</code> NOT <code>$CURRENT_DIR/vendor/src</code>!!!</li>
<li><code>$GOROOT/pkg/&#123;arch&#125;/xxx.a</code> precompiled</li>
<li><code>$GOROOT/src</code> standard library for source code</li>
<li><code>$GOPATH/pkg/&#123;arch&#125;/xxx.a</code> precompiled</li>
<li><code>$GOPATH/src/xxx</code> workspace for source code </li>
<li><font color='red'><strong>Must put your project at $GOPATH&#x2F;src to make it build</strong></font></li>
</ul>
<p>when GO111MODULE&#x3D;off, <code>go get</code> would fetch all the sources by <strong>using their import paths and store them in $GOPATH&#x2F;src</strong>. There was <strong><code>no versioning storing a single git checkout of every package</code></strong> and the ‘master’ branch would represent a stable version of the package.</p>
<p>Go Modules (GO111MODULE&#x3D;on) were introduced with Go 1.11, Go Modules <strong>stores tagged versions with go.mod keeping track of each package’s version</strong></p>
<ul>
<li>manually run  <code>GO111MODULE=on go get</code> would fetch all the sources with tagged versions and saved it at <code>$GOPATH/pkg/mod/</code></li>
<li>automatically run <strong><code>go get</code> when you run <code>go build or go install</code></strong> based on tagged version from go.mod of each module,<strong>you must have go.mod of each module</strong></li>
</ul>
<h3 id="import-package"><a href="#import-package" class="headerlink" title="import package"></a>import package</h3><p><code>import</code> statement imports the package under that path, as one package per directory, hence only one package is imported for the path, most of time ,<code>for easy to use, path and package name are same</code>, but the path and package name can be different, if they are different, you need to know both package path and package name, while if they are same, you just need to know one, details refer to <a target="_blank" rel="noopener" href="https://golangbyexample.com/package-folder-name-golang/">package and folder name</a></p>
<h3 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a>go env</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">check all <span class="built_in">env</span> of go</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">env</span></span></span><br><span class="line">GOENV=&quot;/home/ubuntu/.config/go/env&quot;</span><br><span class="line">GO111MODULE=&quot;on&quot;</span><br><span class="line">GOBIN=&quot;&quot;</span><br><span class="line">GOMODCACHE=&quot;/home/ubuntu/go/pkg/mod&quot;</span><br><span class="line">GOPATH=&quot;/home/ubuntu/go&quot;</span><br><span class="line">GOROOT=&quot;/usr/local/go&quot;</span><br><span class="line">GOPROXY=&quot;https://goproxy.io,direct&quot;</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span> <span class="built_in">env</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi /home/ubuntu/.config/go/env</span></span><br><span class="line">GOBIN=&quot;&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">env</span> -w GOBIN=<span class="string">&quot;&quot;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>frequently used env</strong></p>
<ul>
<li><code>$GOBIN: bin dir of workspace which stores binary for application after go install, default $GOPATH/bin</code></li>
<li><code>$GOMODCACHE: mod(module) cache source code(xx.go) if mod is not standard library when GO111MODULE is on(mod with version), default $GOPATH/pkg/mod.</code></li>
<li><code>$GOPATH: working path, has </code>bin&#x2F;, src&#x2F;, mod&#x2F;<code>, src is used to store download non-standard library(without version)</code></li>
<li><code>$GOROOT: Standard library of Go</code></li>
</ul>
<h3 id="workspace"><a href="#workspace" class="headerlink" title="workspace"></a>workspace</h3><p>A <strong>workspace</strong> is Go’s way to facilitate project management. A workspace, in a nutshell, is a <strong>directory on your system where Go looks for source code files, manages dependency packages and build distribution binary files</strong></p>
<p><font color='red'>A workspace can have multiple applications, if different apps refer to same package, they share the same package files at this workspace.</font></p>
<p><font color='red'>You can have as many workspaces as you want, as long as you keep <code>GOPATH</code> environment variable pointed to the current working workspace directory.</font></p>
<p>A Go workspace directory must have three sub-directories <code>src, pkg and bin</code>, <code>$GOPATH points to active workspace</code>.</p>
<ul>
<li><p>pkg:</p>
<ul>
<li>The pkg directory contains Go package objects(get by <code>go get</code>). They are the compiled versions of the original package source code or source code at pkg&#x2F;mod for GO111MODULE enabled.</li>
</ul>
</li>
<li><p>bin:</p>
<ul>
<li>The bin directory contains the binary executable files. <code>These files are created by go install commands. go install command runs go build command internally and then outputs these files to the bin directory</code></li>
</ul>
</li>
<li><p>src:  </p>
<ul>
<li>The src directory contains Go packages. A package in nutshell is a project directory containing Go source code (.go files). Any packages installed using <code>GO111MODULE=off go get</code> command will reside here as well (and its dependency packages).</li>
</ul>
</li>
</ul>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>Go code is grouped into packages, and <code>packages are grouped into modules</code>, a module can have several related packages but not at same directory, <strong>a module is logical groups to track dependencies of all packages in go.mod file, a module only needs one go.mod file at root directory, subdirectory does not need it all.</strong> </p>
<p>Go must provide all of their dependencies via either Go modules with a go.mod file, or a vendor directory, go.mod is created with <code>go mod init example.com/greetngs</code> and updated when run <code>go mod tidy</code>, go.mod only tracks the deps(write a record in it), the downloaded modules is saved at $GOMODCACHE.</p>
<p>In <code>GO111MODULE=off, if a package or a parent folder(parent&#39;s parent ...) of a package contains folder named vendor it will be searched for dependencies using the vendor folder as an import path root</code>. While vendor folders can be nested, in most cases it is not advised or needed. <strong>when GO111MODULE&#x3D;off Any package in the vendor folder will be found before the standard library.</strong></p>
<h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p><strong>useful command used within a module</strong>  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">initialize new module <span class="keyword">in</span> current directory</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use example.com/greetings.</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If you publish a module, this must be a path from <span class="built_in">which</span> your module can be downloaded by Go tools. Mostly it<span class="string">&#x27;s your code&#x27;</span>s repository.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go mod init example.com/greetings</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">edit go.mod from <span class="built_in">command</span> line</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go mod edit</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">edit <span class="built_in">source</span> code, import packages etc, <span class="keyword">then</span> run go mod tidy</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go mod tidy ensures that the go.mod file matches the <span class="built_in">source</span> code <span class="keyword">in</span> the module. It adds any missing module requirements necessary to build the current module<span class="string">&#x27;s packages and dependencies, and it removes requirements on modules that don&#x27;</span>t provide any relevant packages. It also adds any missing entries to go.sum and removes unnecessary entries.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add missing and remove unused modules, download package <span class="keyword">if</span> not found locally</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go mod tidy</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">show all import information</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go list -m -json all</span></span><br></pre></td></tr></table></figure>

<p><strong>project layout</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|-- prj</span><br><span class="line">|   |-- greetings</span><br><span class="line">|   |   |-- go.mod</span><br><span class="line">|   |   `-- greetings.go</span><br><span class="line">|   `-- hello</span><br><span class="line">|       |-- go.mod</span><br><span class="line">|       `-- hello.go</span><br></pre></td></tr></table></figure>


<h4 id="creating-a-module-library-used-by-others"><a href="#creating-a-module-library-used-by-others" class="headerlink" title="creating a module(library) used by others"></a>creating a module(library) used by others</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> greetings</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> greetings</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go mod init example.com/greetings</span></span><br><span class="line">go: creating new go.mod: module example.com/greetings</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go.mod file to track your code<span class="string">&#x27;s dependencies, it&#x27;</span>s updated automatically.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vi greatings.go</span></span><br><span class="line"></span><br><span class="line">package greetings</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// Hello returns a greeting for the named person.</span><br><span class="line">func Hello(name string) string &#123;</span><br><span class="line">    // Return a greeting that embeds the name in a message.</span><br><span class="line">    message := fmt.Sprintf(&quot;Hi, %v. Welcome!&quot;, name)</span><br><span class="line">    return message</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">optional</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go tool compile -pack greetings.go</span></span><br><span class="line">greetings.a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go tool compile greetings.go</span></span><br><span class="line">greetings.o</span><br></pre></td></tr></table></figure>

<h4 id="creating-a-module-runnable-application"><a href="#creating-a-module-runnable-application" class="headerlink" title="creating a module(runnable application)"></a>creating a module(runnable application)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> hello</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> hello</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go mod init example.com/hello</span></span><br><span class="line">go: creating new go.mod: module example.com/hello</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vi hello.go</span></span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">    &quot;example.com/greetings&quot; //By convention, the package name is the same as the last element of the import path</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // Get a greeting message and print it.</span><br><span class="line">    message := greetings.Hello(&quot;Gladys&quot;)</span><br><span class="line">    fmt.Println(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For production use, you’d publish the example.com/greetings module from its repository, go tools will download it from there</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For now, because you haven<span class="string">&#x27;t published the module yet, you need to adapt the example.com/hello module so it can find the example.com/greetings code on your local file system.</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">use the go mod edit command to edit the example.com/hello module to redirect Go tools from its module path (where the module isn&#x27;</span>t) to the <span class="built_in">local</span> directory (<span class="built_in">where</span> it is)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go mod edit -replace=example.com/greetings=../greetings</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add dependency <span class="keyword">in</span> go.mod</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go mod tidy</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build &amp; ./hello  // build run, binary is written to disk</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run .           // build, run without writing binary to disk</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go install &amp; hello // build, install, and run</span></span><br></pre></td></tr></table></figure>

<h4 id="Importing-packages-from-your-module"><a href="#Importing-packages-from-your-module" class="headerlink" title="Importing packages from your module"></a>Importing packages from your module</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@centos go]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">|-- go.mod</span><br><span class="line">|-- greet</span><br><span class="line">|   `-- greet.go</span><br><span class="line">`-- hello.go</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br><span class="line">(base) [root@centos go]<span class="comment"># cat go.mod </span></span><br><span class="line">module example.com/hello</span><br><span class="line"></span><br><span class="line">go 1.15</span><br><span class="line"></span><br><span class="line"><span class="comment"># module path: example.com/hello</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;example.com/hello/greet&quot;</span> <span class="comment">// import this way: module_path/greet</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        greet.Say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h4><p>It is a folder found <strong>in a module that stores a copy of all the code the module depends on</strong>. The code is used to compile the final executable when the go build command is run with <code>GO111MODULE=off</code>.</p>
<p>By default, there is no vendor folder at all, but you can <strong>create it with <code>go mod vendor</code> or <code>govendor</code> <a target="_blank" rel="noopener" href="https://shockerli.net/post/go-package-manage-tool-govendor/">govendor tool</a></strong>, after this all deps are copied to vendor fold, that means <code>you can build your project without downloading deps if you switch to another machine or the deps are deleted from Internet, you have a total copy of it.</code></p>
<p>It’s old way, should not use it anymore, refer to <a target="_blank" rel="noopener" href="https://go.dev/blog/migrating-to-go-modules">migrate to go mod</a> to update your project.</p>
<h2 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h2><p><strong>No exception in Go like python or C++</strong>, library should return a value and err if want caller check error.</p>
<p>In Go, there is a built-in <code>error type</code> which defines like this</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>So that any type who satisfies this interface implements <code>Error() method</code> can be used as <code>error</code>.</p>
<ul>
<li><code>fmt.Errorf(&quot;error %d&quot;, 10) returns struct instance which implements such method</code></li>
<li>The fmt package formats an error value by calling its Errorf() method.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">great</span><span class="params">(a, b <span class="type">int</span>)</span></span>(<span class="type">int</span>, <span class="type">error</span>) &#123;                                              </span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;                                                                  </span><br><span class="line">        <span class="keyword">return</span> a, <span class="literal">nil</span>                                                           </span><br><span class="line">    &#125;                                                                           </span><br><span class="line">    <span class="keyword">return</span> b, fmt.Errorf(\<span class="string">&quot;%v is not great than %v\&quot;, a, b)                     </span></span><br><span class="line"><span class="string">&#125;                                                                               </span></span><br></pre></td></tr></table></figure>

<h3 id="recover-from-panic"><a href="#recover-from-panic" class="headerlink" title="recover from panic"></a>recover from panic</h3><p><code>defer function is called even panic happens.</code></p>
<p>When <code>panic is called</code>, including implicitly for run-time errors such as indexing a slice out of bounds or failing a type assertion, <code>it immediately stops execution of the current function and begins unwinding the stack of the goroutine, running any deferred functions along the way. If that unwinding reaches the top of the goroutine&#39;s stack, the program dies.</code> </p>
<p>A call to <code>recover()</code> stops the unwinding and returns the argument passed to panic. Because the only code that runs while unwinding is inside deferred functions, recover is only useful inside deferred functions.</p>
<p><strong>One application of recover is to shut down a failing goroutine inside a server without killing the other executing goroutines.</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">    works := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> works &#123;</span><br><span class="line">        <span class="keyword">go</span> safelyDo(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;panic when processing work&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;work is done&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;work failed:&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    do(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server()</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> number</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;not support negative adding&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a + b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v, err := add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;1+2=&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    v, err = add(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       fmt.Println(<span class="string">&quot;-1+2=&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<pre><code>1+2= 3
not support negative adding
</code></pre>
<h2 id="cgo-call-C-in-Go"><a href="#cgo-call-C-in-Go" class="headerlink" title="cgo(call C in Go)"></a>cgo(call C in Go)</h2><p>Cgo lets Go packages call C code. In order to use C code in Go, you first need to import a “pseudo-package”, “C” a special name interpreted by cgo as a reference to C’s name space, and include headers needed by C code when compiling with fixed format.</p>
<p>If the import of <code>&quot;C&quot; is immediately preceded by a comment, that comment, called the preamble, is used as a header when compiling the C parts of the package by gcc!</code>, The preamble may contain any C code, including function and variable declarations and definitions. These may then be referred to from Go code as though they were defined in the package “C”. <strong>All names declared in the preamble may be used, even if they start with a lower-case letter.</strong></p>
<p><strong>NOTE</strong><br><code>CFLAGS, CPPFLAGS, CXXFLAGS, FFLAGS and LDFLAGS may be defined with pseudo #cgo directives within these comments</code> to tweak the behavior of the C, C++ or Fortran compiler.</p>
<p><strong>Note: No space line between import “C” and its header comment</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;xxx.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;xxx.c&gt; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OR if needs to link other library or set FLAG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #cgo CFLAGS: -DPNG_DEBUG=1</span></span><br><span class="line"><span class="comment">// #cgo linux CFLAGS: -DLINUX=1</span></span><br><span class="line"><span class="comment">// #cgo LDFLAGS: -lpng</span></span><br><span class="line"><span class="comment">// #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;png.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="type-mapping-between-C-and-go"><a href="#type-mapping-between-C-and-go" class="headerlink" title="type mapping between C and go"></a>type mapping between C and go</h3><p>The standard C numeric types are available under the names</p>
<ul>
<li>C.char, C.schar (signed char), C.uchar (unsigned char)</li>
<li>C.short, C.ushort (unsigned short)</li>
<li>C.int, C.uint (unsigned int)</li>
<li>C.long, C.ulong (unsigned long), C.longlong (long long), C.ulonglong (unsigned long long)</li>
<li>C.float, C.double</li>
<li>The C type <em><em>void</em> is represented by Go’s unsafe.Pointer.</em>*</li>
<li>The C types __int128_t and __uint128_t are represented by [16]byte.</li>
<li>C.struct_person{} refer to <code>struct person&#123;&#125;</code> defined in C</li>
<li>C.sizeof_struct_person get the len of <code>struct person&#123;&#125;</code> defined in C</li>
</ul>
<p><strong>Access struct</strong></p>
<ul>
<li>To access a struct, union, or enum type directly, prefix it with struct_, union_, or enum_, as in <code>C.struct_stat.</code></li>
</ul>
<p><strong>sizeof</strong></p>
<ul>
<li>The size of any C type T is available as C.sizeof_T, like <code>C.sizeof_struct_stat == sizeof(struct stat)</code></li>
</ul>
<p><strong>pass Go array to C function</strong></p>
<ul>
<li>n, err :&#x3D; C.f(&amp;array[0]) &#x2F;&#x2F; pass address of the first element.</li>
</ul>
<p><strong>Memory allocations made by C code are unknown to Go’s memory manager</strong>.   </p>
<ul>
<li>When you create a C string with <code>C.CString</code> (or any C memory allocation) you must remember to free the memory when you’re done with it by calling C.free.</li>
</ul>
<h3 id="write-C-within-go-file"><a href="#write-C-within-go-file" class="headerlink" title="write C within go file"></a>write C within go file</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// void hello() &#123;</span></span><br><span class="line"><span class="comment">//     printf(&quot;hello\n&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C.hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="write-C-out-of-go-compile-as-library-go-import-the-library"><a href="#write-C-out-of-go-compile-as-library-go-import-the-library" class="headerlink" title="write C out of go, compile as library, go import the library"></a>write C out of go, compile as library, go import the library</h3><p><strong>sum.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;say: &#x27;%s&#x27; adding\n&quot;</span>, msg);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>sum.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">char</span>* msg)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Then create shared library</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -fPIC -c sum.c</span><br><span class="line">$ gcc -shared -o libsum.so sum.o</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">libsum.so  sum.c  sum.h  sum.o  test.go</span><br></pre></td></tr></table></figure>

<p><strong>test.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// #cgo CFLAGS: -I./</span></span><br><span class="line"><span class="comment">// #cgo LDFLAGS: -L./ -lsum</span></span><br><span class="line"><span class="comment">// #include &quot;sum.h&quot;</span></span><br><span class="line"><span class="comment">// #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C.hello()</span><br><span class="line"></span><br><span class="line">    a := C.<span class="type">int</span>(<span class="number">1</span>)</span><br><span class="line">    b := C.<span class="type">int</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">// create memory without go track</span></span><br><span class="line">    msg := C.CString(<span class="string">&quot;starting&quot;</span>)</span><br><span class="line">    c := C.sum(a, b, msg)</span><br><span class="line">    <span class="comment">// free it.</span></span><br><span class="line">    C.free(unsafe.Pointer(msg)) <span class="comment">//defined in stdlib.h</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;sum(1,2)=%v\n&quot;</span>, <span class="type">int</span>(c))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run test.go</span><br><span class="line"></span><br><span class="line">say: <span class="string">&#x27;&#x27;</span> adding</span><br><span class="line"><span class="built_in">sum</span>(1,2)=3</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://golang.org/cmd/cgo/">cgo guideline</a></p>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p><code>func NumCPU() int</code></p>
<blockquote>
<p>NumCPU returns the number of logical CPUs usable by the current process.<br>The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected. </p>
</blockquote>
<p><code>func GOMAXPROCS(n int) int</code></p>
<blockquote>
<p>GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. It defaults to the value of runtime.NumCPU. If n &lt; 1, it does not change the current setting. This call will go away when the scheduler improves. </p>
</blockquote>
<p><code>func Gosched()</code></p>
<blockquote>
<p>Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically.<br><a target="_blank" rel="noopener" href="https://pkg.go.dev/runtime">runtime library</a></p>
</blockquote>
<h2 id="concurrency-multiple-threads"><a href="#concurrency-multiple-threads" class="headerlink" title="concurrency(multiple threads)"></a>concurrency(multiple threads)</h2><p>The channel introduces many use cases in which channels are used to <code>do data synchronizations among goroutines</code>. In fact, channels are not the only synchronization techniques provided in Go. There are some other synchronization techniques supported by Go. For some <code>specified circumstances, using the synchronization techniques other than channel are more efficient and readable than using channels</code>.</p>
<p><strong>ways to use channel, think <code>chan bool</code> as type</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">var</span> m <span class="keyword">chan</span> <span class="type">bool</span> <span class="comment">// bool channel</span></span><br><span class="line">- <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>] <span class="keyword">chan</span> <span class="type">bool</span> <span class="comment">// each element of map is a bool channel.</span></span><br><span class="line">- <span class="keyword">var</span> m <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// int channel</span></span><br><span class="line">- <span class="keyword">var</span> m []<span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// each element of the array is an int channel</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums []<span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;&#125; <span class="comment">// reading channel as return value</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;&#125; <span class="comment">// channel as parameter</span></span><br><span class="line">- <span class="keyword">var</span> ch2 <span class="keyword">chan</span>&lt;- <span class="type">int</span><span class="comment">// channel only for writing</span></span><br><span class="line">- <span class="keyword">var</span> ch3 &lt;-<span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// channel only for reading</span></span><br><span class="line"></span><br><span class="line">- ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">- ch5 := &lt;-<span class="keyword">chan</span> <span class="type">int</span>(ch4) <span class="comment">// convert to unary channel for reading</span></span><br><span class="line">- ch6 := <span class="keyword">chan</span>&lt;- <span class="type">int</span>(ch4) <span class="comment">// convert to unary channel for writing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return a channel for reading</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums []<span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    args        []<span class="type">int</span></span><br><span class="line">    f           <span class="function"><span class="keyword">func</span><span class="params">([]<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">    resultChan  <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// channel var, need to initialize by make(chan int) later on</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p>A goroutine is a <code>lightweight &#39;thread&#39; managed by the Go runtime</code>. by default GO creates a pool of linux threads, the number of this pool equals to number of processor, goroutine runs on these threads.</p>
<p><code>go f(x, y, z)</code></p>
<p><strong><code>The evaluation of f, x, y, and z happens in the current goroutine</code> and the execution of f happens in the new goroutine.</strong></p>
<p><strong>goroutines run in the same address space</strong>, so access to shared memory must be synchronized. The <code>sync</code> package provides useful primitives.</p>
<p><strong><font color='red'>communication between goroutines</font></strong></p>
<p>Channels are a typed conduit through which you can send and receive values with the <code>channel operator, &lt;-</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// create a channel with buffer size 0, no buffer, which only access int as its message</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;- is an operator, NO operator -&gt;!!!</span></span><br><span class="line"><span class="comment">// the left side is receiver, the right side is sender</span></span><br><span class="line"></span><br><span class="line">ch &lt;- v        <span class="comment">// Send v to channel ch. blocked until data is read!!!</span></span><br><span class="line">v := &lt;- ch     <span class="comment">// Receive from ch, and assign value to v blocked until data is sent!!!</span></span><br><span class="line">v, ok := &lt;- ch <span class="comment">// check if channel is close, when closed, v is nil, ok is false, otherwise, v is value, ok is true</span></span><br><span class="line">&lt;- ch          <span class="comment">// discard result</span></span><br></pre></td></tr></table></figure>

<p>By default, <strong>send and receive block until the other side is ready</strong>. This allows goroutines to synchronize without explicit locks or condition variables.</p>
<p>Receivers always block until there is data to receive. If the channel is unbuffered(buffer size 0), the sender blocks until the receiver has received the value. If the channel has a buffer, the sender blocks only until if the buffer is full, this means waiting until some receiver has retrieved a value.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) <span class="comment">// buffer is 10, if no one receives, the 11th sending blocks!!!</span></span><br></pre></td></tr></table></figure>
<p><font color='red'>Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty</font></p>
<p>A sender can close a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after<br><code>v, ok := &lt;- ch</code>  </p>
<p><strong>ok is false if there are no more values to receive and the channel is closed, ok is true if more values to receive, even it’s closed!!!</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    c &lt;- <span class="number">3</span></span><br><span class="line">    c &lt;- <span class="number">4</span></span><br><span class="line">    c &lt;- <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    d, ok := &lt;-c</span><br><span class="line">    fmt.Println(d, ok)</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    d, ok = &lt;-c</span><br><span class="line">    fmt.Println(d, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line"><span class="number">3</span> <span class="literal">true</span></span><br><span class="line"><span class="number">4</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><font color='red'><strong>The loop for i :&#x3D; range c receives values from the channel repeatedly until it is closed.</strong></font></p>
<p><font color='red'><strong>Note:</strong></font></p>
<ul>
<li>Only the sender should close a channel, never the receiver</li>
<li><code>Sending on a closed channel will cause a panic.</code> </li>
<li><code>Reading on closed channel, error happens, but not panic!!</code></li>
<li>For zero buffer channel, send and receive block until the other side is ready</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// chan int, type of channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x <span class="comment">// send x to channel</span></span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c) <span class="comment">// close the channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass channel to another routine</span></span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        <span class="comment">// receives from channel until it&#x27;s closed, blocked if no more data in the channel</span></span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>0
1
1
2
3
5
8
13
21
34
</code></pre>
<h3 id="multiple-channels"><a href="#multiple-channels" class="headerlink" title="multiple channels"></a>multiple channels</h3><p>The select statement lets a goroutine wait on multiple communication operations.</p>
<p><strong>A select blocks until one of its cases can run, then it executes that case. the default case in a select runs if no other case is ready(no event on channel), select only works for channel, not socket fd, if you want to monitor multiple fds for high performance use <a target="_blank" rel="noopener" href="https://github.com/panjf2000/gnet">gnet</a></strong></p>
<ul>
<li>if no default case, select quits until one channel is ready!!! otherwise block for ever, <code>so it&#39;s one time execution, if you need to select more time, put it in for loop!!!</code></li>
</ul>
<p><strong><font color='red'>It chooses one at random if multiple channels are ready</font></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>, quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">// infinite loop</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">// x is the result written to channel</span></span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            <span class="comment">// go down when write to channel is done, wake from block.</span></span><br><span class="line">            <span class="comment">// go down only when x is read by reader as it&#x27;s unbuffered channel</span></span><br><span class="line">            x, y = y, x+y</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">case</span> _, ok:= &lt;-quit: <span class="comment">// run this case only when channel is ready successfully!!!</span></span><br><span class="line">            fmt.Println(ok)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            v := &lt;-c <span class="comment">// full format v, ok: = &lt;-c</span></span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//write empty to signal channel quit</span></span><br><span class="line">    &#125;() <span class="comment">// here call the unnamed function</span></span><br><span class="line"></span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>0
1
1
2
3
5
8
13
21
34
true
</code></pre>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>What we just want to make sure only one goroutine can access a shared variable at a time to avoid conflicts?</p>
<p>This concept is called mutual exclusion, and the conventional name for the data structure that provides it is mutex.</p>
<p>Go’s standard library provides mutual exclusion with <code>sync.Mutex</code> and its two methods:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br><span class="line">...</span><br><span class="line">mu.UnLock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line">mu.RLock() <span class="comment">// reader</span></span><br><span class="line">...</span><br><span class="line">mu.RUnLock()</span><br><span class="line"></span><br><span class="line">mu.Lock() <span class="comment">// writer</span></span><br><span class="line">...</span><br><span class="line">mu.UnLock()</span><br></pre></td></tr></table></figure>

<p>We can define a block of code to be executed in mutual exclusion by surrounding it with a call to <code>Lock and Unlock</code>.</p>
<p>We can also use defer to ensure the mutex will be unlocked as in the Value method.</p>
<p>mutex is not associated with particular goroutine, it’s global and can be accessed by all goroutines, locked when the mutex lock bit is set.</p>
<p><strong>NOTE</strong></p>
<ul>
<li>nested is not supported<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := sync.Mutex&#123;&#125;</span><br><span class="line">m.Lock()</span><br><span class="line">m.Lock()<span class="comment">// block for ever here!!!</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    m.Lock()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hi&quot;</span>)</span><br><span class="line">        m.Unlock() <span class="comment">// make a notification</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// if m.Lock runs before m.Unlock in gorountine, it blocks as it&#x27;s alrealdy locked above</span></span><br><span class="line">    <span class="comment">// as lock on unlocked mutext will block!!!</span></span><br><span class="line">    m.Lock() <span class="comment">// wait to be notified</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Bye&quot;</span>) <span class="comment">// Byes is always after Hi printed!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>Hi
Bye
</code></pre>
<h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p>Each <code>sync.WaitGroup</code> value maintains a counter internally. The initial value of the counter is zero.</p>
<p>The <code>*WaitGroup</code> type has three methods: <code>Add(delta int), Done() and Wait()</code>.</p>
<ul>
<li>we can call the <code>wg.Add(delta) method</code> to change the counter value maintained by wg.</li>
<li>the method call<code> wg.Done()</code> is totally equivalent to the method call wg.Add(-1).</li>
<li>if a call <code>wg.Add(delta) (or wg.Done()) modifies the counter maintained by wg to negative, panic will happen</code>.</li>
<li>when a goroutine calls wg.Wait(),<ul>
<li>if the counter maintained by wg is already zero, then the call wg.Wait() can be viewed as a no-op.</li>
<li>otherwise (the counter is positive), the goroutine will enter blocking state. It will enter running state again (a.k.a., the call wg.Wait() returns) when another goroutine modifies the counter to zero, generally by calling wg.Done().</li>
</ul>
</li>
</ul>
<p><strong>Generally, a WaitGroup value is used for the scenario that one goroutine waits until all of several other goroutines finish their respective jobs.</strong></p>
<p><strong>Note</strong></p>
<ul>
<li><p>The <code>Wait()</code> method can be called in multiple goroutines. When the counter becomes zero, all of them will be notified, in a broadcast way. </p>
</li>
<li><p>A WaitGroup value can <code>be reused after one call to its Wait method returns</code>. But please note that <strong>each Add method call with a positive delta that occurs when the counter is zero must happen before any Wait call starts</strong>, otherwise, data races may happen.</p>
</li>
<li><p>Must <code>call Add() in main goroutine</code> not the one runs the job.</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// set seed</span></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> N = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> values [N]<span class="type">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    </span><br><span class="line">    wg.Add(N)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        i := i</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n) </span></span><br><span class="line">            <span class="comment">// from the default Source. It panics if n &lt;= 0. </span></span><br><span class="line">            values[i] = <span class="number">50</span> + rand.Int31n(<span class="number">50</span>) <span class="comment">//</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;Done:%v\n&quot;</span>, i)</span><br><span class="line">            wg.Done() <span class="comment">// &lt;=&gt; wg.Add(-1)</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="comment">// All elements are guaranteed to be</span></span><br><span class="line">    <span class="comment">// initialized now.</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;values:%v\n&quot;</span>, values)</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>Done:4
Done:2
Done:1
Done:3
Done:0
values:[63 93 53 59 60]
</code></pre>
<h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>A <code>*sync.Once</code> value has a Do(f func()) method, which takes a solo parameter with type <code>func()</code>.</p>
<p>The code in the invoked argument function(<code>doSomething(</code>)) is guaranteed to be executed before any <code>once.Do()</code> method call returns.<br>Generally, <code>a Once value is used to ensure that a piece of code will be executed exactly once in concurrent programming</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line">    doSomething := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// only runs once!!!</span></span><br><span class="line">        x++</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello in once&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">//Hello is guaranteed to be printed before all five world!!!</span></span><br><span class="line">            once.Do(doSomething)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// all below code runs after soSomething return</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;world!&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x = %v\n&quot;</span>, x) <span class="comment">// x = 1</span></span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>Hello in once
world!
world!
world!
world!
world!
x = 1
</code></pre>
<h3 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h3><p>The <code>sync.Cond</code> type provides an efficient way to do notifications among goroutines.</p>
<p>Each <code>sync.Cond</code> value holds a sync.Locker field with name L. <code>The field value is often a value of type *sync.Mutex or *sync.RWMutex</code>. So, <code>in order to use Cron, you must have a mutex as well!!!</code></p>
<ul>
<li><p><code>c.Wait()</code> <strong>must be called when c.L is locked</strong>, otherwise, a c.Wait() will cause panic. A c.Wait() call will first push the current caller goroutine into the waiting goroutine queue maintained by c, then call c.L.Unlock() to unlock&#x2F;unhold the lock c.L. then make the current caller goroutine enter blocking state. Once the caller goroutine is unblocked and enters running state again, c.L.Lock() will be called (in the resumed c.Wait() call) to try to lock and hold the lock c.L again, The c.Wait() call will exit after the c.L.Lock() call returns.</p>
</li>
<li><p>a <code>c.Signal()</code> call will <code>unblock the first goroutine</code> in (and remove it from) the waiting goroutine queue maintained by c, if the queue is not empty.</p>
</li>
<li><p>a <code>c.Broadcast()</code> call will <code>unblock all the goroutines</code> in (and remove them from) the waiting goroutine queue maintained by c, if the queue is not empty.</p>
</li>
</ul>
<p><code>cond.Broadcast() and cond.Signal()</code> are not required to be called when cond.L is locked. you can also call them after unlock.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> N = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> values [N]<span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cond needs a mutex inside</span></span><br><span class="line">    cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        d := time.Second * time.Duration(rand.Intn(<span class="number">5</span>)) / <span class="number">10</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            time.Sleep(d) <span class="comment">// simulate a workload</span></span><br><span class="line">            <span class="comment">// Changes must be made when</span></span><br><span class="line">            <span class="comment">// cond.L is locked.</span></span><br><span class="line">            cond.L.Lock()</span><br><span class="line">            values[i] = <span class="type">string</span>(<span class="string">&#x27;a&#x27;</span> + i)<span class="comment">// &#x27;a&#x27; is bytes(uint8!!!)</span></span><br><span class="line">            <span class="comment">//cond.Broadcast()</span></span><br><span class="line">            cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// &quot;cond.Broadcast()&quot; can be put here</span></span><br><span class="line">            <span class="comment">// when cond.L lock is unlocked. so that the waked one can get lock right now.</span></span><br><span class="line">            cond.Broadcast()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function must be called when</span></span><br><span class="line">    <span class="comment">// cond.L is locked.</span></span><br><span class="line">    checkCondition := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        fmt.Println(values)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">            <span class="comment">// we have the lock here.</span></span><br><span class="line">            <span class="keyword">if</span> values[i] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                <span class="comment">// not all values are set.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line">    <span class="comment">// not for loop.</span></span><br><span class="line">    <span class="keyword">for</span> !checkCondition() &#123;</span><br><span class="line">        <span class="comment">// Must be called when cond.L is locked.</span></span><br><span class="line">        cond.Wait() <span class="comment">// when blockes, mutex is unlocked!!! when waked up, it gets lock again!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>[         ]
[    e     ]
[ b   e     ]
[a b   e     ]
[a b c  e     ]
[a b c  e   h  ]
[a b c  e f  h  ]
[a b c d e f  h  ]
[a b c d e f  h  j]
[a b c d e f g h  j]
[a b c d e f g h i j]
</code></pre>
<h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p>go provides atomic operations <code>Add、CompareAndSwap、Load、Store、Swap</code> from <code>&quot;sync/atomic&quot;</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="type">uint32</span>, delta <span class="type">uint32</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt64</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> (<span class="built_in">new</span> <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint64</span><span class="params">(addr *<span class="type">uint64</span>, delta <span class="type">uint64</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, delta <span class="type">uintptr</span>)</span></span> (<span class="built_in">new</span> <span class="type">uintptr</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="type">int32</span>, old, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="type">int64</span>, old, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, old, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, old, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">(addr *unsafe.Pointer, old, <span class="built_in">new</span> unsafe.Pointer)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="type">int32</span>)</span></span> (val <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt64</span><span class="params">(addr *<span class="type">int64</span>)</span></span> (val <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint32</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> (val <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint64</span><span class="params">(addr *<span class="type">uint64</span>)</span></span> (val <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUintptr</span><span class="params">(addr *<span class="type">uintptr</span>)</span></span> (val <span class="type">uintptr</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadPointer</span><span class="params">(addr *unsafe.Pointer)</span></span> (val unsafe.Pointer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="type">int32</span>, val <span class="type">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="type">int64</span>, val <span class="type">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint32</span><span class="params">(addr *<span class="type">uint32</span>, val <span class="type">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint64</span><span class="params">(addr *<span class="type">uint64</span>, val <span class="type">uint64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, val <span class="type">uintptr</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="type">int32</span>, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (old <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt64</span><span class="params">(addr *<span class="type">int64</span>, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (old <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (old <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (old <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (old <span class="type">uintptr</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapPointer</span><span class="params">(addr *unsafe.Pointer, <span class="built_in">new</span> unsafe.Pointer)</span></span> (old unsafe.Pointer)</span><br></pre></td></tr></table></figure>

<h2 id="reflection"><a href="#reflection" class="headerlink" title="reflection"></a>reflection</h2><h3 id="from-specific-type-to-generic-type"><a href="#from-specific-type-to-generic-type" class="headerlink" title="from specific type to generic type"></a>from specific type to generic type</h3><p>you can convert any type to <code>interface &#123;&#125;</code> just for parameter passing.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b *<span class="type">int</span> = &amp;a</span><br><span class="line"><span class="keyword">var</span> c <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">i = a</span><br><span class="line">i = b</span><br><span class="line">i = c</span><br><span class="line"><span class="comment">// all are ok!!!</span></span><br></pre></td></tr></table></figure>

<h3 id="from-interface-to-specific-type"><a href="#from-interface-to-specific-type" class="headerlink" title="from interface to specific type"></a>from interface to specific type</h3><p><font color='red'>As any type can be converted to <code>interface&#123;&#125;</code> type</font>, but how can we convert it back to particular type.</p>
<p>A type assertion provides access to an interface value’s underlying concrete value.  </p>
<p><code>t := i.(T)</code>  If i does not hold a T, the statement will trigger a panic.  </p>
<p>This statement asserts that the interface value i holds the concrete type T and <code>assigns the underlying T value to the variable t.</code>  </p>
<p>To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.  </p>
<p><code>t, ok := i.(T)</code>  </p>
<p>If i holds a T(i is an instance of T), then t will be the underlying value and ok will be true.<br>If not, ok will be false and t will be the zero value of type T, and no panic occurs.   </p>
<p><font color='red' size=3> T is generic type, it can be <code>int or *int(*int is also a type)</code></font></p>
<p><strong>generic value, v, ok :&#x3D; i.(T) &#x2F;&#x2F; i is var of interface{}</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := i.(<span class="type">int</span>); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Twice %d is %d\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> v, ok := i.(*<span class="type">int</span>); ok&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Twice %d is %d\n&quot;</span>, *v, *v*<span class="number">2</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> v, ok = i.(<span class="type">string</span>); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s is %d bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type switch(only valid for switch)</strong><br>A <code>type switch</code> is like a regular switch statement, but the cases in a type switch specify types (not values), and those values are compared against the type of the value held by the given interface value.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123; <span class="comment">// i.(type), type is keyword here!!!</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>) <span class="comment">// v is type int</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v)) <span class="comment">// v is type string</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	do(<span class="number">21</span>)</span><br><span class="line">	do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://halfrost.com/go_reflection/">more about reflection</a></strong></li>
</ul>
<h3 id="Advanced-feature-between-interface-and-specfic-type"><a href="#Advanced-feature-between-interface-and-specfic-type" class="headerlink" title="Advanced feature between interface and specfic type"></a>Advanced feature between interface and specfic type</h3><p>you can convert any type to <code>interface &#123;&#125;</code> just for parameter passing</p>
<p><font color='red'><strong>but as <code>interface &#123;&#125;</code> has no method, hence you can NOT get more information about the type&#x2F;value it behinds, so <code>refection</code> package gives advanced feature.</strong></font></p>
<p><a target="_blank" rel="noopener" href="https://pkg.go.dev/reflect">reflect</a> implements run-time reflection, <code>allowing a program to manipulate objects with arbitrary types</code>. The typical use is to take a value with static type interface{} and <code>extract its dynamic type information by calling TypeOf(), which returns a Type(an interface defined in reflect package)</code>.</p>
<p>A call to <code>ValueOf() returns a Value(an interface defined in reflect package) representing the run-time data</code>. Zero takes a Type and returns a Value representing a zero value for that type.</p>
<ul>
<li><p>reflect.Type(<code>type interface &#123;&#125;</code>) returned by reflect.Typeof(any instance)</p>
<ul>
<li>rType implements generic methods defined by reflect.Type</li>
<li>mapType, ptrType, structType(which embed rType) etc implement specific methods defined reflect.Type which are valid for its type, so <strong>specific type implements all methods defined by reflect.Type</strong></li>
</ul>
</li>
<li><p>reflect.Value(<code>type Value struct &#123;&#125;</code>) returned by reflect.Valueof(any instance)</p>
<ul>
<li>Value has generic methods called by all values</li>
<li>Value has specific methods which are valid for specific type</li>
</ul>
</li>
</ul>
<p><strong>Method of specific type</strong></p>
<table>
<thead>
<tr>
<th>Kind</th>
<th>Methods applicable</th>
</tr>
</thead>
<tbody><tr>
<td>Int*</td>
<td>Bits</td>
</tr>
<tr>
<td>Uint*</td>
<td>Bits</td>
</tr>
<tr>
<td>Float*</td>
<td>Bits</td>
</tr>
<tr>
<td>Complex*</td>
<td>Bits</td>
</tr>
<tr>
<td>Array</td>
<td>Elem, Len</td>
</tr>
<tr>
<td>Chan</td>
<td>ChanDir, Elem</td>
</tr>
<tr>
<td>Func</td>
<td>In, NumIn, Out, NumOut, IsVariadic</td>
</tr>
<tr>
<td>Map</td>
<td>Key, Elem</td>
</tr>
<tr>
<td>Ptr</td>
<td>Elem</td>
</tr>
<tr>
<td>Slice</td>
<td>Elem</td>
</tr>
<tr>
<td>Struct</td>
<td>Field, FieldByIndex, FieldByName,FieldByNameFunc, NumField</td>
</tr>
</tbody></table>
<ul>
<li><p>Type.Elem() returns a type’s element type.</p>
</li>
<li><p>Type.PtrTo() returns the pointer type with element t.</p>
<ul>
<li>For example, if t represents type Foo, PtrTo(t) represents *Foo.</li>
</ul>
</li>
<li><p>v.Indirect() returns the value that v points to(v is pointer Value)</p>
<ul>
<li><code>v := reflect.Valueof(&amp;Person&#123;Name: &quot;tom&quot;&#125;), vv := v.Indirect()</code></li>
</ul>
</li>
<li><p>v.Addr() returns the pointer’s Value (v is object Value)</p>
<ul>
<li><code>v := reflect.Valueof(Person&#123;Name: &quot;tom&quot;&#125;), vp: = v.Addr()</code></li>
</ul>
</li>
</ul>
<p><img src="https://img.halfrost.com/Blog/ArticleImage/148_6_0.png" alt="reflection rule"></p>
<p><strong>Ref</strong>  </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://halfrost.com/go_reflection/#toc-1">Reflection examples</a></li>
<li><a target="_blank" rel="noopener" href="https://go.dev/blog/laws-of-reflection">Laws of Reflection</a></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`k1:&quot;v1&quot; k2:&quot;v2&quot;`</span></span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> Ident() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.Name + <span class="string">&quot; &quot;</span> + strconv.Itoa(p.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Say(msg <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msg + p.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;Name: <span class="string">&quot;tom&quot;</span>, id: <span class="number">10</span>&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*********************************************************************/</span></span><br><span class="line">    <span class="comment">// typeof from interface</span></span><br><span class="line">    rp := reflect.TypeOf(p)</span><br><span class="line">    <span class="comment">// rp.Elem() returns a type&#x27;s element type.</span></span><br><span class="line">    fmt.Printf(<span class="string">`p := Person&#123;&#125;</span></span><br><span class="line"><span class="string">type :%v</span></span><br><span class="line"><span class="string">size(byte): %v</span></span><br><span class="line"><span class="string">numField: %v</span></span><br><span class="line"><span class="string">numMethod: %v</span></span><br><span class="line"><span class="string">align: %v</span></span><br><span class="line"><span class="string">fieldalign: %v</span></span><br><span class="line"><span class="string">`</span>, rp.String(), rp.Size(), rp.NumField(), rp.NumMethod(), rp.Align(), rp.FieldAlign())</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Ident is not a method of Person</span></span><br><span class="line">    <span class="comment">// Go compiler auto converted p.Ident() to (&amp;p).Ident()</span></span><br><span class="line">    fmt.Println(p.Ident(), (&amp;p).Ident()) <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    m, ok := rp.MethodByName(<span class="string">&quot;Say&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;method name: %v, type: %v, index: %v\n&quot;</span>, m.Name, m.Type, m.Index)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Say method not found\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f, _ := rp.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;field name: %v, type: %v, Tag: %v\n&quot;</span>, f.Name, f.Type, f.Tag)</span><br><span class="line">    <span class="comment">// Type to Value: nv := reflect.New(rp)</span></span><br><span class="line">    <span class="comment">// if rp(map):    nv := reflect.MakeMap(rp)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*********************************************************************/</span></span><br><span class="line">    <span class="comment">// ValueOf from interface</span></span><br><span class="line">    v := reflect.ValueOf(p)</span><br><span class="line">    <span class="comment">// Value to Type: rp := v.Type()</span></span><br><span class="line">    rp = v.Type()</span><br><span class="line">    fmt.Printf(<span class="string">`p := Person&#123;&#125;</span></span><br><span class="line"><span class="string">type :%v</span></span><br><span class="line"><span class="string">size(byte): %v</span></span><br><span class="line"><span class="string">numField: %v</span></span><br><span class="line"><span class="string">numMethod: %v</span></span><br><span class="line"><span class="string">align: %v</span></span><br><span class="line"><span class="string">fieldalign: %v</span></span><br><span class="line"><span class="string">`</span>, rp.String(), rp.Size(), rp.NumField(), rp.NumMethod(), rp.Align(), rp.FieldAlign())</span><br><span class="line"></span><br><span class="line">    vName := v.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    name := vName.String()</span><br><span class="line">    <span class="comment">// we know it&#x27;s string has String() method, </span></span><br><span class="line">    <span class="comment">// otherwise name := vName.Interface().(*NType)</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;name=&quot;</span>, name)</span><br><span class="line">    vSay := v.MethodByName(<span class="string">&quot;Say&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> vSay.IsValid() &#123;</span><br><span class="line">        Say := vSay.Interface().(<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span>)</span><br><span class="line">        fmt.Println(Say(<span class="string">&quot;hello &quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;method Say not found&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******************************************************************************/</span></span><br><span class="line">    <span class="comment">// back to Person struct</span></span><br><span class="line">    p = v.Interface().(Person)</span><br><span class="line">    <span class="comment">// both print Person, but v.Interface() can&#x27; not access field as it&#x27;s interface!!!</span></span><br><span class="line">    fmt.Println(p, v.Interface())</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>p := Person&#123;&#125;
type :struct &#123; Name string &quot;k1:\&quot;v1\&quot; k2:\&quot;v2\&quot;&quot;; 𒀸id int &#125;
size(byte): 24
numField: 2
numMethod: 0
align: 8
fieldalign: 8
tom 10 tom 10
Say method not found
field name: Name, type: string, Tag: k1:&quot;v1&quot; k2:&quot;v2&quot;
p := Person&#123;&#125;
type :struct &#123; Name string &quot;k1:\&quot;v1\&quot; k2:\&quot;v2\&quot;&quot;; 𒀸id int &#125;
size(byte): 24
numField: 2
numMethod: 0
align: 8
fieldalign: 8
name= tom
method Say not found
&#123;tom 10&#125; &#123;tom 10&#125;
</code></pre>
<h2 id="import-cycle"><a href="#import-cycle" class="headerlink" title="import cycle"></a>import cycle</h2><p>Cyclic dependency is fundamentally a bad design and is a compile-time error in Golang(<code>error: import cycle not allowed</code>). we should change our design to solve this in either way.</p>
<p>Solve import cycle</p>
<ul>
<li>put them in the same package</li>
<li>use interface to solve the import cycle issue</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dep</span><br><span class="line">|-- a</span><br><span class="line">|   `-- a.go</span><br><span class="line">|-- b</span><br><span class="line">|   `-- b.go</span><br><span class="line">|-- c</span><br><span class="line">|   `-- c.go</span><br><span class="line">`-- main.go</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/mantishK/dep/b&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> PrintA() &#123;</span><br><span class="line">  fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewA</span><span class="params">()</span></span> *A &#123;</span><br><span class="line">  a := <span class="built_in">new</span>(A)</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RequireB</span><span class="params">()</span></span> &#123;</span><br><span class="line">  o := b.NewB()</span><br><span class="line">  o.PrintB()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/mantishK/dep/a&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b B)</span></span> PrintB() &#123;</span><br><span class="line">  fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewB</span><span class="params">()</span></span> *B &#123;</span><br><span class="line">  b := <span class="built_in">new</span>(B)</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RequireA</span><span class="params">()</span></span> &#123;</span><br><span class="line">  o := a.NewA()</span><br><span class="line">  o.PrintA()<span class="comment">// B wants to PrintA from A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/mantishK/dep/a&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := a.NewA()</span><br><span class="line">    o.PrintA()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><font color='red'><strong>Soloution</strong></font><br>we must introduce an interface in a new package say c. <code>This interface will have all the methods that are in struct A and are accessed by struct B</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">interface</span> &#123;</span><br><span class="line">    PrintA()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/mantishK/dep/b&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> PrintA() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewA</span><span class="params">()</span></span> *A &#123;</span><br><span class="line">    a := <span class="built_in">new</span>(A)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> PrintBFromA() &#123;</span><br><span class="line">    o := b.NewB(a)</span><br><span class="line">    o.PrintB()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/mantishK/dep/c&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    c c.C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b B)</span></span> PrintB() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewB</span><span class="params">(c c.C)</span></span> *B &#123;</span><br><span class="line">    <span class="comment">// pass interface(A) to instance b</span></span><br><span class="line">    b := <span class="built_in">new</span>(B)</span><br><span class="line">    b.c = c</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b B)</span></span> PrintAFromB() &#123;</span><br><span class="line">    <span class="comment">// access PrintA</span></span><br><span class="line">    b.c.PrintA()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/mantishK/dep/a&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/mantishK/dep/b&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := a.NewA()</span><br><span class="line">    o.PrintA()</span><br><span class="line">    o.PrintBFromA()</span><br><span class="line"></span><br><span class="line">    b := b.NewB(o)</span><br><span class="line">    b.PrintAFromB()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Deep-copy"><a href="#Deep-copy" class="headerlink" title="Deep copy"></a>Deep copy</h2><p>There is <code>no deep copy built-in function provided by Go</code>, if you want to deep copy, you have to copy it by your self, go only does shadow copy.</p>
<ul>
<li>For channel, slice, dict, interface, pointer, <strong>assigned var points to same memory.</strong></li>
<li>For <strong>struct, non-point, assigned var has its own memory, shadow copied.</strong></li>
<li><strong>Deep copy for map two ways.</strong><ul>
<li>Marshal –&gt; then Unmarshal</li>
<li>iterate each item, then do copy, if item is a map, recursive deep is needed!!!</li>
</ul>
</li>
<li>copy for slice, <code>copy(dst, src)</code>, not recursive, not deep.</li>
</ul>
<p><strong>Go does the same thing as C language</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">b := a <span class="comment">// b is copy of a, they points to same memory, same thing for map as well.</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(c, a) <span class="comment">// copy a to c, not support map, for map, you have to copy each by your self.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1 := Person &#123;Name: <span class="string">&quot;Jack&quot;</span>&#125;</span><br><span class="line">p2 := p1 <span class="comment">// p2 is copy of p1, they points to different memory.</span></span><br><span class="line"></span><br><span class="line">ps := []Person&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Name:<span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> ps &#123;</span><br><span class="line">    p.Name = <span class="string">&quot;cool&quot;</span> <span class="comment">// p is copy of array item.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ps is not changed at all</span></span><br></pre></td></tr></table></figure>

<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="Anonymous-struct-type"><a href="#Anonymous-struct-type" class="headerlink" title="Anonymous struct type"></a>Anonymous struct type</h2><p>Most of time, if we frequently use a struct type, we should define a new type, use it for short like this</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 Student = Student&#123;<span class="string">&quot;jason&quot;</span>, <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>But we still can use a unnamed struct if only use it for several times, like this</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := <span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="type">string</span></span><br><span class="line">        id <span class="type">int</span></span><br><span class="line">    &#125;&#123;<span class="string">&quot;jason&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    </span><br><span class="line">    test1(s1)</span><br><span class="line">    test2(&amp;s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(s <span class="keyword">struct</span> &#123;name <span class="type">string</span>; id <span class="type">int</span>&#125;)</span></span> &#123;</span><br><span class="line">     fmt.Println(s.name, s.id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(s *<span class="keyword">struct</span> &#123;name <span class="type">string</span>; id <span class="type">int</span>&#125;)</span></span> &#123;</span><br><span class="line">     fmt.Println(s.name, s.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Anonymous-function"><a href="#Anonymous-function" class="headerlink" title="Anonymous function"></a>Anonymous function</h2><p>Anonymous function is a function without name, it’s mostly used in two cases</p>
<ul>
<li><code>used as goruntine entry point</code></li>
<li><code>saved in function object, then call it later.</code></li>
<li><code>used as return value.</code></li>
<li><code>defer function.</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello go&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello go&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reader-and-Writer"><a href="#Reader-and-Writer" class="headerlink" title="Reader and Writer"></a>Reader and Writer</h2><p>The io package specifies the <code>io.Reader interface</code>, which represents the read end of a stream of data.</p>
<p>The <code>Go standard library contains many implementations of this interface, including files, network connections, compressors, ciphers, and others.</code></p>
<p>The io.Reader interface has a Read method:  </p>
<p><code>func (T) Read(b []byte) (n int, err error)</code></p>
<p>Read populates the given byte slice(should be create first with <code>make()</code>) with data and returns the number of bytes populated and an error value. It returns an io.EOF error when the stream ends.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// return Reader interface</span></span><br><span class="line">    r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// buffer to store reading</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b) <span class="comment">// must check err when reading</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82]
b[:n] = &quot;Hello, R&quot;
n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82]
b[:n] = &quot;eader!&quot;
n = 0 err = EOF b = [101 97 100 101 114 33 32 82]
b[:n] = &quot;&quot;
</code></pre>
<h2 id="never-use-break-for-each-case-in-switch-x2F-select"><a href="#never-use-break-for-each-case-in-switch-x2F-select" class="headerlink" title="never use break for each case in switch&#x2F;select"></a>never use break for each case in switch&#x2F;select</h2><p>As go break each matched case automatically, there is <code>no need to use break for each case explicitly in case you want to break in the middle of the case.</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tick := time.NewTicker(<span class="number">2</span> * time.Second)                                         </span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span>                                                                       </span><br><span class="line"><span class="keyword">for</span> &#123;                                                                           </span><br><span class="line">    <span class="keyword">select</span> &#123;                                                                    </span><br><span class="line">    <span class="keyword">case</span> &lt;-tick.C:                                                              </span><br><span class="line">        a++                                                                     </span><br><span class="line">        <span class="keyword">if</span> a &gt; <span class="number">2</span> &#123;                                                              </span><br><span class="line">            fmt.Println(<span class="string">&quot;break out&quot;</span>)                                            </span><br><span class="line">            <span class="keyword">break</span>  <span class="comment">// case is break, hence go next loop of for, for is not break!!!                                             </span></span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        fmt.Println(<span class="string">&quot;reach me&quot;</span>)</span><br><span class="line">    &#125;                                                                                                                   </span><br><span class="line">    fmt.Println(<span class="string">&quot;running&quot;</span>)                                                 </span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h2 id="Handle-OS-difference"><a href="#Handle-OS-difference" class="headerlink" title="Handle OS difference"></a>Handle OS difference</h2><p>Most of time, go code can shared by different OS like linux and windows etc, but in some case, we may need to handle special cases that depends on OS, hence we need to know the OS in Go code <code>$GOOS</code> gives the way for you to deal that.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> runtime.GOOS == <span class="string">&quot;windows&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;You are running on windows&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> runtime.GOOS == <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;You are running on linux&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;You are running on an OS that we do not support&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTTP-over-Unix"><a href="#HTTP-over-Unix" class="headerlink" title="HTTP over Unix"></a>HTTP over Unix</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A quick and dirty demo of talking HTTP over Unix domain sockets</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/codegangsta/martini&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// overriding ne.Dialer.Dial to force unix socket connection</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addr = <span class="string">&quot;http.sock&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fakeDial</span><span class="params">(_, _ <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> net.DialTimeout(<span class="string">&quot;unix&quot;</span>, addr, time.Second*<span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transport http.RoundTripper = &amp;http.Transport&#123;</span><br><span class="line">    Dial: fakeDial,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := martini.Classic()</span><br><span class="line">    m.Get(<span class="string">&quot;/demo&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normal unix listener</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;unix&quot;</span>, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cmd := exec.Command(<span class="string">&quot;/bin/rm&quot;</span>, <span class="string">&quot;-rf&quot;</span>, <span class="string">&quot;http.sock&quot;</span>)</span><br><span class="line">        cmd.Run()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// as you can see server has no special setting for unix listener</span></span><br><span class="line">    <span class="comment">// serve http request on any listener(here unix listener)</span></span><br><span class="line">    <span class="keyword">go</span> http.Serve(listener, m) <span class="comment">// http.Serve takes any net.Listener implementation</span></span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    c := http.Client&#123;&#125;</span><br><span class="line">    <span class="comment">// client usage is different for tcp and unix transport!!!</span></span><br><span class="line">    c.Transport = transport <span class="comment">// use the unix dialer based on unix to send http request(no tcp as tcp+http)</span></span><br><span class="line">    <span class="comment">// as you can see the address is sock path not ip:port like tcp</span></span><br><span class="line">    resp, err := c.Get(<span class="string">&quot;http://http.sock/demo&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// io.copy from resp.Body to os.StdOut(Writer)</span></span><br><span class="line">    io.Copy(os.Stdout, resp.Body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">()</span></span> (code <span class="type">int</span>, body <span class="type">string</span>) &#123;</span><br><span class="line">    code = <span class="number">200</span></span><br><span class="line">    body = <span class="string">&quot;ok\n&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WaitGroup-vs-Channel"><a href="#WaitGroup-vs-Channel" class="headerlink" title="WaitGroup vs Channel"></a>WaitGroup vs Channel</h2><p>Actually, there are designed for different scenarios, If you are dispatching <strong>one-off jobs to be run in parallel without needing to know the results of each job, then you can use a WaitGroup</strong>. But if you need to collect the results from the goroutines then you should use a channel. <strong>channel is designed to pass data while WaitGrop for wait jobs(which runs in goroutine) to finish.</strong></p>
<p><strong>waitgroup</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;job done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        work()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;got one job done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>notify channel</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;job done&quot;</span>)</span><br><span class="line">    ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        work(ch)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;got one job done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>if you have several jobs to run, waitgroup is best choice to use!!</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;job done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        work()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        work()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;got two jobs done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>job done
job done
got two jobs done
</code></pre>
<h2 id="do-we-need-to-close-channel-explicitly"><a href="#do-we-need-to-close-channel-explicitly" class="headerlink" title="do we need to close(channel) explicitly"></a>do we need to close(channel) explicitly</h2><p><strong>No, It’s OK to leave a Go channel open forever and never close it</strong>. When the channel is no longer used(no read and write), it will be garbage collected.</p>
<p>It is only necessary to <strong>close a channel explicitly if the receiver is looking for a close</strong>. Closing the channel is a <strong>control signal on the channel indicating that no more data follows, or to notify goroutine to quit otherwise it may blocking for ever</strong></p>
<p><font color='red'><strong>Danger</strong></font></p>
<ul>
<li><strong>closing a closed channel will panic</strong>, so it is dangerous to close a channel if the closers don’t know whether or not the channel is closed.</li>
<li><strong>sending values to a closed channel will panic</strong>, so it is dangerous to send values to a channel if the senders don’t know whether or not the channel is closed.</li>
</ul>
<p><strong>Rule to close if required</strong></p>
<ul>
<li>don’t close a channel from the receiver side.</li>
<li>don’t close a channel if the channel has multiple concurrent senders.</li>
</ul>
<p>In other words, we should <code>only close a channel in a sender goroutine if the sender is the only sender of the channel</code>. more solution to close a channel, refer to <a target="_blank" rel="noopener" href="https://go101.org/article/channel-closing.html">channel closing</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine blocks&quot;</span>)</span><br><span class="line">        &lt;-ch</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine quit&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;test return, but goroutine is blocking&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if main is a daemon process, gorountine waits for signal while sender is quit</span></span><br><span class="line">    <span class="comment">// when sender quits, it should notify receive to quit as well, otherwise, it&#x27;s blocks for ever</span></span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>test return, but goroutine is blocking
goroutine blocks
goroutine quit
</code></pre>
<h2 id="print-value-of-struct-pointer-embeded-in-another-struct"><a href="#print-value-of-struct-pointer-embeded-in-another-struct" class="headerlink" title="print value of struct pointer embeded in another struct"></a>print value of struct pointer embeded in another struct</h2><p>By default, struct pointer printed with its content if it’s not embeded, but if struct pointer as field of another struct, the pointer address is printed,  As when call print, the <code>String() of that type is called</code>, but by default golang does not provide <code>String()</code> for struct pointer, but struct only, that’s why pointer address is printed, In order to print pinter content(not address), there are several ways we can use</p>
<ul>
<li>iterate each pointer in struct, print it with <code>fmt.Println(&quot;%s&quot;, *p)</code></li>
<li><code>with json.Marshel(), but only exported field are printed</code></li>
<li>For each pointer, implement its <code>func (s *XX)String()string&#123;&#125;</code> method</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ackage main                                                                    </span><br><span class="line">                                                                                </span><br><span class="line"><span class="keyword">import</span> (                                                                        </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>                                                                       </span><br><span class="line">)                                                                               </span><br><span class="line">                                                                                </span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;                                                             </span><br><span class="line">    Id <span class="type">int</span>                                                                      </span><br><span class="line">&#125;                                                                               </span><br><span class="line">                                                                                </span><br><span class="line"><span class="comment">// comment out to see what happens                                              </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Class)</span></span> String() <span class="type">string</span> &#123;                                               </span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, c.Id)                                              </span><br><span class="line">&#125;                                                                               </span><br><span class="line">                                                                                </span><br><span class="line"><span class="comment">// comment out to see what happens                                              </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> String() <span class="type">string</span> &#123;                                              </span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v %v&quot;</span>, p.Name, p.Cls)                                  </span><br><span class="line">&#125;                                                                               </span><br><span class="line">                                                                                </span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;                                                            </span><br><span class="line">    Name <span class="type">string</span> <span class="comment">// string has default String()                                  </span></span><br><span class="line">    Cls  *Class <span class="comment">// no default String() for *Class                               </span></span><br><span class="line">&#125;                                                                               </span><br><span class="line">                                                                                </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                                                                   </span><br><span class="line">    p1 := Person&#123;Name: <span class="string">&quot;tom&quot;</span>, Cls: &amp;Class&#123;Id: <span class="number">1</span>&#125;&#125;                               </span><br><span class="line">    p2 := Person&#123;Name: <span class="string">&quot;jack&quot;</span>, Cls: &amp;Class&#123;Id: <span class="number">2</span>&#125;&#125;                              </span><br><span class="line">    sp := []Person&#123;p1, p2&#125;                                                      </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, sp)                                                      </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, sp)                                                     </span><br><span class="line">                                                                                </span><br><span class="line">    spp := []*Person&#123;&amp;p1, &amp;p2&#125; <span class="comment">// Person has no default String()                </span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, spp)                                                     </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, spp)                                                    </span><br><span class="line">&#125;                      </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#123;tom 1&#125; &#123;jack 2&#125;]</span><br><span class="line">[&#123;Name:tom Cls:1&#125; &#123;Name:jack Cls:2&#125;]</span><br><span class="line">[tom 1 jack 2]</span><br><span class="line">[tom 1 jack 2]</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Cls  *Class</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := Person&#123;Name: <span class="string">&quot;tom&quot;</span>, Cls: &amp;Class&#123;Id: <span class="number">1</span>&#125;&#125;</span><br><span class="line">    p2 := Person&#123;Name: <span class="string">&quot;jack&quot;</span>, Cls: &amp;Class&#123;Id: <span class="number">2</span>&#125;&#125;</span><br><span class="line">    spp := []*Person&#123;&amp;p1, &amp;p2&#125;</span><br><span class="line">    data, _ := json.Marshal(spp)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>[&#123;&quot;Name&quot;:&quot;tom&quot;,&quot;Cls&quot;:&#123;&quot;Id&quot;:1&#125;&#125;,&#123;&quot;Name&quot;:&quot;jack&quot;,&quot;Cls&quot;:&#123;&quot;Id&quot;:2&#125;&#125;]
</code></pre>
<h2 id="block-forever-in-go"><a href="#block-forever-in-go" class="headerlink" title="block forever in go"></a>block forever in go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blockForever</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blockForever</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := sync.Mutex&#123;&#125;</span><br><span class="line">    m.Lock()</span><br><span class="line">    m.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blockForever</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.sgmansfield.com/2016/06/how-to-block-forever-in-go/">block forever</a></p>
<h2 id="Channel-with-timeout"><a href="#Channel-with-timeout" class="headerlink" title="Channel with timeout"></a>Channel with timeout</h2><p>Actually, there is no timeout parameter of API when reading&#x2F;writing channel, so we use other way to do this.</p>
<p><strong>Way1</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;do something...&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">4</span>*time.Second)</span><br><span class="line">        ch&lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span>*time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Way2</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">&quot;done&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">    fmt.Println(res)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    fmt.Println(<span class="string">&quot;timout&quot;</span>, ctx.Err())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Good reason to use context</strong><br>Another advantage of using <code>context</code> is that it can take advantage of its natural transmission characteristics in multiple goroutines, so that all goroutines that pass the context can receive cancellation notifications at the same time. <code>we can call cancel() once, while quits all gorotines who listen on it.</code>.</p>
<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ul>
<li><a target="_blank" rel="noopener" href="https://golang.org/ref/spec">Go Specification</a></li>
<li><a target="_blank" rel="noopener" href="https://go101.org/article/concurrent-synchronization-more.html">Concurrency Synchronization Techniques</a></li>
</ul>

    </div>

    
    
    
      


    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="Jason WeChat Pay">
        <span>WeChat Pay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/20/linux-network-performance/" rel="prev" title="linux-network-performance">
                  <i class="fa fa-chevron-left"></i> linux-network-performance
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/01/go-lib/" rel="next" title="go-lib">
                  go-lib <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cyun All rights reserved</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"jason-bj/blog","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
