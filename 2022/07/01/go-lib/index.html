<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <meta name="google-site-verification" content="xitt2fbphh1nTeWLiTWc0lCggHuxJ5heMcAzkHW2vno">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Microsoft+YaHei+UI:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"cyun.tech","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":10,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="stdstringsPackage strings implements simple functions to manipulate UTF-8 encoded strings.  1234567891011121314151617181920212223242526272829303132333435363738- func Contains(s, substr string) bool- f">
<meta property="og:type" content="article">
<meta property="og:title" content="go-lib">
<meta property="og:url" content="http://cyun.tech/2022/07/01/go-lib/index.html">
<meta property="og:site_name" content="CYun">
<meta property="og:description" content="stdstringsPackage strings implements simple functions to manipulate UTF-8 encoded strings.  1234567891011121314151617181920212223242526272829303132333435363738- func Contains(s, substr string) bool- f">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-images.githubusercontent.com/19351306/110375142-2ba88680-8017-11eb-80c3-554cc746b165.png">
<meta property="article:published_time" content="2022-07-01T07:44:51.000Z">
<meta property="article:modified_time" content="2023-08-16T15:02:01.145Z">
<meta property="article:author" content="Jason">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/19351306/110375142-2ba88680-8017-11eb-80c3-554cc746b165.png">


<link rel="canonical" href="http://cyun.tech/2022/07/01/go-lib/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://cyun.tech/2022/07/01/go-lib/","path":"2022/07/01/go-lib/","title":"go-lib"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go-lib | CYun</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148730544-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-148730544-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?a510d1f580c8231f8f867d14f42bb8ea"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CYun</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#std"><span class="nav-number">1.</span> <span class="nav-text">std</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#strings"><span class="nav-number">1.1.</span> <span class="nav-text">strings</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bytes-manipulation-of-byte-slices"><span class="nav-number">1.2.</span> <span class="nav-text">bytes(manipulation of byte slices)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#container-list"><span class="nav-number">1.3.</span> <span class="nav-text">container(list)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#regex"><span class="nav-number">1.4.</span> <span class="nav-text">regex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exec-run-shell-from-go"><span class="nav-number">1.5.</span> <span class="nav-text">exec(run shell from go)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#discard-output"><span class="nav-number">1.5.1.</span> <span class="nav-text">discard output</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#print-output-to-console"><span class="nav-number">1.5.2.</span> <span class="nav-text">print output to console</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#capture-output-stdout-x2F-stderr-with-one-buffer"><span class="nav-number">1.5.3.</span> <span class="nav-text">capture output(stdout&#x2F;stderr) with one buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#capture-output-stdout-and-stderr-with-two-buffer"><span class="nav-number">1.5.4.</span> <span class="nav-text">capture output(stdout and stderr) with two buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#capture-output-and-with-time-out"><span class="nav-number">1.5.5.</span> <span class="nav-text">capture output and with time out</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#run-command-as-daemon"><span class="nav-number">1.6.</span> <span class="nav-text">run command as daemon</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#time"><span class="nav-number">1.7.</span> <span class="nav-text">time</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Periodically-timeout"><span class="nav-number">1.7.1.</span> <span class="nav-text">Periodically timeout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Once-timeout"><span class="nav-number">1.7.2.</span> <span class="nav-text">Once timeout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timestamp"><span class="nav-number">1.7.3.</span> <span class="nav-text">timestamp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sorting-with-Go"><span class="nav-number">1.8.</span> <span class="nav-text">sorting with Go</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-for-int-float-string"><span class="nav-number">1.8.1.</span> <span class="nav-text">sort for int, float, string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sorting-slice"><span class="nav-number">1.8.2.</span> <span class="nav-text">sorting slice</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#encoding"><span class="nav-number">1.9.</span> <span class="nav-text">encoding</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#json"><span class="nav-number">1.9.1.</span> <span class="nav-text">json</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#omitempty"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">omitempty</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#json-marshal-for-built-in-type"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">json.marshal for built-in type</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xml"><span class="nav-number">1.9.2.</span> <span class="nav-text">xml</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#non-standard"><span class="nav-number">2.</span> <span class="nav-text">non-standard</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#uuid"><span class="nav-number">2.1.</span> <span class="nav-text">uuid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#log"><span class="nav-number">2.2.</span> <span class="nav-text">log</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#glog"><span class="nav-number">2.2.1.</span> <span class="nav-text">glog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#logrus"><span class="nav-number">2.2.2.</span> <span class="nav-text">logrus</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gopsutil"><span class="nav-number">2.3.</span> <span class="nav-text">gopsutil</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#file-ops"><span class="nav-number">2.4.</span> <span class="nav-text">file ops</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#afero"><span class="nav-number">2.4.1.</span> <span class="nav-text">afero</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CLI"><span class="nav-number">2.5.</span> <span class="nav-text">CLI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#flag"><span class="nav-number">2.5.1.</span> <span class="nav-text">flag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-flags"><span class="nav-number">2.5.2.</span> <span class="nav-text">go-flags</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spf13-x2F-cobra"><span class="nav-number">2.5.3.</span> <span class="nav-text">spf13&#x2F;cobra</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-cron-scheduling"><span class="nav-number">2.6.</span> <span class="nav-text">Go cron scheduling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-Server"><span class="nav-number">2.7.</span> <span class="nav-text">HTTP Server</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Restful-API-server"><span class="nav-number">2.7.1.</span> <span class="nav-text">Restful API server</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gorilla-x2F-mux"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">gorilla&#x2F;mux</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#yaml-vs-json-vs-toml"><span class="nav-number">2.8.</span> <span class="nav-text">yaml vs json vs toml</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#toml-decode"><span class="nav-number">2.8.1.</span> <span class="nav-text">toml decode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toml-encode"><span class="nav-number">2.8.2.</span> <span class="nav-text">toml encode</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bit"><span class="nav-number">2.9.</span> <span class="nav-text">bit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#encoding-protobuffer"><span class="nav-number">2.10.</span> <span class="nav-text">encoding(protobuffer)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#style"><span class="nav-number">2.10.1.</span> <span class="nav-text">style</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proto3"><span class="nav-number">2.10.2.</span> <span class="nav-text">proto3</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#build-proto3-of-go"><span class="nav-number">2.10.2.1.</span> <span class="nav-text">build proto3 of go</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#generated-go-code"><span class="nav-number">2.10.2.2.</span> <span class="nav-text">generated go code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#use-generated-code"><span class="nav-number">2.10.2.3.</span> <span class="nav-text">use generated code</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pty"><span class="nav-number">2.11.</span> <span class="nav-text">pty</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#go-package"><span class="nav-number">2.11.1.</span> <span class="nav-text">go package</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shell"><span class="nav-number">2.11.1.1.</span> <span class="nav-text">shell</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FAQ"><span class="nav-number">3.</span> <span class="nav-text">FAQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#use-io-pipe-or-channel"><span class="nav-number">3.1.</span> <span class="nav-text">use io.pipe or channel?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ref"><span class="nav-number">4.</span> <span class="nav-text">Ref</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jason"
      src="/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">141</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">148</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jason-cyun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jason-cyun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jason_lkm@163.com" title="E-Mail → mailto:jason_lkm@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cyun.tech/2022/07/01/go-lib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="Jason">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CYun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="go-lib | CYun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go-lib
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-07-01 15:44:51" itemprop="dateCreated datePublished" datetime="2022-07-01T15:44:51+08:00">2022-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-16 23:02:01" itemprop="dateModified" datetime="2023-08-16T23:02:01+08:00">2023-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go-program/" itemprop="url" rel="index"><span itemprop="name">go program</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="std"><a href="#std" class="headerlink" title="std"></a>std</h1><h2 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h2><p>Package strings implements simple functions to manipulate UTF-8 encoded strings. </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">ContainsAny</span><span class="params">(s, chars <span class="type">string</span>)</span></span> <span class="type">bool</span> any Unicode code points in chars are within s. </span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, substr <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span>   splited by whitespace</span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="type">string</span>)</span></span> <span class="type">bool</span> whether the <span class="type">string</span> s begins with prefix.</span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, substr <span class="type">string</span>)</span></span> first instance of substr in s, or <span class="number">-1</span> <span class="keyword">if</span> substr is not present in s. </span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s, chars <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, substr <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">LastIndexAny</span><span class="params">(s, chars <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(elems []<span class="type">string</span>, sep <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="type">string</span>)</span></span> []<span class="type">string</span> any separator!!!</span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(mapping <span class="keyword">func</span>(<span class="type">rune</span>)</span></span> <span class="type">rune</span>, s <span class="type">string</span>) <span class="type">string</span> </span><br><span class="line"><span class="comment">//Map returns a copy of the string s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement.**  </span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">ReplaceAll</span><span class="params">(s, old, <span class="built_in">new</span> <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s, cutset <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"><span class="comment">// // Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s, cutset <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"><span class="comment">//returns a slice of the string s with all leading Unicode code(check one by one) points contained in cutset removed.**</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s, cutset <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//prefix as a whole to check</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"><span class="comment">//TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.</span></span><br></pre></td></tr></table></figure>

<p><strong>Note</strong></p>
<ul>
<li>Trim, TrimLeft, TrimRight, check ‘each character’ in the cutset</li>
<li>TrimSuffix, TrimPrefix check ‘suffix and prefix’ as a whole not a set”</li>
</ul>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;no C K dno&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;string: %s\n&quot;</span>, s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;hasprefix: %v, hassuffix: %v\n&quot;</span>, strings.HasPrefix(s, <span class="string">&quot;no&quot;</span>), strings.HasSuffix(s, <span class="string">&quot;dno&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;split by `o`: %v, fields(split by space): %v\n&quot;</span>, strings.Split(s, <span class="string">&quot;o&quot;</span>), strings.Fields(s))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;lower: %s, upper: %s, title: %s\n&quot;</span>, strings.ToLower(s), strings.ToUpper(s), strings.Title(s))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;contains?: %v\n&quot;</span>, strings.ContainsAny(s, <span class="string">&quot;CK&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;trim: %v, left: %v, right: %v, prefix: %v\n&quot;</span>, strings.Trim(s, <span class="string">&quot;no&quot;</span>), strings.TrimLeft(s, <span class="string">&quot;no&quot;</span>), strings.TrimRight(s, <span class="string">&quot;no&quot;</span>), strings.TrimPrefix(s, <span class="string">&quot;no&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>string: no C K dno
hasprefix: true, hassuffix: true
split by `o`: [n  C K dn ], fields(split by space): [no C K dno]
lower: no c k dno, upper: NO C K DNO, title: No C K Dno
contains?: true
trim:  C K d, left:  C K dno, right: no C K d, prefix:  C K dno
</code></pre>
<h2 id="bytes-manipulation-of-byte-slices"><a href="#bytes-manipulation-of-byte-slices" class="headerlink" title="bytes(manipulation of byte slices)"></a>bytes(manipulation of byte slices)</h2><p>Package <code>bytes</code> implements functions for the <code>manipulation of byte slices</code>. It is <strong>similar to the facilities of the strings package.</strong></p>
<p>Package strings implements simple functions to manipulate UTF-8 encoded strings. </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(b, subslice []<span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">ContainsAny</span><span class="params">(b []<span class="type">byte</span>, chars <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep []<span class="type">byte</span>)</span></span> <span class="type">int</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Equal</span><span class="params">(a, b []<span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix []<span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix []<span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep []<span class="type">byte</span>)</span></span> <span class="type">int</span> <span class="comment">//sep as a whole</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s []<span class="type">byte</span>, chars <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, sep []<span class="type">byte</span>)</span></span> <span class="type">int</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">LastIndexAny</span><span class="params">(s []<span class="type">byte</span>, chars <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(s [][]<span class="type">byte</span>, sep []<span class="type">byte</span>)</span></span> []<span class="type">byte</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep []<span class="type">byte</span>)</span></span> [][]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(mapping <span class="keyword">func</span>(r <span class="type">rune</span>)</span></span> <span class="type">rune</span>, s []<span class="type">byte</span>) []<span class="type">byte</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> []<span class="type">byte</span>, n <span class="type">int</span>)</span></span> []<span class="type">byte</span> <span class="comment">// old and new as a whole</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">ReplaceAll</span><span class="params">(s, old, <span class="built_in">new</span> []<span class="type">byte</span>)</span></span> []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s []<span class="type">byte</span>)</span></span> []<span class="type">byte</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s []<span class="type">byte</span>)</span></span> []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s, cutset []<span class="type">byte</span>)</span></span> []<span class="type">byte</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s, cutset []<span class="type">byte</span>)</span></span> []<span class="type">byte</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s []<span class="type">byte</span>)</span></span> []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> <span class="comment">// suffix as a whole</span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix []<span class="type">byte</span>)</span></span> []<span class="type">byte</span></span><br></pre></td></tr></table></figure>

<h2 id="container-list"><a href="#container-list" class="headerlink" title="container(list)"></a>container(list)</h2><p>Package list implements a doubly linked list. </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;container/list&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a new list and put some numbers in it.</span></span><br><span class="line">    l := list.New()</span><br><span class="line">    e4 := l.PushBack(Person&#123;<span class="string">&quot;d&quot;</span>&#125;)</span><br><span class="line">    e1 := l.PushFront(Person&#123;<span class="string">&quot;a&quot;</span>&#125;)</span><br><span class="line">    l.InsertBefore(Person&#123;<span class="string">&quot;c&quot;</span>&#125;, e4)</span><br><span class="line">    l.InsertAfter(Person&#123;<span class="string">&quot;b&quot;</span>&#125;, e1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate through list and print its contents.</span></span><br><span class="line">    <span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        fmt.Println(e.Value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Create a new list and put some numbers in it.</span></span><br><span class="line">    l = l.Init()</span><br><span class="line">    e4 = l.PushBack(<span class="number">4</span>)</span><br><span class="line">    e1 = l.PushFront(<span class="number">1</span>)</span><br><span class="line">    l.InsertBefore(<span class="number">3</span>, e4)</span><br><span class="line">    l.InsertAfter(<span class="number">2</span>, e1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate through list and print its contents.</span></span><br><span class="line">    <span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        fmt.Println(e.Value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">listDemo()</span><br></pre></td></tr></table></figure>

<pre><code>&#123;a&#125;
&#123;b&#125;
&#123;c&#125;
&#123;d&#125;
1
2
3
4
</code></pre>
<h2 id="regex"><a href="#regex" class="headerlink" title="regex"></a>regex</h2><p>Package <code>regexp</code> implements regular expression search. </p>
<p>There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression:<br><code>Find(All)?(String)?(Submatch)?(Index)?</code></p>
<p>If ‘All’ is present, the routine matches successive <code>non-overlapping matches of the entire expression</code>. Empty matches abutting a preceding match are ignored. <code>The return value is a slice containing the successive return values of the corresponding non-&#39;All&#39; routine</code>. These routines take an extra integer argument, n. If n &gt;&#x3D; 0, the function returns <code>at most n matches/submatches; otherwise, it returns all of them</code>.</p>
<p>If ‘String’ is present, <code>the argument is a string; otherwise it is a slice of bytes</code>; return values are adjusted as appropriate.</p>
<p>If ‘Submatch’ is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (<code>also known as capturing groups</code>) within the regular expression, numbered from left to right in order of opening parenthesis. <code>Submatch 0 is the match of the entire expression, submatch 1 the match of the first parenthesized subexpression, and so on</code>.</p>
<p>If ‘Index’ is present, <code>matches and submatches are identified by byte index pairs within the input string</code>: result[2<em>n:2</em>n+1] identifies the indexes of the nth submatch. The pair for n&#x3D;&#x3D;0 identifies the match of the entire expression. If ‘Index’ is not present, the match is identified by the text of the match&#x2F;submatch. If an index is negative or text is nil, it means that subexpression did not match any string in the input. For ‘String’ versions an empty string means either no match or an empty match. </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindAll(b []<span class="type">byte</span>, n <span class="type">int</span>) [][]<span class="type">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindAllIndex(b []<span class="type">byte</span>, n <span class="type">int</span>) [][]<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindAllString(s <span class="type">string</span>, n <span class="type">int</span>) []<span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindAllStringIndex(s <span class="type">string</span>, n <span class="type">int</span>) [][]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindAllStringSubmatch(s <span class="type">string</span>, n <span class="type">int</span>) [][]<span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindAllStringSubmatchIndex(s <span class="type">string</span>, n <span class="type">int</span>) [][]<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindAllSubmatch(b []<span class="type">byte</span>, n <span class="type">int</span>) [][][]<span class="type">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindAllSubmatchIndex(b []<span class="type">byte</span>, n <span class="type">int</span>) [][]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> Find(b []<span class="type">byte</span>) []<span class="type">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindIndex(b []<span class="type">byte</span>) (loc []<span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindString(s <span class="type">string</span>) <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindStringIndex(s <span class="type">string</span>) (loc []<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindStringSubmatch(s <span class="type">string</span>) []<span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindStringSubmatchIndex(s <span class="type">string</span>) []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindSubmatch(b []<span class="type">byte</span>) [][]<span class="type">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> FindSubmatchIndex(b []<span class="type">byte</span>) []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> Match(b []<span class="type">byte</span>) <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> MatchString(s <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> ReplaceAll(src, repl []<span class="type">byte</span>) []<span class="type">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> ReplaceAllLiteral(src, repl []<span class="type">byte</span>) []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> ReplaceAllLiteralString(src, repl <span class="type">string</span>) <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span></span> ReplaceAllString(src, repl <span class="type">string</span>) <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p><strong>Frequently used</strong>  </p>
<ul>
<li><p>*<em>func (re <em>Regexp) FindString(s string) string</em></em></p>
<ul>
<li>FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use FindStringIndex or FindStringSubmatch if it is necessary to distinguish these cases.</li>
</ul>
</li>
<li><p>*<em>func (re <em>Regexp) FindStringIndex(s string) (loc []int)</em></em></p>
<ul>
<li>FindStringIndex returns <code>a two-element slice of integers</code> defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match.</li>
</ul>
</li>
<li><p>*<em>func (re <em>Regexp) MatchString(s string) bool</em></em></p>
<ul>
<li>MatchString reports whether the string <strong>s contains any match of the regular expression re</strong>.</li>
</ul>
</li>
<li><p>*<em>func (re <em>Regexp) ReplaceAllLiteralString(src, repl string) string</em></em></p>
<ul>
<li>ReplaceAllLiteralString returns a copy of src, <strong>replacing matches of the Regexp</strong> with the replacement string repl. The replacement repl is substituted directly, without using Expand</li>
</ul>
</li>
<li><p>*<em>func (re <em>Regexp) ReplaceAllString(src, repl string) string</em></em></p>
<ul>
<li>ReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement string repl. Inside repl, <code>$ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.</code></li>
</ul>
</li>
<li><p>*<em>func (re <em>Regexp) FindStringSubmatch(s string) []string</em></em></p>
<ul>
<li>FindStringSubmatch <strong>returns a two-element slice</strong> of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the ‘Submatch’ description in the package comment. A return value of nil indicates no match.</li>
</ul>
</li>
<li><p>*<em>func (re <em>Regexp) FindStringSubmatchIndex(s string) []int</em></em></p>
<ul>
<li>FindStringSubmatchIndex <strong>returns a two-element slice</strong> holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the ‘Submatch’ and ‘Index’ descriptions in the package comment. A return value of nil indicates no match.</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo_regex</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">regexDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    re := regexp.MustCompile(<span class="string">`foo.?`</span>) <span class="comment">// pattern must be in `` not &#x27;&#x27;!!!</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindString(<span class="string">&quot;seafood fool&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindString(<span class="string">&quot;meat&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, re.FindStringIndex(<span class="string">&quot;seafood fool&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, re.FindStringIndex(<span class="string">&quot;meat&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, re.MatchString(<span class="string">&quot;seafood fool&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, re.MatchString(<span class="string">&quot;meat&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    re = regexp.MustCompile(<span class="string">`a(x+)b`</span>)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(re.ReplaceAllLiteralString(<span class="string">&quot;-ab-axxb-&quot;</span>, <span class="string">&quot;T&quot;</span>))</span><br><span class="line">    fmt.Println(re.ReplaceAllLiteralString(<span class="string">&quot;-ab-axxb-&quot;</span>, <span class="string">&quot;$&#123;1&#125;&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    fmt.Println(re.ReplaceAllString(<span class="string">&quot;-ab-axxb-&quot;</span>, <span class="string">&quot;T&quot;</span>))</span><br><span class="line">    fmt.Println(re.ReplaceAllString(<span class="string">&quot;-ab-axxb-&quot;</span>, <span class="string">&quot;$&#123;1&#125;&quot;</span>)) <span class="comment">// $&#123;1&#125; submatch (the first group)</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(re.FindStringSubmatch(<span class="string">&quot;-ab-axxb-&quot;</span>))</span><br><span class="line">    fmt.Println(re.FindStringSubmatchIndex(<span class="string">&quot;-ab-axxb-&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">regexDemo()</span><br></pre></td></tr></table></figure>

<pre><code>&quot;food&quot;
&quot;&quot;
[3 7]
[]
true
false
-ab-T-
-ab-$&#123;1&#125;-
-ab-T-
-ab-xx-
[axxb xx]
[4 8 5 7]
</code></pre>
<h2 id="exec-run-shell-from-go"><a href="#exec-run-shell-from-go" class="headerlink" title="exec(run shell from go)"></a>exec(run shell from go)</h2><p>Package exec runs external commands. It wraps os.StartProcess to make it easier to remap stdin and stdout, connect I&#x2F;O with pipes, and do other adjustments.</p>
<p>Unlike the “system” library call from C and other languages, the <code>os/exec package intentionally does not invoke the system shell</code> and <strong>does not expand any glob patterns or handle other expansions, pipelines, or redirections typically done by shells</strong>. The package behaves more like C’s “exec” family of functions. To expand glob patterns, either call the shell directly, taking care to escape any dangerous input, or use the path&#x2F;filepath package’s Glob function. To expand environment variables, use package os’s ExpandEnv. </p>
<p><strong>sync method, goroutine blocks</strong></p>
<ul>
<li>cmd.Run(): output is saved to cmd.Stdout and cmd.Stderr, by default discard, you can set them with buffer to get the output</li>
<li>cmd.Output(): only return stdout</li>
<li>cmd.CombinedOutput(): return stdout and stderr</li>
</ul>
<p><strong>async method</strong></p>
<ul>
<li>func (c *Cmd) Start() error<blockquote>
<p>Start starts a separate process to run  the specified command but does not wait for it to complete. If Start returns successfully, the c.Process field will be set. A child process to run command</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>The Wait method will return the exit code and release associated resources once the command exits. </p>
</blockquote>
<ul>
<li>func (c *Cmd) Wait() error<blockquote>
<p>Wait waits for the command to exit and waits for any copying to stdin or copying from stdout or stderr to complete.<br>The command must have been started by Start.</p>
</blockquote>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">	err := cmd.Start() <span class="comment">// a child process is created to run command if no error happens</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Waiting for command to finish...&quot;</span>)</span><br><span class="line">	err = cmd.Wait()</span><br><span class="line">	log.Printf(<span class="string">&quot;Command finished with error: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="discard-output"><a href="#discard-output" class="headerlink" title="discard output"></a>discard output</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// check binary exist before run</span></span><br><span class="line">    path, err := exec.LookPath(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;didn&#x27;t find &#x27;ls&#x27; executable\n&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;&#x27;ls&#x27; executable is in &#x27;%s&#x27;\n&quot;</span>, path)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cmd := exec.Command(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-lah&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">        cmd = exec.Command(<span class="string">&quot;tasklist&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    err := cmd.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">&quot;cmd.Run() failed with %s\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>&#39;ls&#39; executable is in &#39;/usr/bin/ls&#39;
</code></pre>
<h3 id="print-output-to-console"><a href="#print-output-to-console" class="headerlink" title="print output to console"></a>print output to console</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-lah&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">        cmd = exec.Command(<span class="string">&quot;tasklist&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print output to console</span></span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    err := cmd.Run() <span class="comment">// only return error</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">&quot;cmd.Run() failed with %s\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>total 476K
drwxr-xr-x  4 root root  165 Jul  1 17:23 .
drwxr-xr-x 16 root root  242 May 30 16:48 ..
drwxr-xr-x  3 root root   54 Jul  1 15:07 debug
-rw-r--r--  1 root root 102K Jul  1 09:18 go_advanced.ipynb
-rw-r--r--  1 root root 105K Jul  1 14:42 Go_basics.ipynb
-rw-r--r--  1 root root  13K Jun 30 11:27 go-context.ipynb
-rw-r--r--  1 root root 185K Jul  1 17:23 Go_lib.ipynb
-rw-r--r--  1 root root  57K Jun 30 10:23 Go_network_rpc.ipynb
drwxr-xr-x  2 root root  181 Jun 30 11:08 .ipynb_checkpoints
</code></pre>
<h3 id="capture-output-stdout-x2F-stderr-with-one-buffer"><a href="#capture-output-stdout-x2F-stderr-with-one-buffer" class="headerlink" title="capture output(stdout&#x2F;stderr) with one buffer"></a>capture output(stdout&#x2F;stderr) with one buffer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-h&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">        cmd = exec.Command(<span class="string">&quot;tasklist&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// out, err := cmd.CombinedOutput() //combine(stderr and stdout)</span></span><br><span class="line">    out, err := cmd.Output() <span class="comment">// only stdout</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;cmd.Run() failed with %s\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;out:\n%s\n&quot;</span>, <span class="type">string</span>(out))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>out:
total 476K
drwxr-xr-x  4 root root  165 Jul  1 17:23 .
drwxr-xr-x 16 root root  242 May 30 16:48 ..
drwxr-xr-x  3 root root   54 Jul  1 15:07 debug
-rw-r--r--  1 root root 102K Jul  1 09:18 go_advanced.ipynb
-rw-r--r--  1 root root 105K Jul  1 14:42 Go_basics.ipynb
-rw-r--r--  1 root root  13K Jun 30 11:27 go-context.ipynb
-rw-r--r--  1 root root 185K Jul  1 17:23 Go_lib.ipynb
-rw-r--r--  1 root root  57K Jun 30 10:23 Go_network_rpc.ipynb
drwxr-xr-x  2 root root  181 Jun 30 11:08 .ipynb_checkpoints
</code></pre>
<h3 id="capture-output-stdout-and-stderr-with-two-buffer"><a href="#capture-output-stdout-and-stderr-with-two-buffer" class="headerlink" title="capture output(stdout and stderr) with two buffer"></a>capture output(stdout and stderr) with two buffer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-lah&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> stdout, stderr bytes.Buffer</span><br><span class="line">    cmd.Stdout = &amp;stdout</span><br><span class="line">    cmd.Stderr = &amp;stderr</span><br><span class="line">    </span><br><span class="line">    err := cmd.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;cmd.Run() failed with %s\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    outStr, errStr := stdout.String(), stderr.String()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;out:\n%s\nerr:\n%s\n&quot;</span>, outStr, errStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>out:
total 476K
drwxr-xr-x  4 root root  165 Jul  1 17:23 .
drwxr-xr-x 16 root root  242 May 30 16:48 ..
drwxr-xr-x  3 root root   54 Jul  1 15:07 debug
-rw-r--r--  1 root root 102K Jul  1 09:18 go_advanced.ipynb
-rw-r--r--  1 root root 105K Jul  1 14:42 Go_basics.ipynb
-rw-r--r--  1 root root  13K Jun 30 11:27 go-context.ipynb
-rw-r--r--  1 root root 185K Jul  1 17:23 Go_lib.ipynb
-rw-r--r--  1 root root  57K Jun 30 10:23 Go_network_rpc.ipynb
drwxr-xr-x  2 root root  181 Jun 30 11:08 .ipynb_checkpoints

err:
</code></pre>
<h3 id="capture-output-and-with-time-out"><a href="#capture-output-and-with-time-out" class="headerlink" title="capture output and with time out"></a>capture output and with time out</h3><p>Use <code>exec.CommandContext()</code>, the os&#x2F;exec package handles checking the timeout and killing the process if it expires, user no need to kill the process by himself.</p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@vCabbage/go-timeout-commands-with-os-exec-commandcontext-ba0c861ed738">timeout example</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a new context and add a timeout to it</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">1</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// The cancel should be deferred so resources are cleaned up</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the command with our context</span></span><br><span class="line">    cmd := exec.CommandContext(ctx, <span class="string">&quot;ping&quot;</span>, <span class="string">&quot;-c 4&quot;</span>, <span class="string">&quot;-i 1&quot;</span>, <span class="string">&quot;8.8.8.8&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This time we can simply use Output() to get the result.</span></span><br><span class="line">    out, err := cmd.Output()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to check the context error to see if the timeout was executed.</span></span><br><span class="line">    <span class="comment">// The error returned by cmd.Output() will be OS specific based on what</span></span><br><span class="line">    <span class="comment">// happens when a process is killed.</span></span><br><span class="line">    <span class="keyword">if</span> ctx.Err() == context.DeadlineExceeded &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Command timed out&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there&#x27;s no context error, we know the command completed (or errored).</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Output:&quot;</span>, <span class="type">string</span>(out))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Non-zero exit code:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>Command timed out
</code></pre>
<h2 id="run-command-as-daemon"><a href="#run-command-as-daemon" class="headerlink" title="run command as daemon"></a>run command as daemon</h2><p>That means after c.Process starts, we should release it from parent, hence init takes it as its parent, command runs daemon.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;os/exec&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Daemon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;100&quot;</span>)</span><br><span class="line">    cmd.Stdin = <span class="literal">nil</span></span><br><span class="line">    cmd.Stdout = <span class="literal">nil</span></span><br><span class="line">    cmd.Stderr = <span class="literal">nil</span></span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;Setsid: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">    err := cmd.Start() <span class="comment">// runs in another process(child)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// I&#x27;m here in parent</span></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123; <span class="comment">// no error happens, a child process is created</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;trying to release child process after 30s&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">30</span> * time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;child process released, command runs in daemon&quot;</span>)</span><br><span class="line">        cmd.Process.Release() <span class="comment">// release it to make it orphan, init process takes it</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// parent exits but sleep is still running</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;parent exited, sleep cmd is still running in separate process&quot;</span>)</span><br><span class="line">        os.Exit(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Daemon()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<pre><code>repl.go:9:24: undefined &quot;syscall&quot; in syscall.SysProcAttr &lt;*ast.SelectorExpr&gt;
</code></pre>
<h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><p>Package time provides functionality for measuring and displaying time. </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">statusUpdate</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 10 minute 10 * Time.Minute</span></span><br><span class="line">    <span class="comment">// 10s       10 * time.Second</span></span><br><span class="line">    <span class="comment">// 100ms     100 * time.Millisecond</span></span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(time.Now())</span><br><span class="line">    fmt.Println(time.Weekday())</span><br><span class="line">    </span><br><span class="line">    start := time.Now()</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">    end := time.Now()</span><br><span class="line">    <span class="comment">// check whether end is before or after start</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(end.After(start))</span><br><span class="line">    fmt.Println(end.Before(start))</span><br><span class="line">    fmt.Println(end.Unix())     <span class="comment">// seconds since 1970</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// peridical timeout, write time to channel every 5s</span></span><br><span class="line">    <span class="comment">// can shutdown ticker at any time</span></span><br><span class="line">    </span><br><span class="line">    ticker := time.NewTicker(time.Second) <span class="comment">// signal tick every 1s</span></span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//send true after 3 s</span></span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Done!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> t := &lt;-ticker.C: <span class="comment">//ticker.C is a channel: chan time</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Current time: &quot;</span>, t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">timeDemo1()</span><br><span class="line"><span class="comment">//timeDemo2()</span></span><br></pre></td></tr></table></figure>

<pre><code>2022-07-01 17:23:20.113770275 +0800 CST m=+6926.821548718
Sunday
true
false
1656667400
Current time:  2022-07-01 17:23:21.124828279 +0800 CST m=+6927.832606722
Current time:  2022-07-01 17:23:22.124729486 +0800 CST m=+6928.832507925
Current time:  2022-07-01 17:23:23.124739482 +0800 CST m=+6929.832517925
Done!
</code></pre>
<h3 id="Periodically-timeout"><a href="#Periodically-timeout" class="headerlink" title="Periodically timeout"></a>Periodically timeout</h3><p><code>func NewTicker(d Duration) *Ticker</code>                                                                                          </p>
<ul>
<li>NewTicker returns a new Ticker containing a channel that will send the time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.</li>
</ul>
<p><code>func Tick(d Duration) &lt;-chan Time</code>                                                                                                 </p>
<ul>
<li>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it &quot;leaks&quot;. Unlike NewTicker, Tick will return nil if d &lt;&#x3D; 0.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(time.Second) <span class="comment">// signal tick every 1s</span></span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">    </span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ok =&lt;-done:</span><br><span class="line">            fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> t := &lt;-ticker.C: <span class="comment">//ticker.C is a channel: chan time</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;current time: &quot;</span>, t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// peridical timeout, write time to channel every 1s</span></span><br><span class="line">    <span class="comment">// you can&#x27;t shutdown the ticker as no way to know the Ticker instance!!!</span></span><br><span class="line">    t := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> next := <span class="keyword">range</span> t &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, next)</span><br><span class="line">        <span class="keyword">if</span> i++; i == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    timeDemo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>current time:  2022-07-01 17:23:24.126393711 +0800 CST m=+6930.834172154
done
2022-07-01 17:23:25.12738211 +0800 CST m=+6931.835160502
2022-07-01 17:23:26.127205432 +0800 CST m=+6932.834983825
</code></pre>
<h3 id="Once-timeout"><a href="#Once-timeout" class="headerlink" title="Once timeout"></a>Once timeout</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//one time timeout</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> m := &lt;-c:</span><br><span class="line">        handle(m)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timed out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    timeDemo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>timed out
</code></pre>
<h3 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp"></a>timestamp</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Println(time.Now())</span><br><span class="line">    timeUnix := time.Now().Unix()         <span class="comment">//second</span></span><br><span class="line">    timeUnixNano := time.Now().UnixNano() <span class="comment">//nano second</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(timeUnix)</span><br><span class="line">    fmt.Println(timeUnixNano)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert timestamp to human readable</span></span><br><span class="line">    fmt.Println(time.Unix(timeUnix, <span class="number">0</span>))</span><br><span class="line">    <span class="comment">// convert timestamp to human readable with format specified, must this value 2006-01-02 15:04:05!!!</span></span><br><span class="line">    fmt.Println(time.Unix(timeUnix, <span class="number">0</span>).Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>2022-07-01 17:23:27.129936571 +0800 CST m=+6933.837715027
1656667407
1656667407129992154
2022-07-01 17:23:27 +0800 CST
2022-07-01 17:23:27
</code></pre>
<h2 id="sorting-with-Go"><a href="#sorting-with-Go" class="headerlink" title="sorting with Go"></a>sorting with Go</h2><p>Package sort provides primitives for <code>sorting slices and user-defined collections</code>, you can provides <code>less</code> function for custom types.</p>
<h3 id="sort-for-int-float-string"><a href="#sort-for-int-float-string" class="headerlink" title="sort for int, float, string"></a>sort for int, float, string</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125; <span class="comment">// unsorted</span></span><br><span class="line">    sort.Ints(s) <span class="comment">// sorted in increasing order</span></span><br><span class="line">    fmt.Println(s, sort.IntsAreSorted(s))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Sort string in increasing order</span></span><br><span class="line">    s := []<span class="type">string</span>&#123;<span class="string">&quot;Bravo&quot;</span>, <span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;Alpha&quot;</span>, <span class="string">&quot;Grin&quot;</span>, <span class="string">&quot;Delta&quot;</span>&#125;</span><br><span class="line">    sort.Strings(s)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sort slice of any type!!!</span></span><br><span class="line">&#125;</span><br><span class="line">sortDemo()</span><br></pre></td></tr></table></figure>

<pre><code>[1 2 3 4 5 6] true
[Alpha Bravo Delta Gopher Grin]
</code></pre>
<h3 id="sorting-slice"><a href="#sorting-slice" class="headerlink" title="sorting slice"></a>sorting slice</h3><p>Any type of slice, you must provide less function<br><code>func SliceStable(x interface&#123;&#125;, less func(i, j int) bool)</code><br><code>func Slice(x interface&#123;&#125;, less func(i, j int) bool)</code></p>
<p>Slice sorts the slice x given the provided less function. It panics if x is not a slice.</p>
<p>The sort is not guaranteed to be stable: equal elements may be reversed from their original order. For a stable sort, use SliceStable.</p>
<p>The less function must satisfy the same requirements as the Interface type’s Less method.<br><strong>Less reports whether the element with index i must sort before the element with index j, less returns true means i must be sorted firstly</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="type">string</span></span><br><span class="line">        Age  <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">55</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> people[i].Name &lt; people[j].Name &#125;)</span><br><span class="line">    fmt.Println(<span class="string">&quot;By name:&quot;</span>, people)</span><br><span class="line"></span><br><span class="line">    sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> people[i].Age &lt; people[j].Age &#125;)</span><br><span class="line">    fmt.Println(<span class="string">&quot;By age:&quot;</span>, people)</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>By name: [&#123;Alice 55&#125; &#123;Bob 75&#125; &#123;Gopher 7&#125; &#123;Vera 24&#125;]
By age: [&#123;Gopher 7&#125; &#123;Vera 24&#125; &#123;Alice 55&#125; &#123;Bob 75&#125;]
</code></pre>
<h2 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h2><p>Package encoding defines interfaces shared by other packages that convert data <strong>to and from byte-level and textual representations</strong>. like <code>encoding/xml  encoding/base64 encoding/hex etc</code><br><strong>base64</strong></p>
<ul>
<li><p>func (enc *Encoding) Decode(dst, src []byte) (n int, err error)</p>
</li>
<li><p>func (enc *Encoding) DecodeString(s string) ([]byte, error)</p>
</li>
<li><p>func (enc *Encoding) Encode(dst, src []byte)</p>
</li>
<li><p>func (enc *Encoding) EncodeToString(src []byte) string</p>
</li>
</ul>
<p><strong>hex</strong></p>
<ul>
<li><p>func Decode(dst, src []byte) (int, error)</p>
</li>
<li><p>func DecodeString(s string) ([]byte, error)</p>
</li>
<li><p>func Encode(dst, src []byte) int</p>
</li>
<li><p>func EncodeToString(src []byte) string</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">base64Demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sc := [] <span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    encode := base64.StdEncoding.EncodeToString(sc)</span><br><span class="line">    <span class="comment">//base64.URLEncoding</span></span><br><span class="line">    fmt.Println(encode)</span><br><span class="line">    sc, _ := base64.StdEncoding.DecodeString(encode)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(sc))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sc := [] <span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    encode := hex.EncodeToString(sc)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(encode)</span><br><span class="line">    sc, _ := hex.DecodeString(encode)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(sc))</span><br><span class="line">&#125;</span><br><span class="line">base64Demo()</span><br><span class="line">hexDemo()</span><br></pre></td></tr></table></figure>

<pre><code>aGVsbG8=
hello
68656c6c6f
hello
</code></pre>
<h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>Go supports encode&#x2F;decode any type to&#x2F;from json, but most of time, <strong>we use <code>map or struct</code> for json encoding and decoding.</strong></p>
<p>Here are frequently used APIs provided by <code>encoding/json</code> package.  </p>
<p><code>func Marshal(v interface&#123;&#125;) ([]byte, error)</code></p>
<blockquote>
<p>Marshal traverses the value v <code>recursively</code>.</p>
</blockquote>
<p><strong>Encoding Note</strong>  </p>
<blockquote>
<p>The encoding of each struct field can be customized by the format string stored under the “json” key in the struct field’s tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.  </p>
</blockquote>
<blockquote>
<p>&#x2F;&#x2F; Field appears in JSON as key “myName”.<br>Field int <code>json:&quot;myName&quot;</code>  </p>
</blockquote>
<blockquote>
<p>&#x2F;&#x2F; Field appears in JSON as key “myName” and<br>&#x2F;&#x2F; the field is omitted from the object if its value is empty,<br>&#x2F;&#x2F; empty in GO means default value of each type<br>&#x2F;&#x2F; integer: 0<br>&#x2F;&#x2F; string: “”<br>&#x2F;&#x2F; pointer: nil<br>&#x2F;&#x2F; slice: has zero elements<br>&#x2F;&#x2F; omitempty: means if it’s not set or set with default value, these fileds are not marshed or unmarshed!!!<br>Field int <code>json:&quot;myName,omitempty&quot;</code>  </p>
</blockquote>
<blockquote>
<p>&#x2F;&#x2F; Field is ignored by this package.<br>Field int <code>json:&quot;-&quot;</code></p>
</blockquote>
<blockquote>
<p><strong>The map’s key type must either be a string, an integer type</strong><br><strong>map[string]interface{} to store arbitrary JSON objects, []interface{} to store arbitrary JSON arrays.</strong></p>
</blockquote>
<blockquote>
<p>Pointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.</p>
</blockquote>
<p><code>func MarshalIndent(v interface&#123;&#125;, prefix, indent string) ([]byte, error)</code></p>
<blockquote>
<p>MarshalIndent is like Marshal but applies Indent to format the output. Each JSON element in the output will begin on a new line beginning with prefix followed by one or more copies of indent according to the indentation nesting.</p>
</blockquote>
<p><code>func Unmarshal(data []byte, v interface&#123;&#125;) error</code></p>
<blockquote>
<p>Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v<br>Unmarshal uses the inverse of the encodings that Marshal uses, allocating maps, slices, and pointers as necessary, <strong>If v is nil or not a pointer, Unmarshal returns an InvalidUnmarshalError.</strong></p>
</blockquote>
<p>To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either <code>the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match</code>. By default, <strong>object keys which don’t have a corresponding struct field are ignored</strong>.</p>
<p><strong>map json key to struct field</strong></p>
<ul>
<li>For a given <strong>JSON key Foo</strong>, Unmarshal will attempt to match the struct fields in this order:<ul>
<li>an exported (public) field with a struct tag json:”Foo”,</li>
<li>an exported field named Foo, or</li>
<li>an exported field named FOO, FoO, or some other case-insensitive match.</li>
</ul>
</li>
</ul>
<p><strong>Only fields that are found in the destination type will be decoded, any unexported fields in the destination struct will be unaffected.</strong></p>
<p><strong>encode—&gt; Marshal()   —&gt; to json string</strong><br><strong>decode—&gt; Unmarshal() —&gt; to struct or map</strong></p>
<p><strong>What to use (Structs vs maps)</strong><br>As a general rule of thumb, if <strong>you can use structs to represent your JSON data, you should use them</strong>. The only good reason to use maps would be if <strong>it were not possible to use structs due to the uncertain nature of the keys or values in the data</strong>.</p>
<p>If we use maps, we will either need each of the keys to have the same data type, or use a generic type and convert it later.</p>
<p><strong>NOTE</strong>  </p>
<ul>
<li><p><font color='red'>Only exported field are encode and marshaled</font></p>
</li>
<li><p><code>json.Marshal(obj), json.Marshal(&amp;obj)</code> both are ok </p>
</li>
<li><p><font color='red' size=4> <code>json.Unmarshal(&amp;obj)</code> must use pointer as parameter, the pointer must not be nil!!!</font></p>
</li>
<li><p><code>json.NewEncoder(os.Stdout).Encode(obj)</code>, <code>json.NewEncoder(os.Stdout).Encode(&amp;obj)</code> both are ok, write encoded data from obj to os.Stdout.</p>
</li>
<li><p><code>json.Decoder(os.Stdin).Decode(&amp;obj)</code> must use pointer as parameter, read decoded data from os.Stdin to obj</p>
</li>
<li><p><code>Marshal is used to encode struct/map to string</code> while <code>Encode() is used to encode struct/map and write to io.Writer</code>, similar thing happens for Unmarshal and Decode().</p>
</li>
<li><p>You can <font color='red'><strong>Marshal from one struct, but Unmarshal to another struct</strong>, but only the ‘matched’ field are assigned, others use default, <strong>the ‘matched’ field must have same type!!! but the tag&#x2F;name obeys above rules.</strong></font></p>
</li>
</ul>
<p><strong>Sugestion for json.Decoder() vs json.Unmarshal()</strong></p>
<ul>
<li><p>use json.Decoder if your <code>data is coming from an io.Reader stream</code>, or you need to decode multiple values from a stream of data</p>
</li>
<li><p>Use json.Unmarshal if you already have the JSON string in memory.</p>
</li>
</ul>
<p><font color='red'><strong>json.Decoder(io.Reader).Decode(&amp;obj) blocks if no data available, returns if EOF, error or data available. if io.Reader is a file, it reads them all to buffer, then UnMarshal, if io.Reader is a connection, receives data then Unmarshal()</strong></font></p>
<p><strong>Marshal a string, just quoted them, “” is added</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">buf1 := []byte(s) // buf1[<span class="number">0</span>] == <span class="string">&#x27;h&#x27;</span> <span class="built_in">len</span>(buf1) == <span class="number">5</span></span><br><span class="line"></span><br><span class="line">buf2, _:= json.Marshal(s)// buf[<span class="number">0</span>] == <span class="string">&#x27;&quot;&#x27;</span>, <span class="built_in">len</span>(buf2)==<span class="number">7</span></span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Msg *<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Id   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Student&#123;</span><br><span class="line">        Name: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">        Id:   <span class="number">100</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes, _ := json.Marshal(&amp;s)</span><br><span class="line">    fmt.Println(<span class="string">&quot;json string: &quot;</span>,<span class="type">string</span>(bytes))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// \r, \n is ignore when Unmarshal!!!</span></span><br><span class="line">    bytes = <span class="built_in">append</span>(bytes, <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">    bytes = <span class="built_in">append</span>(bytes, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    p := &amp;Person&#123;&#125;</span><br><span class="line">    err := json.Unmarshal(bytes, p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(p.Name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>json string:  &#123;&quot;Name&quot;:&quot;tom&quot;,&quot;Id&quot;:100&#125;
tom
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">json_struct_demo</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="keyword">type</span> FruitBasket <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name    <span class="type">string</span></span><br><span class="line">        Fruit   []<span class="type">string</span>  <span class="comment">// an array</span></span><br><span class="line">        Id      <span class="type">int64</span>  <span class="string">`json:&quot;ref&quot;`</span> <span class="comment">// struct tag used as json key when encoding</span></span><br><span class="line">        private <span class="type">string</span>   <span class="comment">// An unexported field is not encoded, if you run with main()!!!</span></span><br><span class="line">        Created time.Time</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    basket := FruitBasket&#123;</span><br><span class="line">        Name:    <span class="string">&quot;Standard&quot;</span>,</span><br><span class="line">        Fruit:   []<span class="type">string</span>&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;,</span><br><span class="line">        Id:      <span class="number">999</span>,</span><br><span class="line">        private: <span class="string">&quot;Second-rate&quot;</span>,</span><br><span class="line">        Created: time.Now(),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> jsonData []<span class="type">byte</span></span><br><span class="line">    <span class="comment">//jsonData, err := json.Marshal(basket) //encode return a slice of byte</span></span><br><span class="line">    jsonData, err := json.MarshalIndent(basket, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(jsonData)) <span class="comment">//convert slice to a string</span></span><br><span class="line">    </span><br><span class="line">    jd := []<span class="type">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;Name&quot;: &quot;Standard&quot;,</span></span><br><span class="line"><span class="string">        &quot;Fruit&quot;: [</span></span><br><span class="line"><span class="string">            &quot;Apple&quot;,</span></span><br><span class="line"><span class="string">            &quot;Banana&quot;,</span></span><br><span class="line"><span class="string">            &quot;Orange&quot;</span></span><br><span class="line"><span class="string">        ],</span></span><br><span class="line"><span class="string">        &quot;ref&quot;: 999,</span></span><br><span class="line"><span class="string">        &quot;Created&quot;: &quot;2018-04-09T23:00:00Z&quot;</span></span><br><span class="line"><span class="string">    &#125;`</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// when passed with struct, you must know the field of the json string</span></span><br><span class="line">    <span class="comment">// so that it can be mapped to the proper filed of the struct!!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> bt FruitBasket</span><br><span class="line">    err := json.Unmarshal(jd, &amp;bt) <span class="comment">// must pass pointer!!!</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(bt.Name, bt.Fruit, bt.Id)</span><br><span class="line">    fmt.Println(bt.Created)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, bt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">json_struct_demo()</span><br></pre></td></tr></table></figure>

<pre><code>&#123;
    &quot;Name&quot;: &quot;Standard&quot;,
    &quot;Fruit&quot;: [
        &quot;Apple&quot;,
        &quot;Banana&quot;,
        &quot;Orange&quot;
    ],
    &quot;ref&quot;: 999,
    &quot;饞€竝rivate&quot;: &quot;Second-rate&quot;,
    &quot;Created&quot;: &quot;2022-07-01T17:23:27.137247781+08:00&quot;
&#125;
Standard [Apple Banana Orange] 999
2018-04-09 23:00:00 +0000 UTC
&#123;Name:Standard Fruit:[Apple Banana Orange] Id:999 饞€竝rivate: Created:2018-04-09 23:00:00 +0000 UTC&#125;
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">json_map_demo</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Eve&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Age&quot;</span>:  <span class="number">6.0</span>,</span><br><span class="line">        <span class="string">&quot;Parents&quot;</span>: []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">            <span class="number">12</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> jsonData []<span class="type">byte</span></span><br><span class="line">    <span class="comment">//jsonData, err := json.Marshal(basket) //encode return a slice of byte</span></span><br><span class="line">    jsonData, err := json.MarshalIndent(m, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(jsonData)) <span class="comment">//convert slice to a string</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    js := <span class="string">`&#123;&quot;name&quot;: &quot;battery sensor&quot;, &quot;capacity&quot;: 40&#125;`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reading <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// any type of value, nil map here!</span></span><br><span class="line">    </span><br><span class="line">    err := json.Unmarshal([]<span class="type">byte</span>(js), &amp;reading)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%+v %v %v %T\n&quot;</span>,</span><br><span class="line">                   reading, reading[<span class="string">&quot;name&quot;</span>],</span><br><span class="line">                   reading[<span class="string">&quot;capacity&quot;</span>],</span><br><span class="line">                   reading[<span class="string">&quot;capacity&quot;</span>]) <span class="comment">// type of number in json after parsed, it&#x27;s float64!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">json_map_demo()</span><br></pre></td></tr></table></figure>

<pre><code>&#123;
    &quot;Age&quot;: 6,
    &quot;Name&quot;: &quot;Eve&quot;,
    &quot;Parents&quot;: [
        &quot;Alice&quot;,
        &quot;Bob&quot;,
        12
    ]
&#125;
map[capacity:40 name:battery sensor] battery sensor 40 float64
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.OpenFile(<span class="string">&quot;/tmp/json&quot;</span>, os.O_CREATE|os.O_RDWR, <span class="number">0644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;failed to open file /tmp/json&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    ne := json.NewEncoder(f)</span><br><span class="line"></span><br><span class="line">    ev := <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">        Score <span class="type">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">    &#125;&#123;<span class="string">&quot;hi&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset moved to end of file</span></span><br><span class="line">    err = ne.Encode(ev)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;encode json failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">        YourName  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">        YourScore <span class="type">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dv Person</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move offset back to beginning of the file</span></span><br><span class="line">    _, err = f.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Seek back beginning failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    de := json.NewDecoder(f)</span><br><span class="line"></span><br><span class="line">    err = de.Decode(&amp;dv)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;decode from json failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, dv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>&#123;YourName:hi YourScore:100&#125;
</code></pre>
<h4 id="omitempty"><a href="#omitempty" class="headerlink" title="omitempty"></a>omitempty</h4><p>If field is set to its default value, the key itself will be omitted from the JSON object. <font color='red' size=4>omitempty only works for Marshal() to string!!!</font></p>
<p><code>zero</code> value(default) for each type  </p>
<ul>
<li>0 for numeric types,</li>
<li>false for the boolean type</li>
<li>“” (the empty string) for string.</li>
<li>nil for pointer</li>
<li>len(map) &#x3D;&#x3D; 0</li>
<li>len(slice) &#x3D;&#x3D; 0</li>
</ul>
<p><strong><font color='red'>No default value for struct object, so omitempy has no effect for embeded object!!!</font></strong></p>
<p>In cases where an empty value does not exist, omitempty is of no use. An embedded struct, for example, does not have an empty value:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dimension <span class="keyword">struct</span> &#123;</span><br><span class="line">    Height <span class="type">int</span></span><br><span class="line">    Width  <span class="type">int</span> <span class="string">`json:&quot;,omitempty&quot;`</span> <span class="comment">// effect here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Breed    <span class="type">string</span></span><br><span class="line">    WeightKg <span class="type">int</span></span><br><span class="line">    Size     dimension <span class="string">`json:&quot;,omitempty&quot;`</span> <span class="comment">// no effect here!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := Dog&#123;</span><br><span class="line">        Breed: <span class="string">&quot;pug&quot;</span>,</span><br><span class="line">        <span class="comment">// dimension is not set but not omitted!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    b, _ := json.Marshal(d)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&#123;&quot;Breed&quot;:&quot;pug&quot;,&quot;WeightKg&quot;:0,&quot;Size&quot;:&#123;&quot;Height&quot;:0&#125;&#125;</code></p>
<p>In this case, even though we never set the value of the Size attribute, and set its omitempty tag, it still appears in the output. This is because structs do not have any empty value in Go. To solve this, use a struct pointer instead :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Breed    <span class="type">string</span></span><br><span class="line">    WeightKg <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    Breed    <span class="type">string</span></span><br><span class="line">    WeightKg <span class="type">int</span> <span class="string">`json:&quot;weight,omitempty&quot;`</span></span><br><span class="line">    PWeightKg *<span class="type">int</span> <span class="string">`json:&quot;pweight,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := Dog&#123;</span><br><span class="line">        Breed: <span class="string">&quot;hal&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    nw := <span class="number">0</span></span><br><span class="line">    c0 := Cat&#123;</span><br><span class="line">        Breed: <span class="string">&quot;cal&quot;</span>,</span><br><span class="line">        WeightKg: <span class="number">0</span>, <span class="comment">// omitted as its value is default!!! warning!!!</span></span><br><span class="line">        PWeightKg: &amp;nw, <span class="comment">// not omitted as for pointer default value is nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    c1 := Cat&#123;</span><br><span class="line">        Breed: <span class="string">&quot;cal&quot;</span>,</span><br><span class="line">        WeightKg: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    b, _ := json.Marshal(d)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">    b, _ := json.Marshal(c0)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">    b, _ := json.Marshal(c1)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>&#123;&quot;Breed&quot;:&quot;hal&quot;,&quot;WeightKg&quot;:0&#125;
&#123;&quot;Breed&quot;:&quot;cal&quot;,&quot;pweight&quot;:0&#125;
&#123;&quot;Breed&quot;:&quot;cal&quot;,&quot;weight&quot;:1&#125;
</code></pre>
<h4 id="json-marshal-for-built-in-type"><a href="#json-marshal-for-built-in-type" class="headerlink" title="json.marshal for built-in type"></a>json.marshal for built-in type</h4><p>As you can json.Marshal() can be used for built-in type, the result is several bytes for that value, then you can Unmarshal to that type!</p>
<p><font color='red'><strong>json.Marshal() for nil will result ‘null’ string</strong></font></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    vb := <span class="literal">true</span></span><br><span class="line">    data, _ := json.Marshal(vb)</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">    fmt.Println(<span class="string">&quot;============&quot;</span>)</span><br><span class="line"></span><br><span class="line">    vi := <span class="number">12</span></span><br><span class="line">    data, _ = json.Marshal(vi)</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">    fmt.Println(<span class="string">&quot;============&quot;</span>)</span><br><span class="line"></span><br><span class="line">    vs := <span class="string">&quot;ab&quot;</span></span><br><span class="line">    data, _ = json.Marshal(vs)</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">    fmt.Println(<span class="string">&quot;============&quot;</span>)</span><br><span class="line"></span><br><span class="line">    vsc := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">    data, _ = json.Marshal(vsc)</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">    fmt.Println(<span class="string">&quot;============&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> vn <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">    data, _ = json.Marshal(vn)<span class="comment">// nul string for nil !!!</span></span><br><span class="line">    fmt.Println(data)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">    fmt.Println(<span class="string">&quot;============&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>[116 114 117 101]
true
============
[49 50]
12
============
[34 97 98 34]
&quot;ab&quot;
============
[91 34 97 34 44 34 98 34 93]
[&quot;a&quot;,&quot;b&quot;]
============
[110 117 108 108]
null
============
</code></pre>
<h3 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h3><p><strong>Marshal</strong><br><code>func Marshal(v any) ([]byte, error)</code><br>Marshal returns the XML encoding of v.</p>
<p>Marshal handles an array or slice by marshaling each of the elements. Marshal handles a pointer by marshaling the value it points at or, if the pointer is nil, by writing nothing. Marshal handles an interface value by marshaling the value it contains or, if the interface value is nil, by writing nothing. Marshal handles all other data by writing one or more XML elements containing the data.</p>
<p><strong>The name for the XML elements is taken from, in order of preference:</strong></p>
<ul>
<li>the <code>tag on the XMLName field</code>, if the data is a struct</li>
<li>the <code>value of the XMLName field</code> of type Name: the only one use value as name of element.!!!</li>
<li>the <code>tag of the struct field</code> used to obtain the data</li>
<li>the <code>name of the struct field</code> used to obtain the data</li>
<li>the <code>name of the marshaled type</code>.</li>
</ul>
<p>The XML element for a struct contains <code>marshaled elements for each of the exported fields of the struct, with these exceptions:</code></p>
<ul>
<li>the XMLName field, described above, is omitted.</li>
<li>a field with tag “-“ is omitted.</li>
<li>a field with tag “name,attr” becomes an attribute with the given name in the XML element.</li>
<li>a field with tag “,attr” becomes an attribute with the field name in the XML element.</li>
<li>a field with tag “,chardata” is written as character data, not as an XML element.(field value used for struct, as no <code>&lt;$tag&gt;&lt;/$tag&gt;</code> generated)</li>
<li>a field with tag “,cdata” is written as character data wrapped in one or more <code>&lt;![CDATA[...]]&gt;</code> tags, not as an XML element.</li>
<li>a field with tag “,innerxml” is written verbatim, not subject to the usual marshaling procedure.</li>
<li>a field with tag “,comment” is written as an XML comment, not subject to the usual marshaling procedure. It must not contain the “–” string within it.</li>
<li>a field with a tag including the “omitempty” option is omitted if the field value is empty. The <code>empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero</code>.</li>
<li><strong>an anonymous struct field is handled as if the fields of its value were part of the outer struct.</strong></li>
<li>a field implementing Marshaler is written by calling its MarshalXML method.</li>
<li>a field implementing encoding.TextMarshaler is written by encoding the result of its MarshalText method as text.</li>
</ul>
<p><strong>NOTE</strong></p>
<ul>
<li><p>If a field uses a tag “a&gt;b&gt;c”, then the element c will be nested inside parent elements a and b. Fields that appear next to each other that name the same parent will be enclosed in one XML element.</p>
</li>
<li><p>If the XML name for a struct field is defined by both the field tag and the struct’s XMLName field, the names must match.</p>
</li>
</ul>
<hr style="border:1px solid gray"> </hr>

<p><strong>Unmarshal</strong><br><code>func Unmarshal(data []byte, v any) error</code><br>Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded.</p>
<p>Because Unmarshal uses the reflect package, it can <code>only assign to exported (upper case) field</code>s. Unmarshal uses a case-sensitive comparison to match XML element names to tag values and struct field names.</p>
<p><strong>Unmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key ‘xml’ in the struct field’s tag</strong></p>
<ul>
<li><p>If the struct has a field of type []byte or string with tag “,innerxml”, Unmarshal accumulates the raw XML nested inside the element in that field. The rest of the rules still apply.</p>
</li>
<li><p>If the struct has a field named XMLName of type Name, Unmarshal records the element name in that field.</p>
</li>
<li><p>If the XMLName field has an associated tag of the form “name” or “namespace-URL name”, the XML element must have the given name (and, optionally, name space) or else Unmarshal returns an error.</p>
</li>
<li><p>If the XML element has an attribute whose name matches a struct field name with an associated tag containing “,attr” or the explicit name in a struct field tag of the form “name,attr”, Unmarshal records the attribute value in that field.</p>
</li>
<li><p>If the XML element has an attribute not handled by the previous rule and the struct has a field with an associated tag containing “,any,attr”, Unmarshal records the attribute value in the first such field.</p>
</li>
<li><p>If the XML element contains character data, that data is accumulated in the first struct field that has tag “,chardata”. The struct field may have type []byte or string. If there is no such field, the character data is discarded.</p>
</li>
<li><p>If the XML element contains comments, they are accumulated in the first struct field that has tag “,comment”.  The struct field may have type []byte or string. If there is no such field, the comments are discarded.</p>
</li>
<li><p>If the XML element contains a sub-element whose name matches the prefix of a tag formatted as “a” or “a&gt;b&gt;c”, unmarshal will descend into the XML structure looking for elements with the given names, and will map the innermost elements to that struct field. A tag starting with “&gt;” is equivalent to one starting with the field name followed by “&gt;”.</p>
</li>
<li><p>If the XML element contains a sub-element whose name matches a struct field’s XMLName tag and the struct field has no explicit name tag as per the previous rule, unmarshal maps the sub-element to that struct field.</p>
</li>
<li><p>If the XML element contains a sub-element whose name matches a field without any mode flags (“,attr”, “,chardata”, etc), Unmarshal maps the sub-element to that struct field.</p>
</li>
<li><p>If the XML element contains a sub-element that hasn’t matched any of the above rules and the struct has a field with tag “,any”, unmarshal maps the sub-element to that struct field.</p>
</li>
<li><p>An anonymous struct field is handled as if the fields of its value were part of the outer struct.</p>
</li>
<li><p>A struct field with tag “-“ is never unmarshaled into.</p>
</li>
</ul>
<p><strong>NOTE</strong></p>
<ul>
<li>If Unmarshal encounters a field type that implements the Unmarshaler interface, Unmarshal calls its UnmarshalXML method to produce the value from the XML element. Otherwise, if the value implements encoding.TextUnmarshaler, Unmarshal calls that value’s UnmarshalText method.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// when Plant used as field of another field.</span></span><br><span class="line"><span class="comment">// we explitly declare it&#x27;s tag name here, if user set tag, tag name must be same as defined here!!!</span></span><br><span class="line"><span class="keyword">type</span> Plant <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// xml.Name the root tag of struct, no need to set value for it!!</span></span><br><span class="line">    <span class="comment">// if no tag for it, you have to set value of XMLName as it&#x27;s value used for xml</span></span><br><span class="line">    XMLName xml.Name <span class="string">`xml:&quot;plant&quot;`</span></span><br><span class="line">    <span class="comment">// the attr of the root tag with id as its name</span></span><br><span class="line">    Id <span class="type">int</span> <span class="string">`xml:&quot;id,attr&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// nested tag of the root with &#x27;name&#x27; as its name</span></span><br><span class="line">    Name <span class="type">string</span> <span class="string">`xml:&quot;name&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even without explicitly name a tag, it&#x27;s exported if it starts with capital letter!!!</span></span><br><span class="line">    <span class="comment">// nested tag of the root with &#x27;Origin&#x27; as its name as it&#x27;s not named explicitly</span></span><br><span class="line">    <span class="comment">// several such tags as it&#x27;s an array</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// by default empty value is not saved to xml</span></span><br><span class="line">    Origin []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Plant)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Plant id=%v, name=%v, origin=%v&quot;</span>,</span><br><span class="line">        p.Id, p.Name, p.Origin)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    coffee := &amp;Plant&#123;Id: <span class="number">27</span>, Name: <span class="string">&quot;Coffee&quot;</span>&#125;</span><br><span class="line">    <span class="comment">//coffee.Origin = []string&#123;&quot;Ethiopia&quot;, &quot;Brazil&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">    out, _ := xml.MarshalIndent(coffee, <span class="string">&quot; &quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">    fmt.Println(<span class="string">&quot;==================================&quot;</span>)</span><br><span class="line">    fmt.Println(xml.Header + <span class="type">string</span>(out))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p Plant</span><br><span class="line">    <span class="keyword">if</span> err := xml.Unmarshal(out, &amp;p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;==================================&quot;</span>)</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    fmt.Println(<span class="string">&quot;==================================&quot;</span>)</span><br><span class="line"></span><br><span class="line">    tomato := &amp;Plant&#123;Id: <span class="number">81</span>, Name: <span class="string">&quot;Tomato&quot;</span>&#125;</span><br><span class="line">    tomato.Origin = []<span class="type">string</span>&#123;<span class="string">&quot;Mexico&quot;</span>, <span class="string">&quot;California&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> Nesting <span class="keyword">struct</span> &#123;</span><br><span class="line">        XMLName xml.Name <span class="string">`xml:&quot;nesting&quot;`</span></span><br><span class="line">        <span class="comment">// a&gt;b&gt;c: c(newplant) is used as name for Plant if Plant has no xml.Name specified explicitly</span></span><br><span class="line">        <span class="comment">// but no error if we set here newplant for Plant event it&#x27;s not used at all</span></span><br><span class="line">        Plants []*Plant <span class="string">`xml:&quot;parent&gt;child&gt;newplant&quot;`</span></span><br><span class="line">        <span class="comment">// ERROR: can NOT declare newplant as its name, as Plant has already declare it!!!</span></span><br><span class="line">        <span class="comment">// Plant *Plant `xml:&quot;newplant,omitempty&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nesting := &amp;Nesting&#123;&#125;</span><br><span class="line">    nesting.Plants = []*Plant&#123;coffee, tomato&#125;</span><br><span class="line"></span><br><span class="line">    out, err := xml.MarshalIndent(nesting, <span class="string">&quot; &quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code> &lt;plant id=&quot;27&quot;&gt;
   &lt;name&gt;Coffee&lt;/name&gt;
 &lt;/plant&gt;
==================================
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;plant id=&quot;27&quot;&gt;
   &lt;name&gt;Coffee&lt;/name&gt;
 &lt;/plant&gt;
==================================
&#123;&#123; plant&#125; 27 Coffee []&#125;
    ==================================
     <nesting>
       <parent>
         <child>
           <plant id="27">
             <name>Coffee</name>
           </plant>
           <plant id="81">
             <name>Tomato</name>
             <Origin>Mexico</Origin>
             <Origin>California</Origin>
           </plant>
         </child>
       </parent>
     </nesting>


#### chardata
In xml, mostly only the leaf node has value, leaf nodes can be defined by a field of struct, `the field type can be built-in type like int, string, leaf node without attr can use built-in type!!!`, like this:
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Garden <span class="keyword">struct</span> &#123;                                                            </span><br><span class="line">    Cool     <span class="type">string</span> <span class="string">`xml:&quot;cool,omitempty&quot;`</span>  </span><br><span class="line">&#125;</span><br><span class="line">gd = Garden&#123;&#125;</span><br><span class="line">gd.Cool = <span class="string">&quot;jas&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
The generate xml:
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Garden&gt;</span><br><span class="line">  &lt;cool&gt;jas&lt;/cool&gt;</span><br><span class="line">&lt;/Garden&gt;</span><br></pre></td></tr></table></figure>

What about if we want to add attr to cool, there is no way to do as, cool is built-in type, you can not add attr to it, you need to declare a struct, like this, as Value is chardata, not XML element, that means **`chardata is needed for leaf node that has attrs and its value`**
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CoolT &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`xml:&quot;name,attr&quot;`</span></span><br><span class="line">    Value <span class="type">string</span> <span class="string">`xml:&quot;,chardata&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Garden <span class="keyword">struct</span> &#123;                                                            </span><br><span class="line">    Cool     <span class="type">string</span> <span class="string">`xml:&quot;cool,omitempty&quot;`</span>  </span><br><span class="line">&#125;</span><br><span class="line">gd = Garden&#123;&#125;</span><br><span class="line">gd.Cool = <span class="string">&quot;jas&quot;</span></span><br></pre></td></tr></table></figure>

#### custom UnmarshalXML and MarshalXML
For user type, user can implement its own UnmarshalXML and marshalXML of that type, which is called by xml.Marshal() and xml.UnmarshalXML(), if you do not want to use the default logic of this process.

### gob
`Gob is like pickle in python and Protobuf`, they are used to serialize object, the serialized object is a stream which is self-describing(`have type, value, name et`c). `Each data item in the stream is preceded by a specification of its type, expressed in terms of a small set of predefined types`. Pointers are not transmitted, but the things they point to are transmitted; that is, the values are flattened. Nil pointers are not permitted, as they have no value. Recursive types work fine, but recursive values (data with cycles) are problematic. This may change.

To use gobs, create an Encoder and present it with a series of data items as values or addresses that can be dereferenced to values. The Encoder makes sure all type information is sent before it is needed. At the receive side, a Decoder retrieves values from the encoded stream and unpacks them into local variables.

The source and destination values/types `need not correspond exactly`. For structs, fields (identified by name) that are in the source but absent from the receiving variable will be ignored. Fields that are in the receiving variable but missing from the transmitted type or value will be ignored in the destination. **If a field with the same name is present in both, their types must be compatible**. Both the receiver and transmitter will do all necessary indirection and dereferencing to convert between gobs and actual Go values.

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123; A, B <span class="type">int</span> &#125;</span><br></pre></td></tr></table></figure>
can be sent from or received into any of these Go types below:

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123; A, B <span class="type">int</span> &#125;	<span class="comment">// the same</span></span><br><span class="line">*<span class="keyword">struct</span> &#123; A, B <span class="type">int</span> &#125;	<span class="comment">// extra indirection of the struct</span></span><br><span class="line"><span class="keyword">struct</span> &#123; *A, **B <span class="type">int</span> &#125;	<span class="comment">// extra indirection of the fields</span></span><br><span class="line"><span class="keyword">struct</span> &#123; A, B <span class="type">int64</span> &#125;	<span class="comment">// different concrete value type; see below</span></span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/gob&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y, Z <span class="type">int</span></span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Q <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y *<span class="type">int32</span> <span class="comment">// when decode from P, Z is ignored, int converted to int32</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example shows the basic usage of the package: Create an encoder,</span></span><br><span class="line"><span class="comment">// transmit some values, receive them with a decoder.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Initialize the encoder and decoder. Normally enc and dec would be</span></span><br><span class="line">    <span class="comment">// bound to network connections and the encoder and decoder would</span></span><br><span class="line">    <span class="comment">// run in different processes but here is just a demo to show how it works !!!</span></span><br><span class="line">    <span class="keyword">var</span> network bytes.Buffer        <span class="comment">// Stand-in for a network connection</span></span><br><span class="line">    enc := gob.NewEncoder(&amp;network) <span class="comment">// Will write to network.</span></span><br><span class="line">    dec := gob.NewDecoder(&amp;network) <span class="comment">// Will read from network.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encode (send) some values.</span></span><br><span class="line">    err := enc.Encode(P&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&quot;Pythagoras&quot;</span>&#125;) <span class="comment">// instance of P struct serialized to buffer.</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;encode error:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    err = enc.Encode(P&#123;<span class="number">1782</span>, <span class="number">1841</span>, <span class="number">1922</span>, <span class="string">&quot;Treehouse&quot;</span>&#125;) <span class="comment">// another instance of P struct serialized to buffer.</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;encode error:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode (receive) and print the values. as it&#x27;s stream first in, first out!!!</span></span><br><span class="line">    <span class="keyword">var</span> q Q</span><br><span class="line">    err = dec.Decode(&amp;q) <span class="comment">//after decode, first instance is removed from stream.</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;decode error 1:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q: &#123;%d, %d&#125;\n&quot;</span>, q.Name, *q.X, *q.Y)</span><br><span class="line">    </span><br><span class="line">    err = dec.Decode(&amp;q)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;decode error 2:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q: &#123;%d, %d&#125;\n&quot;</span>, q.Name, *q.X, *q.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

    "Pythagoras": &#123;3, 4&#125;
    "Treehouse": &#123;1782, 1841&#125;


## hash(get hash value)
Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum mostly `used for data transfer over network`.

`Package maphash` provides `hash functions on byte sequences`. These hash functions are intended to be used to implement hash tables or other data structures that need to `map arbitrary strings or byte sequences to a uniform distribution on unsigned 64-bit integers`. Each different instance of a hash table or data structure should use its own Seed.
**maphash API**
- func (h *Hash) Sum64() uint64
- func (h *Hash) Write(b []byte) (int, error)
- func (h *Hash) WriteString(s string) (int, error)

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;hash/crc32&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;hash/crc64&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;hash/maphash&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maphashDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> h maphash.Hash</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a string to the hash, and print the current hash value.</span></span><br><span class="line">    h.WriteString(<span class="string">&quot;hello, &quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, h.Sum64())</span><br><span class="line">    </span><br><span class="line">    h.Reset() <span class="comment">// seed unchanged, so same value for same string</span></span><br><span class="line">    h.WriteString(<span class="string">&quot;hello, &quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, h.Sum64())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crcDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maphashDemo()</span><br><span class="line">crcDemo()</span><br></pre></td></tr></table></figure>

## math
Package rand implements pseudo-random number generators.   
**random API**  
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- func (r *Rand) Float32() float32 [0, 1)</span><br><span class="line">- func (r *Rand) Int() int</span><br><span class="line">- func (r *Rand) Int31() int32</span><br><span class="line">- func (r *Rand) Int63() int64</span><br><span class="line">                                    </span><br><span class="line">- func (r *Rand) Intn(n int) int        range [0, n)</span><br><span class="line">- func (r *Rand) Int31n(n int32) int32        [0, n)</span><br><span class="line">- func (r *Rand) Int63n(n int64) int64         \[0, n)</span><br><span class="line">                                    </span><br><span class="line">- func (r *Rand) Uint32() uint32</span><br><span class="line">- func (r *Rand) Uint64() uint64</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// set seed</span></span><br><span class="line">    r := rand.New(rand.NewSource(<span class="number">99</span>))</span><br><span class="line">    fmt.Println(r.Float32(), r.Int(), r.Intn(<span class="number">100</span>), r.Uint32())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">randDemo()</span><br></pre></td></tr></table></figure>

    0.2635776 5864379541603903257 90 2699839765


## crypto
Package, crypto, aes, des, rsa, sha1, sha256, hmac, md5

## file/IO ops
There are many ways to read and write IO in golang. At present, I know `IO library, OS library, ioutil library, bufio library, bytes library and so on`, which one to choose?  which library should be used in what scenario?

- The OS library mainly deals with the operating system, so file operations are basically linked with the OS library, such as creating a file, deleting a file, change file mode, creating dir etc. This library is often used with ioutil library, bufio library, etc
    - *os.File is a type that implements io.Reader, and io.Writer (among others) which streams bytes to or from a file on disk
      It is useful if you don't want to read the whole file into memory, It has the downside of being a lower level construct,  meaning data must often be processed in loops (with error checks on each iteration), and that it must be manually managed (via Close())


- io library belongs to the bottom interface definition library. 
    - its function is to `define some basic interfaces and some basic constants,` and to explain the functions of these interfaces. The common interfaces are reader, writer, etc. Generally, `this library is only used to call its constants, such as io.EOF`.


- The ioutil library is included in the IO directory. It is mainly used as a toolkit. There are some practical functions, such as readall (read data from a source), readfile (read file content), WriteFile (write data to a file), readdir (get directory), it's easy to use, like readfile, `it does some operation automatically which we should do by ourself if use os.File`
    - It automatically allocates a byte slice of the correct size (no need to Read + append in a loop)
    - It automatically closes the file
    - It returns the first error that prevented it from working (so you only need a single error check)

- bufio provides wrapper types for io.Reader and io.Writer that buffer the input / output to improve efficiency.
    - If you are reading a file in one or a few large steps, you probably don't need it either
    - buffered input and output add some extra concerns
    - bufio.Scanner is a nice utility type to efficiently read independent lines of text from an io.Reader
        
        
- bytes provides helper functions and types for interacting with byte slices ([]byte)
    - `bytes.Reader turns a []byte into a io.Reader (as well as an io.Seeker to rewind)`
    - `bytes.Buffer uses []bytes to implement a reader/writer, it is useful when you want to use code that takes an io.Writer, and store the results in memory for use later`
       
       
- bufio vs bytes.Buffer: both of them provide a layer of caching function. The main difference between them is that `bufio is for file to memory caching, wrap other Reader/Writer`, while `bytes.Buffer is for memory to memory caching`.

<hr style="border:1px solid gray"> </hr>

<font color='red'>**Suggestion**</font>

- **file operation, create/delete/chmod use` os library`**
- **small file, load at once, use `ioutil`**
- **large file, `bufio` support read line by line, or read word by word etc**
- **control read size of file by yourself, read many times, `os.File`**
- **In memory reader/writer `bytes.Buffer`**

When Read encounters an error or end-of-file condition after successfully reading n > 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that **a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF**.

Callers should always process the n > 0 bytes returned before considering the error err. Doing so correctly handles I/O errors that happen after reading some bytes and also both of the allowed EOF behaviors. 

[IO-Cookbook](https://jesseduffield.com/Golang-IO-Cookbook/)

<hr style="border:1px solid gray"> </hr>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">src:</span><br><span class="line"> - bufio</span><br><span class="line">  - bufio.go</span><br><span class="line"> - bytes</span><br><span class="line">  - buffer.go</span><br><span class="line">  - reader.go</span><br><span class="line"> - io</span><br><span class="line">  - ioutil</span><br><span class="line">   - ioutil.go</span><br><span class="line">  - io.go</span><br><span class="line"> - os</span><br><span class="line">  - file.go</span><br><span class="line"> - strings </span><br><span class="line">  - reader.go</span><br></pre></td></tr></table></figure>


<font color='red'  size=3>io/ioutil was a poorly defined collection of helpers, you should use os.xxx if avaiable.</font>

### os


standard package `os` provides basic operations file system while File provides read/write operations.

- func Chdir(dir string) error
- func Chmod(name string, mode FileMode) error
- func Chown(name string, uid, gid int) error

- func Stat(name string) (FileInfo, error)
- func IsExist(err error) bool
- func IsNotExist(err error) bool

- func ReadDir(name string) ([]DirEntry, error)
- func Mkdir(name string, perm FileMode) error
- func MkdirAll(path string, perm FileMode) error
- func MkdirTemp(dir, pattern string) (string, error)

- func Remove(name string) error
- func RemoveAll(path string) error
- func Rename(oldpath, newpath string) error

- func ReadFile(name string) ([]byte, error) // read all at once

- func Create(name string) (*File, error)
- func Open(name string) (*File, error)
- func OpenFile(name string, flag int, perm FileMode) (*File, error)


- func (f *File) Close() error
- func (f *File) Read(b []byte) (n int, err error) // read size of slice from file
- func (f *File) ReadAt(b []byte, off int64) (n int, err error)
- func (f *File) Write(b []byte) (n int, err error)
- func (f *File) WriteAt(b []byte, off int64) (n int, err error)
- func (f *File) WriteString(s string) (n int, err error)
- func (f *File) ReadDir(n int) ([]DirEntry, error)
- func (f *File) Sync() error


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FileMakePath</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;                                           </span><br><span class="line">    <span class="keyword">if</span> stat, err := os.Stat(path); os.IsExist(err) &#123;                             </span><br><span class="line">        <span class="keyword">if</span> stat.IsDir() &#123;                                                        </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>                                                           </span><br><span class="line">        &#125;                                                                        </span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;[util] %s exists, but not dir&quot;</span>, path)                 </span><br><span class="line">    &#125;                                                                            </span><br><span class="line">                                                                                 </span><br><span class="line">    <span class="comment">// create if not exists                                                      </span></span><br><span class="line">    <span class="keyword">if</span> err := os.MkdirAll(path, <span class="number">0777</span>); err != <span class="literal">nil</span> &#123;                              </span><br><span class="line">        <span class="keyword">return</span> err                                                               </span><br><span class="line">    &#125;                                                                            </span><br><span class="line">                                                                                </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>                                                                   </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    info, err := os.Stat(<span class="string">&quot;/tmp/test&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;/tmp/test not found, creating it&quot;</span>)</span><br><span class="line">            _, err := os.Create(<span class="string">&quot;/tmp/test&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;create failed: %v\n&quot;</span>, err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;created&quot;</span>)</span><br><span class="line">                os.Chmod(<span class="string">&quot;/tmp/test&quot;</span>, <span class="number">0777</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;stats of /tmp/test: %v\n&quot;</span>, info)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the file doesn&#x27;t exist, create it, or append to the file</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">&quot;/tmp/test&quot;</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write data to file</span></span><br><span class="line">    file.Write([]<span class="type">byte</span>(<span class="string">&quot;ab\n&quot;</span>))</span><br><span class="line">    file.WriteString(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    file.Close()</span><br><span class="line"></span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">100</span>)</span><br><span class="line">    file, err = os.Open(<span class="string">&quot;/tmp/test&quot;</span>)</span><br><span class="line">    <span class="comment">// read data from file at most 100 bytes!!</span></span><br><span class="line">    _, err = file.Read(data)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;read error &quot;</span>, err)</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;file content: \n%s\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">    file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.Remove(<span class="string">&quot;/tmp/test&quot;</span>) != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;failed to remove file /tmp/test&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;removed file /tmp/test&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

    /tmp/test not found, creating it
    created
    file content: 
    ab
    hello                                                                                            
    removed file /tmp/test


### ioutil
#### read whole file once


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;write hello to file&quot;</span>)</span><br><span class="line">    <span class="comment">// easy to write and read file !!!</span></span><br><span class="line">    </span><br><span class="line">    err := ioutil.WriteFile(<span class="string">&quot;/tmp/test.txt&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;hello \nworld&quot;</span>), <span class="number">0644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// read whole file at once, if file is large not good way</span></span><br><span class="line">    file, err := ioutil.ReadFile(<span class="string">&quot;/tmp/test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;read content: %s&quot;</span>, file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// readall from io.Reader</span></span><br><span class="line">    r := strings.NewReader(<span class="string">&quot;hello\nboy\n&quot;</span>)</span><br><span class="line">    buf, _ := ioutil.ReadAll(r)</span><br><span class="line">    fmt.Printf(<span class="type">string</span>(buf))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

    write hello to file
    read content: hello 
    worldhello
    boy


### bufio
In some case, **file is large, we want to read line by line, or read until meet delimiter or read word by word**, this what bufio supports, it also provides read any data size but with buffer.

**bufio is a wrapper of another io.Reader/io.Writer, then gives more advanced feature, hence in order to use it, you need an io.Reader firstly, as it wraps io.Reader/io.Writer, hence you should NOT close it with bufio interface, but with io.Reader/io.Writer interface, use interfaces provided by bufio for reading/writing only**


**API**
- `func (b *Reader) Read(p []byte) (n int, err error)`
>Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying Reader, hence n may be less than len(p).
- `func (b *Reader) ReadBytes(delim byte) ([]byte, error)`
>ReadBytes reads until the first occurrence of delim in the input, returning a slice **containing the data up to and including the delimiter**. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.
- `func (b *Reader) ReadString(delim byte) (string, error)`
>Same as ReadBytes as it just calls ReadBytes directly, then convert bytes to string 

- `func (s *Scanner) Scan() bool`
><font color='red' size=4>returns until the first occurrence of delim in the input(or error, EOF), by default delim  is `\n`, or `\r\n`</font>

**NOTE: `\r\n, \n` is returned by `ReadBytes() and ReadString()` which is not true for Scanner.Text(),Scanner.Bytes() which striped**

#### read file line by line


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">&quot;hello boy\ngirl\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reader</span></span><br><span class="line">    br := bufio.NewReader(r)</span><br><span class="line">    line, err := br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// line with \n!!!, its count is 10!!!</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v: %d\n&quot;</span>, line, <span class="built_in">len</span>([]<span class="type">rune</span>(line)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    line, err = br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%v&quot;</span>, line)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v: %d\n&quot;</span>, line, <span class="built_in">len</span>([]<span class="type">rune</span>(line)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;use scanner&quot;</span>)</span><br><span class="line">    <span class="comment">// Scanner to read line by line</span></span><br><span class="line">    <span class="comment">// return to start position</span></span><br><span class="line">    r.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    scanner := bufio.NewScanner(r)</span><br><span class="line">    <span class="comment">// read word by word: scanner.Split(bufio.ScanWords)</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;<span class="comment">// returns until \n!!!</span></span><br><span class="line">        <span class="comment">//scaner.Text() has stripped line, no \n</span></span><br><span class="line">        fmt.Println(scanner.Text(), <span class="built_in">len</span>([]<span class="type">rune</span>(scanner.Text())))</span><br><span class="line">        fmt.Println(<span class="type">string</span>(scanner.Bytes()), <span class="built_in">len</span>(scanner.Bytes()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

    hello boy
    : 10
    girl
    : 5
    use scanner
    hello boy 9
    hello boy 9
    girl 4
    girl 4


### io.Copy and io.Pipe and bytes.Buffer and string.NewReader()

Package io provides basic interfaces to I/O primitives. Its primary job is to wrap existing implementations of such primitives, such as those in package os, into `shared public interfaces that abstract the functionality, plus some other related primitives`.

In most cases, `we did NOT use io library directly, but it provides two convenient ways io.Copy and io.Pipe which is used in most application.`

- `func Copy(dst Writer, src Reader) (written int64, err error)`
>Copy copies from src to dst until either EOF is reached on src or an error occurs. It returns the number of bytes copied and the first error encountered while copying, if any. A successful Copy returns err == nil, not err == EOF. Because Copy is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.
If src implements the WriterTo interface, the copy is implemented by calling src.WriteTo(dst). Otherwise, if dst implements the ReaderFrom interface, the copy is implemented by calling dst.ReadFrom(src). 

- `func Pipe() (*PipeReader, *PipeWriter)`
>Pipe creates a `synchronous in-memory pipe`. It can be used to connect code expecting an io.Reader with code expecting an io.Writer. Reads and Writes on the pipe are matched one to one except when multiple Reads are needed to consume a single Write. That is, **each Write to the PipeWriter blocks until it has satisfied one or more Reads from the PipeReader that fully consume the written data**. The data is copied directly from the Write to the corresponding Read (or Reads); there is no internal buffering.

**Note**
- pipe.Write() returns only when **error happens or all data is received by reader, otherwise it blocks**
- pipe.Read() returns data received and tell Writer how many it receives, so that writer can write immediately after get the notification

**Cases**
- <font color='red'>io.Copy: Get data(bytes) from reader, without any change, Write to writer **(no user involved)**, this what io.Copy mostly used, reader and writer can anyone like file, string, in memory etc!!</font>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">&quot;hello boy\ngirl\n&quot;</span>)</span><br><span class="line">    <span class="comment">// copy from reader to writer</span></span><br><span class="line">    <span class="comment">// support any reader and any writer</span></span><br><span class="line">    io.Copy(os.Stdout, r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buffer *bytes.Buffer</span><br><span class="line">    buffer = bytes.NewBufferString(<span class="string">&quot;hello boy\ngirl\n&quot;</span>)</span><br><span class="line">    io.Copy(os.Stdout, buffer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- <font color='red'>io.Pipe() same as io.Copy, but more limitation and more efficient, as reader and writer are bound from beginning and they are in memory, **need user call write() and read() API**.</font>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    preader, pwriter := io.Pipe()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        reader := strings.NewReader(<span class="string">&quot;ab&quot;</span>)</span><br><span class="line">        fmt.Println(<span class="string">&quot;writer writes data and blocks as reader is not ready&quot;</span>)</span><br><span class="line">        io.Copy(pwriter, reader)</span><br><span class="line">        fmt.Println(<span class="string">&quot;writer waked up after data is read&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read blocks until writer write data or writer close/error</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">60</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;reader sleep 1 seconds before reading&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">    c, err := preader.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;error reading&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">        <span class="comment">//fmt.Println(string(buf))</span></span><br><span class="line">        fmt.Println(<span class="type">string</span>(buf[:c]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

    reader sleep 1 seconds before reading
    writer writes data and blocks as reader is not ready
    writer waked up after data is read
    ab


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Importing fmt, io, and bytes</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calling main</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calling Pipe method</span></span><br><span class="line">    pipeReader, pipeWriter := io.Pipe()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using Fprint in go function to write</span></span><br><span class="line">    <span class="comment">// data to the file</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// block here until reader read it all or read call Close()</span></span><br><span class="line">        n, err := fmt.Fprint(pipeWriter, <span class="string">&quot;Geeks\n&quot;</span>)</span><br><span class="line">        <span class="comment">// the print may be printed before or after last rcv!!!</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;pipeWriter returns %v bytes is written err: %v\n&quot;</span>, n, err)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using Close method to close write</span></span><br><span class="line">        pipeWriter.Close()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := io.ReadFull(pipeReader, buf)</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;rcv: %v bytes: %q\n&quot;</span>, n, <span class="type">string</span>(buf))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**Possible output**
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rcv: 2 bytes: &quot;Ge&quot;</span><br><span class="line">rcv: 2 bytes: &quot;ek&quot;</span><br><span class="line">rcv: 2 bytes: &quot;s\n&quot;</span><br><span class="line">pipeWriter returns 6 bytes is written err: &lt;nil&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rcv: 2 bytes: &quot;Ge&quot;</span><br><span class="line">rcv: 2 bytes: &quot;ek&quot;</span><br><span class="line">pipeWriter returns 6 bytes is written err: &lt;nil&gt;</span><br><span class="line">rcv: 2 bytes: &quot;s\n&quot;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calling main</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calling Pipe method</span></span><br><span class="line">    pipeReader, pipeWriter := io.Pipe()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using Fprint in go function to write</span></span><br><span class="line">    <span class="comment">// data to the file</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// block here until reader read it all or read call Close()</span></span><br><span class="line">        n, err := fmt.Fprint(pipeWriter, <span class="string">&quot;Geeks\n&quot;</span>)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;pipeWriter returns: %v bytes is written err: %v\n&quot;</span>, n, err)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using Close method to close write</span></span><br><span class="line">        pipeWriter.Close()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data into buffer</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;starts to read&quot;</span>)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := io.ReadFull(pipeReader, buf)</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;rcv: %v bytes: %q\n&quot;</span>, n, <span class="type">string</span>(buf))</span><br><span class="line">            pipeReader.Close()</span><br><span class="line">            <span class="comment">// sleep a while for writer to quit first</span></span><br><span class="line">            time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

    starts to read
    rcv: 2 bytes: "Ge"
    pipeWriter returns: 2 bytes is written err: io: read/write on closed pipe



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">&quot;some io.Reader stream to be read\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(os.Stdout, r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// copy from reder to os.Stdout(console)</span></span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an new memory buffer.</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">60</span>)</span><br><span class="line">    buffer := bytes.NewBuffer(buf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// after Copy, reader reach to EOF, we we should reset it to read data again</span></span><br><span class="line">    r.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// read from reader to buffer!!!</span></span><br><span class="line">    buffer.ReadFrom(r)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s&quot;</span>, buffer.String())</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q&quot;</span>, buffer.String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

    some io.Reader stream to be read
                                                                some io.Reader stream to be read
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00some io.Reader stream to be read\n"

### list all files(file,dir) under a dir
- os.ReadDir (return all)
- os.File.ReadDir(can limit return entries)
- ioutil.ReadDir(less efficient than os.ReadDir
- filepath.Glob(support patterns)
- filepath.Walk(support recursive sub-dirs, above does not support this)

## signal

**[signal wiki page](https://en.wikipedia.org/wiki/Signal_(IPC))**

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// os.Interrupt&lt;----&gt;syscall.SIGINT (Ctrl+C)</span></span><br><span class="line">    <span class="comment">// os.Kill     &lt;----&gt;syscall.SIGKILL</span></span><br><span class="line">    signal.Notify(c, os.Interrupt)</span><br><span class="line">    signal.Notify(c, os.Kill)</span><br><span class="line">    signal.Notify(c, syscall.SIGQUIT)</span><br><span class="line">    signal.Notify(c, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s := &lt;-c:</span><br><span class="line">        fmt.Println(<span class="string">&quot;sig: &quot;</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## random
Random numbers are generated by a Source. Top-level functions, such as and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines, but Sources created by NewSource are not.

This package's outputs might be easily predictable regardless of how it's seeded. For random numbers suitable for security-sensitive work, see the `crypto/rand` package.

- Int/Int31/Int63: generate random number without range
- Intn/Int31n/Int63n: generate random number from [0, n)


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    fmt.Println(rand.Int(), rand.Intn(<span class="number">10</span>))</span><br><span class="line">    fmt.Println(rand.Int31(), rand.Int31n(<span class="number">10</span>))</span><br><span class="line">    fmt.Println(rand.Int63(), rand.Int63n(<span class="number">10</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// generate bunch of numbers</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">6</span>)</span><br><span class="line">    rand.Read(buf)</span><br><span class="line">    fmt.Println(buf)</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

    5656737410240953005 4
    670732630 8
    846728672197744499 9
    [40 95 241 197 58 113]


## template
There are two packages operating with templates `text/template and html/template`. Both provide the same interface, however the html/template package is used to generate HTML output safe against code injection.

Templates are executed by applying them to a `data structure`. Annotations in the template refer to elements of the data structure (typically a field of a struct or a key in a map) to control execution and derive values to be displayed. `Execution of the template walks the structure and sets the cursor, represented by a period '.' and called "dot", to the value at the current location in the structure as execution proceeds.`, **data structure is represented by a period '.'**

To obtain data from a struct, you can use the `&#123;&#123; .FieldName &#125;&#125;` action, which will replace it with FieldName value of given struct, on parse time.
</code></pre>
<p>There is also the <code>&#123;&#123; . &#125;&#125;</code> action that you can use to refer to a value of non-struct types.</p>
<p>Templates are provided to the appropriate functions either as string or as “raw string”. Actions represents the data evaluations, functions or control loops. <code>They are delimited by &#123;&#123; &#125;&#125;. Other, non delimited parts are left untouched</code>.</p>
<p>Here is the list of actions. <strong>“Arguments” and “pipelines” are evaluations of data</strong>, defined in detail in the corresponding sections that follow.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;/* a comment */&#125;&#125;</span><br><span class="line">&#123;&#123;- /* a comment with white space trimmed from preceding and following text */ -&#125;&#125;</span><br><span class="line">	A comment; discarded. May contain newlines.</span><br><span class="line">	Comments do not nest and must start and end at the</span><br><span class="line">	delimiters, as shown here.</span><br><span class="line"></span><br><span class="line">&#123;&#123;pipeline&#125;&#125;</span><br><span class="line">	The default textual representation (the same as would be</span><br><span class="line">	printed by fmt.Print) of the value of the pipeline is copied</span><br><span class="line">	to the output.</span><br><span class="line"></span><br><span class="line">&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;</span><br><span class="line">	If the value of the pipeline is empty, no output is generated;</span><br><span class="line">	otherwise, T1 is executed. The empty values are false, 0, any</span><br><span class="line">	nil pointer or interface value, and any array, slice, map, or</span><br><span class="line">	string of length zero.</span><br><span class="line">	Dot is unaffected.</span><br><span class="line"></span><br><span class="line">&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125;</span><br><span class="line">	If the value of the pipeline is empty, T0 is executed;</span><br><span class="line">	otherwise, T1 is executed. Dot is unaffected.</span><br><span class="line"></span><br><span class="line">&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;else if pipeline&#125;&#125; T0 &#123;&#123;end&#125;&#125;</span><br><span class="line">	To simplify the appearance of if-else chains, the else action</span><br><span class="line">	of an if may include another if directly; the effect is exactly</span><br><span class="line">	the same as writing</span><br><span class="line">		&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125;&#123;&#123;if pipeline&#125;&#125; T0 &#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;range pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;</span><br><span class="line">	The value of the pipeline must be an array, slice, map, or channel.</span><br><span class="line">	If the value of the pipeline has length zero, nothing is output;</span><br><span class="line">	otherwise, dot is set to the successive elements of the array,</span><br><span class="line">	slice, or map and T1 is executed. If the value is a map and the</span><br><span class="line">	keys are of basic type with a defined order, the elements will be</span><br><span class="line">	visited in sorted key order.</span><br><span class="line">    Dot is changed if pipeline is not zero</span><br><span class="line"></span><br><span class="line">&#123;&#123;range pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125;</span><br><span class="line">	The value of the pipeline must be an array, slice, map, or channel.</span><br><span class="line">	If the value of the pipeline has length zero, dot is unaffected and</span><br><span class="line">	T0 is executed; otherwise, dot is set to the successive elements</span><br><span class="line">	of the array, slice, or map and T1 is executed.</span><br><span class="line">    Dot is change if pipeline is not zero</span><br><span class="line">    </span><br><span class="line">&#123;&#123;template &quot;name&quot;&#125;&#125;</span><br><span class="line">	The template with the specified name is executed with nil data.</span><br><span class="line"></span><br><span class="line">&#123;&#123;template &quot;name&quot; pipeline&#125;&#125;</span><br><span class="line">	The template with the specified name is executed with dot set</span><br><span class="line">	to the value of the pipeline.</span><br><span class="line">    New temaplte&#x27;s dot is set with pipeline</span><br><span class="line"></span><br><span class="line">&#123;&#123;block &quot;name&quot; pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;</span><br><span class="line">	A block is shorthand for defining a template</span><br><span class="line">		&#123;&#123;define &quot;name&quot;&#125;&#125; T1 &#123;&#123;end&#125;&#125;</span><br><span class="line">	and then executing it in place</span><br><span class="line">		&#123;&#123;template &quot;name&quot; pipeline&#125;&#125;</span><br><span class="line">	The typical use is to define a set of root templates that are</span><br><span class="line">	then customized by redefining the block templates within.</span><br><span class="line"></span><br><span class="line">&#123;&#123;with pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;</span><br><span class="line">	If the value of the pipeline is empty, no output is generated;</span><br><span class="line">	otherwise, dot is set to the value of the pipeline and T1 is</span><br><span class="line">	executed.</span><br><span class="line">    Dot is change if pipeline is not zero</span><br><span class="line">    </span><br><span class="line">&#123;&#123;with pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125;</span><br><span class="line">	If the value of the pipeline is empty, dot is unaffected and T0</span><br><span class="line">	is executed; otherwise, dot is set to the value of the pipeline</span><br><span class="line">	and T1 is executed.</span><br><span class="line">    Dot is change if pipeline is not zero</span><br><span class="line">    </span><br><span class="line">. is change during scope, while $ is unchanged, it&#x27;s top .</span><br><span class="line">pipeline is empty means.</span><br><span class="line">0-     interger</span><br><span class="line">nil-   pointer, interface</span><br><span class="line">len=0  array, slice, map, string</span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p><strong>Basics</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template from a file</span></span><br><span class="line">t1, err := template.ParseFiles(<span class="string">&quot;test.html&quot;</span>)</span><br><span class="line"><span class="comment">// template from string</span></span><br><span class="line">t1, err := template.New(<span class="string">&quot;test&quot;</span>).Parse(<span class="string">`&#123;&#123;&quot;raw string&quot; | printf&#125;&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output to stdout</span></span><br><span class="line">t1.Execute(os.Stdout, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output to any Writer</span></span><br><span class="line">t1.Execute(Writer, <span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Rules to write template, refer to <a target="_blank" rel="noopener" href="https://pkg.go.dev/text/template">template format</a> and <a target="_blank" rel="noopener" href="https://pkg.go.dev/text/template#hdr-Functions">built-in functions</a>, <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1683688">template examples</a>, <a target="_blank" rel="noopener" href="https://github.com/Masterminds/sprig">extra functions provided by sprig</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;html/template&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Inventory <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Id   <span class="type">uint</span></span><br><span class="line">    Cool <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sweaters := Inventory&#123;<span class="string">&quot;wool&quot;</span>, <span class="number">17</span>, <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">    tmpl, err := template.New(<span class="string">&quot;test&quot;</span>).Parse(<span class="string">`</span></span><br><span class="line"><span class="string">&#123;&#123;&quot;raw string&quot; | printf&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;.Name&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123; with $Id :=  .Id&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;- $Id -&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end -&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;if .Cool&#125;&#125; &#123;&#123;/*must has such field!!!*/&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;.Cool&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;else&#125;&#125;</span></span><br><span class="line"><span class="string">NO Cool in field</span></span><br><span class="line"><span class="string">&#123;&#123;end -&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;if (gt .Id 10)&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;- .Id -&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// render with data from struct!!!</span></span><br><span class="line">    err = tmpl.Execute(os.Stdout, sweaters)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>raw string
wool
17
NO Cool in field
17
</code></pre>
<h1 id="non-standard"><a href="#non-standard" class="headerlink" title="non-standard"></a>non-standard</h1><h2 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h2><p>uuid.UUID is new type(alias) <code>[16]byte</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/google/uuid&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    id := uuid.New()</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>string to uuid bytes</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uid, _:= uuid.Parse(<span class="string">&quot;b1762c24-48ff-4f67-a66c-e3aeb66051f0&quot;</span>)</span><br><span class="line">bytes := uid[:] <span class="comment">// convert UUID to [16]byte</span></span><br></pre></td></tr></table></figure>
<p><strong>bytes to uuid string</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uid, _:= uuid.FromBytes(bytes)</span><br><span class="line">ustr := uid.String()  <span class="comment">// convert UUID to string</span></span><br></pre></td></tr></table></figure>

<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>Besides the standard log package, there are lots of log library for Go, here are some popular ones.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// These two line can be omitted if print log to console</span></span><br><span class="line">    outfile, _ := os.OpenFile(<span class="string">&quot;/tmp/my.log&quot;</span>, os.O_APPEND|os.O_WRONLY|os.O_CREATE, <span class="number">0600</span>)</span><br><span class="line">    logger := log.New(outfile, <span class="string">&quot;log_prefix &quot;</span>, log.Llongfile | log.Ldate|log.Ltime|log.Lmicroseconds)</span><br><span class="line"></span><br><span class="line">    logger.Println(<span class="string">&quot;hello, log!!!&quot;</span>)</span><br><span class="line">    <span class="comment">//print to console directly</span></span><br><span class="line">    log.Println(<span class="string">&quot;hello console&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cat /tmp/my.log</span></span><br><span class="line"><span class="comment">// log_prefix 2021/10/09 11:40:58.169531 /home/data/tmp/lg.go:13: hello, log!!!</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/sirupsen/logrus">logrus</a>–&gt;structured logger, completely API compatible with the standard library logger</li>
<li><a target="_blank" rel="noopener" href="https://github.com/uber-go/zap">zap</a>–&gt;structured, leveled logging in Go, high performance</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/glog">glog</a>–&gt;simple, stable, standard lib provided by Go</li>
<li><a target="_blank" rel="noopener" href="https://github.com/oklog/oklog">oklog</a>—-&gt;no updates years, old</li>
<li><a target="_blank" rel="noopener" href="https://github.com/cihub/seelog">seelog</a>–&gt;no updates years, old</li>
<li><a target="_blank" rel="noopener" href="https://github.com/rs/zerolog">zerolog</a> –&gt;json output</li>
</ul>
<p><strong>Suggestion:</strong>  </p>
<ul>
<li>For simple usage, use glog</li>
<li>Structured, use logrus</li>
<li>Need high performance, zap is best choice.</li>
</ul>
<h3 id="glog"><a href="#glog" class="headerlink" title="glog"></a>glog</h3><p>format when writing logs <code>&lt;header&gt;] &lt;message&gt;</code>, header has below format.<br><code>Lmmdd hh:mm:ss.uuuuuu threadid file:line</code></p>
<ul>
<li>L: log level, I(INFO), W(WARNING), E(ERROR), F(FATAL))</li>
<li>mmdd hh:mm:ss.uuuuuu time of log</li>
<li>threadid: thread id</li>
<li>file:line: file trigger the log</li>
</ul>
<p><strong>Log format Example</strong><br><code>I0715 13:28:17.923715   31920 main.go:14] hello message</code></p>
<p><strong>API</strong>  </p>
<ul>
<li>glog.Flush()</li>
<li>glog.Info()&#x2F;glog.Infof()&#x2F;glog.Infoln()</li>
<li>glog.Warning()&#x2F;glog.Warningf()&#x2F;glog.Warningln()</li>
<li>glog.Error()&#x2F;glog.Errorf()&#x2F;glog.Errorln()</li>
<li>glog.Fatal()&#x2F;glog.Fatalf()&#x2F;glog.Fatalln(), note os.Exit() when Fatalx() called.</li>
</ul>
<p><strong>NOTE</strong></p>
<ul>
<li><p><strong>glog.Infof(), glog.Errorf(), glog.Warningf() will auto added <code>\n</code> at last if user not set</strong></p>
</li>
<li><p>glog saves different log level to different files, but low log file contains high log as well, say INFO log files has ERROR log as well!!!</p>
</li>
<li><p>glog.Info&#x2F;Warning&#x2F;Error&#x2F;Fatal always writes log to file, no switch to turn it on&#x2F;off</p>
</li>
<li><p>use glog.V() and pass -v flag to control whether or not to write log to Info file, <strong>as V only provides <code>Infof()</code>, that means, it’s INFO log!!!, so do NOT use it for error, warning, trace logs!!!</strong></p>
</li>
<li><p>By default, glog saves logs to &#x2F;tmp, <code>change it to your path with -log_dir</code></p>
</li>
<li><p>By default, glog does not print log to std, change it <code>to stdio instead of file with -logtostderr</code></p>
</li>
<li><p>Need both std and file, <code>use -alsologtostderr as well as -log_dir</code></p>
</li>
<li><p><font color='red'><strong>must put it at main(): flag.Parse()</strong></font></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># log to /var/log dir, make sure it exists</span></span><br><span class="line">$ go run main.go  -log_dir=/var/log</span><br><span class="line"></span><br><span class="line"><span class="comment"># you can you see, for each start(as time pid is different), glog will create 4 logs files!!!</span></span><br><span class="line"><span class="comment"># 20210727-062649.9900--&gt;date: 2021 year 07.27  time:06.26.49  pid: 9900</span></span><br><span class="line">$ <span class="built_in">ls</span> /var/log</span><br><span class="line">g.centos.root.log.INFO.20210727-062649.9900 (named: &lt;program name&gt;.&lt;hostname&gt;.&lt;user name&gt;.<span class="built_in">log</span>.&lt;severity level&gt;.&lt;<span class="built_in">date</span>&gt;.&lt;time&gt;.&lt;pid&gt;)</span><br><span class="line">$ <span class="built_in">cat</span> g.centos.root.log.INFO.20210727-062649.9900</span><br><span class="line">I1115 09:52:34.216494   29618 g.go:36] hello</span><br><span class="line"><span class="built_in">date</span>  time              pid   file:line] <span class="variable">$msg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># log to stderr</span></span><br><span class="line">$ go run main.go -logtostderr</span><br></pre></td></tr></table></figure>


<p><strong>Sample code</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/golang/glog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">defer</span> glog.Flush()</span><br><span class="line"></span><br><span class="line">    glog.Info(<span class="string">&quot;This is info message&quot;</span>)</span><br><span class="line">    glog.Infof(<span class="string">&quot;This is info message: %v&quot;</span>, <span class="number">12345</span>)</span><br><span class="line">    glog.Infoln(<span class="string">&quot;This is info message:&quot;</span>, <span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>V style</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/golang/glog&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">defer</span> glog.Flush()</span><br><span class="line">    <span class="comment">// log only print when set -v equal or larger than 2</span></span><br><span class="line">    <span class="comment">// $ go run g.log -v 2, the number of level can be range from 0-int32!</span></span><br><span class="line">    <span class="comment">// but most of time we use 0--5</span></span><br><span class="line">    <span class="keyword">if</span> glog.V(<span class="number">2</span>) &#123;</span><br><span class="line">        glog.Info(<span class="string">&quot;Starting transaction...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    glog.V(<span class="number">2</span>).Infof(<span class="string">&quot;Processed elements %d&quot;</span>, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="logrus"><a href="#logrus" class="headerlink" title="logrus"></a>logrus</h3><p><strong>log Format</strong><br><code>$level[0000] message $field=$value $field=$value</code><br><code>INFO[0000] A walrus appears                              animal=walrus</code></p>
<p><strong>API</strong>  </p>
<ul>
<li>log.Trace(“Something very low level.”)</li>
<li>log.Debug(“Useful debugging information.”)</li>
<li>log.Info(“Something noteworthy happened!”)</li>
<li>log.Warn(“You should probably take a look at this.”)</li>
<li>log.Error(“Something failed but I’m not quitting.”)</li>
<li>log.Fatal(“Bye.”) &#x2F;&#x2F; Calls os.Exit(1) after logging</li>
<li>log.Panic(“I’m bailing.”) &#x2F;&#x2F; Calls panic() after logging</li>
</ul>
<p><strong>Sample code</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main                                                                    </span><br><span class="line">                                                                                </span><br><span class="line"><span class="keyword">import</span> (                                                                        </span><br><span class="line">    <span class="string">&quot;os&quot;</span>                                                                        </span><br><span class="line">                                                                                </span><br><span class="line">    log <span class="string">&quot;github.com/sirupsen/logrus&quot;</span>                                            </span><br><span class="line">)                                                                               </span><br><span class="line">                                                                                </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                                                                   </span><br><span class="line">    <span class="comment">// Log as JSON instead of the default ASCII formatter.                      </span></span><br><span class="line">    <span class="comment">//log.SetFormatter(&amp;log.JSONFormatter&#123;&#125;)                                    </span></span><br><span class="line">                                                                                </span><br><span class="line">    <span class="comment">// Output to stdout instead of the default stderr                           </span></span><br><span class="line">    <span class="comment">// Can be any io.Writer, see below for File example                         </span></span><br><span class="line">    <span class="comment">// log.SetOutput(os.Stdout)                                                 </span></span><br><span class="line">                                                                                </span><br><span class="line">    <span class="comment">// You could set this to any `io.Writer` such as a file                     </span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">&quot;logrus.log&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;                                                             </span><br><span class="line">        log.SetOutput(file)                                                     </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                    </span><br><span class="line">        log.Info(<span class="string">&quot;Failed to log to file, using default stderr&quot;</span>)                 </span><br><span class="line">    &#125;                                                                           </span><br><span class="line">                                                                                </span><br><span class="line">    log.WithFields(log.Fields&#123;                                                  </span><br><span class="line">        <span class="string">&quot;animal&quot;</span>: <span class="string">&quot;walrus&quot;</span>,                                                     </span><br><span class="line">    &#125;).Info(<span class="string">&quot;A walrus appears&quot;</span>)                                                 </span><br><span class="line">&#125;                                                                               </span><br></pre></td></tr></table></figure>

<h2 id="gopsutil"><a href="#gopsutil" class="headerlink" title="gopsutil"></a>gopsutil</h2><p>In most monitor system, we need to get some info about the system, like CPU, memory, disk, net, process etc, gopsutil provides better API to support these, you do NOT need to deal with OS related files or API, gopsutil handles this for you, its supports get info about below aspects.</p>
<ul>
<li>cpu</li>
<li>disk</li>
<li>docker</li>
<li>host</li>
<li>load</li>
<li>mem</li>
<li>net</li>
<li>process</li>
<li>winservices</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/shirou/gopsutil/v3/mem&quot;</span></span><br><span class="line">    <span class="comment">// &quot;github.com/shirou/gopsutil/mem&quot;  // to use v2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v, _ := mem.VirtualMemory()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// almost every return value is a struct</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Total: %v, Free:%v, UsedPercent:%f%%\n&quot;</span>, v.Total, v.Free, v.UsedPercent)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert to JSON. String() is also implemented</span></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>More details, please refer to <a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/shirou/gopsutil">gopsutil</a></p>
<h2 id="file-ops"><a href="#file-ops" class="headerlink" title="file ops"></a>file ops</h2><p>As <code>os</code> package provides basic function to operation file system, it still have more work for user to do,that’s why <a target="_blank" rel="noopener" href="https://github.com/spf13/afero">afero</a> comes in, it gives a lot of very powerful possibilities.</p>
<h3 id="afero"><a href="#afero" class="headerlink" title="afero"></a>afero</h3><p>Afero is a filesystem framework providing a simple, uniform and universal API interacting with any filesystem, as an abstraction layer providing interfaces, types and methods, it provides significant improvements over using the os package alone, most notably the ability to create mock and testing filesystems without relying on the disk.</p>
<p>It is <strong>suitable for use in any situation where you would consider using the OS package as it provides an additional abstraction</strong> that makes it easy to use a memory backed file system during testing. It also adds support for the http filesystem for full interoperability.</p>
<p><strong>File System Methods Available:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Chmod(name <span class="type">string</span>, mode os.FileMode) : <span class="type">error</span></span><br><span class="line">Chown(name <span class="type">string</span>, uid, gid <span class="type">int</span>) : <span class="type">error</span></span><br><span class="line">Chtimes(name <span class="type">string</span>, atime time.Time, mtime time.Time) : <span class="type">error</span></span><br><span class="line">Create(name <span class="type">string</span>) : File, <span class="type">error</span></span><br><span class="line">Mkdir(name <span class="type">string</span>, perm os.FileMode) : <span class="type">error</span></span><br><span class="line">MkdirAll(path <span class="type">string</span>, perm os.FileMode) : <span class="type">error</span></span><br><span class="line">Name() : <span class="type">string</span></span><br><span class="line">Open(name <span class="type">string</span>) : File, <span class="type">error</span></span><br><span class="line">OpenFile(name <span class="type">string</span>, flag <span class="type">int</span>, perm os.FileMode) : File, <span class="type">error</span></span><br><span class="line">Remove(name <span class="type">string</span>) : <span class="type">error</span></span><br><span class="line">RemoveAll(path <span class="type">string</span>) : <span class="type">error</span></span><br><span class="line">Rename(oldname, newname <span class="type">string</span>) : <span class="type">error</span></span><br><span class="line">Stat(name <span class="type">string</span>) : os.FileInfo, <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p><strong>File Interfaces and Methods Available:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">io.Closer</span><br><span class="line">io.Reader</span><br><span class="line">io.ReaderAt</span><br><span class="line">io.Seeker</span><br><span class="line">io.Writer</span><br><span class="line">io.WriterAt</span><br><span class="line"></span><br><span class="line">Name() : <span class="type">string</span></span><br><span class="line">Readdir(count <span class="type">int</span>) : []os.FileInfo, <span class="type">error</span></span><br><span class="line">Readdirnames(n <span class="type">int</span>) : []<span class="type">string</span>, <span class="type">error</span></span><br><span class="line">Stat() : os.FileInfo, <span class="type">error</span></span><br><span class="line">Sync() : <span class="type">error</span></span><br><span class="line">Truncate(size <span class="type">int64</span>) : <span class="type">error</span></span><br><span class="line">WriteString(s <span class="type">string</span>) : ret <span class="type">int</span>, err <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p><strong>Utilities</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DirExists(path <span class="type">string</span>) (<span class="type">bool</span>, <span class="type">error</span>)</span><br><span class="line">Exists(path <span class="type">string</span>) (<span class="type">bool</span>, <span class="type">error</span>)</span><br><span class="line">FileContainsBytes(filename <span class="type">string</span>, subslice []<span class="type">byte</span>) (<span class="type">bool</span>, <span class="type">error</span>)</span><br><span class="line">GetTempDir(subPath <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">IsDir(path <span class="type">string</span>) (<span class="type">bool</span>, <span class="type">error</span>)</span><br><span class="line">IsEmpty(path <span class="type">string</span>) (<span class="type">bool</span>, <span class="type">error</span>)</span><br><span class="line">ReadDir(dirname <span class="type">string</span>) ([]os.FileInfo, <span class="type">error</span>)</span><br><span class="line">ReadFile(filename <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">SafeWriteReader(path <span class="type">string</span>, r io.Reader) (err <span class="type">error</span>)</span><br><span class="line">TempDir(dir, prefix <span class="type">string</span>) (name <span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line">TempFile(dir, prefix <span class="type">string</span>) (f File, err <span class="type">error</span>)</span><br><span class="line">Walk(root <span class="type">string</span>, walkFn filepath.WalkFunc) <span class="type">error</span></span><br><span class="line">WriteFile(filename <span class="type">string</span>, data []<span class="type">byte</span>, perm os.FileMode) <span class="type">error</span></span><br><span class="line">WriteReader(path <span class="type">string</span>, r io.Reader) (err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Declare a backend</strong><br>The backend can be In memory, native OS system, readonly etc</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/spf13/afero&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AppFs = afero.NewMemMapFs()</span><br><span class="line"><span class="comment">//OR</span></span><br><span class="line"><span class="keyword">var</span> AppFs = afero.NewOsFs()</span><br><span class="line"><span class="comment">//OR</span></span><br><span class="line"><span class="keyword">var</span> AppFs = afero.NewReadOnlyFs(afero.NewOsFs())</span><br></pre></td></tr></table></figure>

<h2 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h2><p>There are lots of pkgs to develop CLI, here only list some of them.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/flag">flag</a>: simple, standard lib, not support subcommand</li>
<li><a target="_blank" rel="noopener" href="https://github.com/spf13/pflag">pflag</a>: implementing POSIX&#x2F;GNU-style –flags</li>
<li><a target="_blank" rel="noopener" href="https://github.com/jessevdk/go-flags">go-flags</a>: This library provides similar functionality to the builtin flag library of go, but provides much more functionality and nicer formatting.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/urfave/cli">urfave&#x2F;cli</a>: popular one</li>
<li><a target="_blank" rel="noopener" href="https://github.com/spf13/cobra">spf13&#x2F;cobra</a>: more powerful, used by k8s, docker etc</li>
</ul>
<p><strong>Suggestion</strong>  </p>
<ul>
<li>very simple use, no subcommand needed, less options, use flag</li>
<li>simple use, lots of options, use go-flags</li>
<li>complex command line cobra</li>
</ul>
<h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag.int returns the var which is used to access parsed value</span></span><br><span class="line"><span class="keyword">var</span> cliName = flag.String(<span class="string">&quot;yourname&quot;</span>, <span class="string">&quot;nick&quot;</span>, <span class="string">&quot;Input Your Name&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> cliAge = flag.Int(<span class="string">&quot;yourage&quot;</span>, <span class="number">28</span>, <span class="string">&quot;Input Your Age&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> cliGender = flag.String(<span class="string">&quot;yourgender&quot;</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Input Your Gender&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cliFlag <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// IntVar uses an existing var</span></span><br><span class="line">    flag.IntVar(&amp;cliFlag, <span class="string">&quot;flagname&quot;</span>, <span class="number">1234</span>, <span class="string">&quot;Just for demo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// start parsing from os.Args[1:], os.Args[0] is the app name</span></span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print parsed value</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;name=&quot;</span>, *cliName)</span><br><span class="line">    fmt.Println(<span class="string">&quot;age=&quot;</span>, *cliAge)</span><br><span class="line">    fmt.Println(<span class="string">&quot;gender=&quot;</span>, *cliGender)</span><br><span class="line">    fmt.Println(<span class="string">&quot;flagname=&quot;</span>, cliFlag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="go-flags"><a href="#go-flags" class="headerlink" title="go-flags"></a>go-flags</h3><p>Package flags provides an extensive command line option parser. The flags package is similar in functionality to the go builtin flag package but provides more options and uses reflection to provide a convenient and succinct way of specifying command line options.</p>
<p>Supported features:</p>
<ul>
<li>Options with short names (-v)                                                 </li>
<li>Options with long names (–verbose)                                           </li>
<li>Options with and without arguments (bool v.s. other type)                     </li>
<li>Options with <code>optional arguments and default values</code>                            </li>
<li>Multiple option groups each containing a set of options                       </li>
<li>Generate and print well-formatted help message                                </li>
<li>Passing remaining command line arguments after – (optional)                  </li>
<li>Ignoring unknown command line options (optional)                              </li>
<li>Supports -I&#x2F;usr&#x2F;include -I&#x3D;&#x2F;usr&#x2F;include -I &#x2F;usr&#x2F;include option argument specification</li>
<li>Supports multiple short options -aux                                          </li>
<li>Supports all primitive go types (string, int{8..64}, uint{8..64}, float)      </li>
<li>Supports same option multiple times (can store in slice or last option counts)</li>
<li>Supports maps                                                                 </li>
<li>Supports function callbacks                                                   </li>
<li>Supports namespaces for (nested) option groups</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">    gflags <span class="string">&quot;github.com/jessevdk/go-flags&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> opts <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// Slice of bool will append &#x27;true&#x27; each time the option</span></span><br><span class="line">        <span class="comment">// is encountered (can be set multiple times, like -vvv)</span></span><br><span class="line">        Verbose []<span class="type">bool</span> <span class="string">`short:&quot;v&quot; long:&quot;verbose&quot; description:&quot;Show verbose debug information&quot;`</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of automatic marshalling to desired type (uint)</span></span><br><span class="line">        Offset <span class="type">uint</span> <span class="string">`long:&quot;offset&quot; description:&quot;Offset&quot;`</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a callback, called each time the option is found.</span></span><br><span class="line">        Call <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="string">`short:&quot;c&quot; description:&quot;Call phone number&quot;`</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a required flag</span></span><br><span class="line">        Name <span class="type">string</span> <span class="string">`short:&quot;n&quot; long:&quot;name&quot; description:&quot;A name&quot; required:&quot;true&quot;`</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a flag restricted to a pre-defined set of strings</span></span><br><span class="line">        Animal <span class="type">string</span> <span class="string">`long:&quot;animal&quot; choice:&quot;cat&quot; choice:&quot;dog&quot;`</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a value name</span></span><br><span class="line">        File <span class="type">string</span> <span class="string">`short:&quot;f&quot; long:&quot;file&quot; description:&quot;A file&quot; value-name:&quot;FILE&quot;`</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a slice of strings</span></span><br><span class="line">        StringSlice []<span class="type">string</span> <span class="string">`short:&quot;s&quot; description:&quot;A slice of strings&quot;`</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a map</span></span><br><span class="line">        IntMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="string">`long:&quot;intmap&quot; description:&quot;A map from string to int&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callback which will invoke callto:&lt;argument&gt; to call a number.</span></span><br><span class="line">    <span class="comment">// Note that this works just on OS X (and probably only with</span></span><br><span class="line">    <span class="comment">// Skype) but it shows the idea.</span></span><br><span class="line">    opts.Call = <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        cmd := exec.Command(<span class="string">&quot;open&quot;</span>, <span class="string">&quot;callto:&quot;</span>+num)</span><br><span class="line">        cmd.Start()</span><br><span class="line">        cmd.Process.Release()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parser := gflags.NewParser(&amp;opts, gflags.Default|gflags.IgnoreUnknown|gflags.PassAfterNonOption)</span><br><span class="line">    parser.Usage = <span class="string">&quot;start \n\n start a pod&quot;</span></span><br><span class="line">    args, err := parser.Parse()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Verbosity: %v\n&quot;</span>, opts.Verbose)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Offset: %d\n&quot;</span>, opts.Offset)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Name: %s\n&quot;</span>, opts.Name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Animal: %s\n&quot;</span>, opts.Animal)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;StringSlice: %v\n&quot;</span>, opts.StringSlice)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;IntMap: [a:%v b:%v]\n&quot;</span>, opts.IntMap[<span class="string">&quot;a&quot;</span>], opts.IntMap[<span class="string">&quot;b&quot;</span>])</span><br><span class="line">    <span class="comment">// after parse, args is changed, parased ones are removed</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Remaining args: %s\n&quot;</span>, strings.Join(args, <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="spf13-x2F-cobra"><a href="#spf13-x2F-cobra" class="headerlink" title="spf13&#x2F;cobra"></a>spf13&#x2F;cobra</h3><p>Cobra is a library providing a simple interface to create powerful modern CLI interfaces similar to git &amp; go tools.</p>
<p><strong>Cobra provides:</strong></p>
<ul>
<li>Easy subcommand-based CLIs: app server, app fetch, etc.</li>
<li>Fully POSIX-compliant flags (including short &amp; long versions)</li>
<li>Nested subcommands</li>
<li>Global, local and cascading flags</li>
<li>Easy generation of applications &amp; commands with <strong>cobra init appname &amp; cobra add cmdname</strong></li>
<li>Intelligent suggestions (app srver… did you mean app server?)</li>
<li>Automatic help generation for commands and flags</li>
<li>Automatic help flag recognition of -h, –help, etc.</li>
<li>Automatically generated shell autocomplete for your application (bash, zsh, fish, powershell)</li>
<li>Automatically generated man pages for your application</li>
</ul>
<p>Cobra is built on a structure of commands, arguments &amp; flags.<br>Commands represent actions, Args are things and Flags are modifiers for those actions.like this <code>git clone URL --bare</code></p>
<p>How to write CLI by cobra</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/spf13/cobra/blob/master/user_guide.md">user guide</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spf13/cobra/blob/master/cobra/README.md">auto generate cmd</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/how-to-create-a-cli-in-golang-with-cobra-d729641c7177">example using cobra</a></li>
</ul>
<h2 id="Go-cron-scheduling"><a href="#Go-cron-scheduling" class="headerlink" title="Go cron scheduling"></a>Go cron scheduling</h2><p><a target="_blank" rel="noopener" href="https://github.com/go-co-op/gocron">go cron</a> is a Golang job scheduling package which lets you run Go functions periodically at pre-determined interval using a simple, human-friendly syntax.</p>
<p><img src="https://user-images.githubusercontent.com/19351306/110375142-2ba88680-8017-11eb-80c3-554cc746b165.png" alt="design"></p>
<ul>
<li>Scheduler: The scheduler tracks all the jobs assigned to it and makes sure they are passed to the executor when ready to be run. The scheduler is able to manage overall aspects of job behavior like limiting how many jobs are running at one time.</li>
<li>Job: The job is simply aware of the task (go function) it’s provided and is therefore only able to perform actions related to that task like preventing itself from overruning a previous task that is taking a long time.</li>
<li>Executor: The executor, as it’s name suggests, is simply responsible for calling the task (go function) that the job hands to it when sent by the scheduler.</li>
</ul>
<p><strong>Tags</strong><br>Jobs may have arbitrary tags added which can be useful when tracking many jobs. The scheduler supports both enforcing tags to be unique and when not unique, running all jobs with a given tag.</p>
<p><strong>Interval supports</strong></p>
<ul>
<li>milliseconds</li>
<li>seconds</li>
<li>minutes</li>
<li>hours</li>
<li>days</li>
<li>weeks</li>
<li>months</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s := gocron.NewScheduler(time.UTC)</span><br><span class="line">s.TagsUnique()</span><br><span class="line"></span><br><span class="line">_, _ = s.Every(<span class="number">1</span>).Week().Tag(<span class="string">&quot;foo&quot;</span>).Do(task)</span><br><span class="line">_, err := s.Every(<span class="number">1</span>).Week().Tag(<span class="string">&quot;foo&quot;</span>).Do(task)</span><br><span class="line"><span class="comment">// error!!!</span></span><br><span class="line"></span><br><span class="line">s := gocron.NewScheduler(time.UTC)</span><br><span class="line"></span><br><span class="line">s.Every(<span class="number">2</span>).Day().Tag(<span class="string">&quot;tag&quot;</span>).At(<span class="string">&quot;10:00&quot;</span>).Do(task)</span><br><span class="line">s.Every(<span class="number">1</span>).Minute().Tag(<span class="string">&quot;tag&quot;</span>).Do(task)</span><br><span class="line">s.RunByTag(<span class="string">&quot;tag&quot;</span>)</span><br><span class="line"><span class="comment">// both jobs will run</span></span><br></pre></td></tr></table></figure>

<p><strong>Example</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s := gocron.NewScheduler(time.UTC)</span><br><span class="line"></span><br><span class="line">s.Every(<span class="number">5</span>).Seconds().Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// strings parse to duration</span></span><br><span class="line">s.Every(<span class="string">&quot;5m&quot;</span>).Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">s.Every(<span class="number">5</span>).Days().Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">task = <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// cron expressions supported</span></span><br><span class="line">s.Cron(<span class="string">&quot;*/1 * * * *&quot;</span>).Do(task) <span class="comment">// every minute</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you can start running the scheduler in two different ways:</span></span><br><span class="line"><span class="comment">// starts the scheduler asynchronously</span></span><br><span class="line">s.StartAsync()</span><br><span class="line"><span class="comment">//OR</span></span><br><span class="line"><span class="comment">//starts the scheduler and blocks current execution path </span></span><br><span class="line">s.StartBlocking()</span><br></pre></td></tr></table></figure>

<p>More examples, refer to <a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/go-co-op/gocron#pkg-examples">cron example</a></p>
<p><strong>Note:</strong><br>Q: I’ve removed my job from the scheduler, but how can I stop a long-running job that has already been triggered?<br>A: We recommend using a means of canceling your job, e.g. a context.WithCancel().</p>
<h2 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP Server"></a>HTTP Server</h2><h3 id="Restful-API-server"><a href="#Restful-API-server" class="headerlink" title="Restful API server"></a>Restful API server</h3><p>Here we only list pure restful api server package, which is small, fast.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/bmizerany/pat">pat</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/gorilla/mux">gorilla&#x2F;mux</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/julienschmidt/httprouter">httrouter</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/go-chi/chi">go-chi&#x2F;chi</a></li>
</ul>
<p>Let’s focus on mux which is powerful and used in many production</p>
<h4 id="gorilla-x2F-mux"><a href="#gorilla-x2F-mux" class="headerlink" title="gorilla&#x2F;mux"></a>gorilla&#x2F;mux</h4><p><strong>Paths can have variables. They are defined using the format {name} or {name:pattern}. If a regular expression pattern is not defined, the matched variable will be anything until the next slash.</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r := mux.NewRouter()</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/products/&#123;key&#125;&quot;</span>, ProductHandler)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/articles/&#123;category&#125;/&quot;</span>, ArticlesCategoryHandler)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;&quot;</span>, ArticleHandler)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArticlesCategoryHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    vars := mux.Vars(r)</span><br><span class="line">    w.WriteHeader(http.StatusOK)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Category: %v\n&quot;</span>, vars[<span class="string">&quot;category&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p><strong>Routes can also be restricted</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r := mux.NewRouter()</span><br><span class="line"></span><br><span class="line"><span class="comment">// restrict a particular route</span></span><br><span class="line">r.HandleFunc(<span class="string">&quot;/products&quot;</span>, ProductsHandler).Host(<span class="string">&quot;www.example.com&quot;</span>).Methods(<span class="string">&quot;GET&quot;</span>).Schemes(<span class="string">&quot;http&quot;</span>)</span><br></pre></td></tr></table></figure>
<hr style="border:1px solid gray"> </hr>

<p><strong>Group several routes that share the same requirements</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r := mux.NewRouter()</span><br><span class="line">s := r.PathPrefix(<span class="string">&quot;/products&quot;</span>).Subrouter()</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;/products/&quot;</span></span><br><span class="line">s.HandleFunc(<span class="string">&quot;/&quot;</span>, ProductsHandler)</span><br><span class="line"><span class="comment">// &quot;/products/&#123;key&#125;/&quot;</span></span><br><span class="line">s.HandleFunc(<span class="string">&quot;/&#123;key&#125;/&quot;</span>, ProductHandler)</span><br><span class="line"><span class="comment">// &quot;/products/&#123;key&#125;/details&quot;</span></span><br><span class="line">s.HandleFunc(<span class="string">&quot;/&#123;key&#125;/details&quot;</span>, ProductDetailsHandler)</span><br></pre></td></tr></table></figure>
<hr style="border:1px solid gray"> </hr>

<p><strong>Graceful shutdown</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wait time.Duration</span><br><span class="line">    flag.DurationVar(&amp;wait, <span class="string">&quot;graceful-timeout&quot;</span>, time.Second*<span class="number">15</span>, <span class="string">&quot;the duration for which the server gracefully wait for existing connections to finish - e.g. 15s or 1m&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    r := mux.NewRouter()</span><br><span class="line">    <span class="comment">// Add your routes as needed</span></span><br><span class="line"></span><br><span class="line">    srv := &amp;http.Server&#123;</span><br><span class="line">        Addr: <span class="string">&quot;0.0.0.0:8000&quot;</span>,</span><br><span class="line">        <span class="comment">// Good practice to set timeouts to avoid Slowloris attacks.</span></span><br><span class="line">        WriteTimeout: time.Second * <span class="number">15</span>,</span><br><span class="line">        ReadTimeout:  time.Second * <span class="number">15</span>,</span><br><span class="line">        IdleTimeout:  time.Second * <span class="number">60</span>,</span><br><span class="line">        Handler:      r, <span class="comment">// Pass our instance of gorilla/mux in.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run our server in a goroutine so that it doesn&#x27;t block.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// We&#x27;ll accept graceful shutdowns when quit via SIGINT (Ctrl+C)</span></span><br><span class="line">    <span class="comment">// SIGKILL, SIGQUIT or SIGTERM (Ctrl+/) will not be caught.</span></span><br><span class="line">    signal.Notify(c, os.Interrupt)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block until we receive our signal.</span></span><br><span class="line">    &lt;-c</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a deadline to wait for.</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), wait)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="comment">// Doesn&#x27;t block if no connections, but will otherwise wait</span></span><br><span class="line">    <span class="comment">// until the timeout deadline.</span></span><br><span class="line">    srv.Shutdown(ctx)</span><br><span class="line">    <span class="comment">// Optionally, you could run srv.Shutdown in a goroutine and block on</span></span><br><span class="line">    <span class="comment">// &lt;-ctx.Done() if your application should wait for other services</span></span><br><span class="line">    <span class="comment">// to finalize based on context cancellation.</span></span><br><span class="line">    log.Println(<span class="string">&quot;shutting down&quot;</span>)</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>show all routes call walk of the router</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">r.Walk(<span class="function"><span class="keyword">func</span><span class="params">(route *mux.Route, router *mux.Router, ancestors []*mux.Route)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">     pathTemplate, err := route.GetPathTemplate()</span><br><span class="line">     <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;ROUTE:&quot;</span>, pathTemplate)</span><br><span class="line">     &#125;</span><br><span class="line">     queriesTemplates, err := route.GetQueriesTemplates()</span><br><span class="line">     <span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(queriesTemplates) != <span class="number">0</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;Queries templates:&quot;</span>, strings.Join(queriesTemplates, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">     &#125;</span><br><span class="line">     methods, err := route.GetMethods()</span><br><span class="line">     <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;Methods:&quot;</span>, strings.Join(methods, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;Methods: Any&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println()</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>NOTE</strong></p>
<ul>
<li>Routes are tested in the order they were added to the router. If two routes match, the first one wins</li>
<li>each handler must declare like this <code>func HandlerXXX(w http.ResponseWriter, r *http.Request) &#123;&#125;</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">YourHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// no content-type, default text/plain</span></span><br><span class="line">    w.WriteHeader(http.StatusOK)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Gorialla\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  w.Header().Set(&quot;Content-type&quot;, &quot;application/json&quot;)</span></span><br><span class="line">    <span class="comment">//  p := struct &#123;</span></span><br><span class="line">    <span class="comment">//     Name string</span></span><br><span class="line">    <span class="comment">//  &#125;&#123;</span></span><br><span class="line">    <span class="comment">//      Name: &quot;gorilla&quot;,</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line">    <span class="comment">//  w.WriteHeader(http.StatusOK)</span></span><br><span class="line">    <span class="comment">//  json.NewEncoder(w).Encode(&amp;p)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := mux.NewRouter()</span><br><span class="line">    <span class="comment">// Routes consist of a path and a handler function.</span></span><br><span class="line">    r.HandleFunc(<span class="string">&quot;/&quot;</span>, YourHandler)</span><br><span class="line">    </span><br><span class="line">    srv := &amp;http.Server&#123;</span><br><span class="line">        Addr: <span class="string">&quot;0.0.0.0:8000&quot;</span>,</span><br><span class="line">        <span class="comment">// Good practice to set timeouts to avoid Slowloris attacks.</span></span><br><span class="line">        WriteTimeout: time.Second * <span class="number">15</span>,</span><br><span class="line">        ReadTimeout:  time.Second * <span class="number">15</span>,</span><br><span class="line">        IdleTimeout:  time.Second * <span class="number">60</span>,</span><br><span class="line">        Handler:      r, <span class="comment">// Pass our instance of gorilla/mux in.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="yaml-vs-json-vs-toml"><a href="#yaml-vs-json-vs-toml" class="headerlink" title="yaml vs json vs toml"></a>yaml vs json vs toml</h2><p>TOML shares traits with other file formats used for application configuration and data serialization, such as YAML and JSON. <code>TOML and JSON both are simple and use ubiquitous data types</code>, making them easy to code for or parse with machines. <code>TOML and YAML both emphasize human readability features</code>, like comments that make it easier to understand the purpose of a given line. <code>TOML differs in combining these, allowing comments (unlike JSON) but preserving simplicity (unlike YAML)</code>.</p>
<p><strong>spec</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/YAML">yaml wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/yaml/yaml-spec">yaml spec</a></li>
<li><a href="https://cyun.tech/encode-yaml/">yaml example</a></li>
<li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc8259">json spec</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toml-lang/toml">toml spec</a></li>
</ul>
<p><strong>Golang support</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/go-yaml/yaml">Yaml</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/BurntSushi/toml/">BurntSushi&#x2F;toml</a><blockquote>
<p>This Go package provides a reflection interface similar to Go’s standard library json and xml packages. This package also supports the encoding.TextUnmarshaler and encoding.TextMarshaler interfaces so that you can define custom data representations, it supports tag as well like json   <strong>type b struct{Port string <code>toml:&quot;port,omitempty&quot;&#125;</code></strong></p>
</blockquote>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/spf13/viper">Viper</a><ul>
<li>Find, load, and unmarshal a configuration file in <strong>JSON, TOML, YAML, HCL, INI, envfile or Java properties formats</strong>.</li>
<li>Provide a mechanism to set default values for your different configuration options.</li>
<li>Provide a mechanism to set override values for options specified through command line flags.</li>
<li>Provide an alias system to easily rename parameters without breaking existing code.</li>
<li>Make it easy to tell the difference between when a user has provided a command line or config file which is the same as the default.</li>
</ul>
</li>
</ul>
<h3 id="toml-decode"><a href="#toml-decode" class="headerlink" title="toml decode"></a>toml decode</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config tomlConfig</span><br><span class="line"><span class="comment">// one line of code to parse toml file!!!</span></span><br><span class="line"><span class="keyword">if</span> _, err := toml.DecodeFile(<span class="string">&quot;example.toml&quot;</span>, &amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a TOML document. Boom.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">title</span> = <span class="string">&quot;TOML Example&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[owner]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;Tom Preston-Werner&quot;</span></span><br><span class="line"><span class="attr">organization</span> = <span class="string">&quot;GitHub&quot;</span></span><br><span class="line"><span class="attr">bio</span> = <span class="string">&quot;GitHub Cofounder &amp; CEO\nLikes tater tots and beer.&quot;</span></span><br><span class="line"><span class="attr">dob</span> = <span class="number">1979</span>-<span class="number">05</span>-<span class="number">27</span>T07:<span class="number">32</span>:<span class="number">00</span>Z <span class="comment"># First class dates? Why not?</span></span><br><span class="line"></span><br><span class="line"><span class="section">[database]</span></span><br><span class="line"><span class="attr">server</span> = <span class="string">&quot;192.168.1.1&quot;</span></span><br><span class="line"><span class="attr">ports</span> = [ <span class="number">8001</span>, <span class="number">8001</span>, <span class="number">8002</span> ]</span><br><span class="line"><span class="attr">connection_max</span> = <span class="number">5000</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[servers]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># You can indent as you please. Tabs or spaces. TOML don&#x27;t care.</span></span><br><span class="line">  <span class="section">[servers.alpha]</span></span><br><span class="line">  <span class="attr">ip</span> = <span class="string">&quot;10.0.0.1&quot;</span></span><br><span class="line">  <span class="attr">dc</span> = <span class="string">&quot;eqdc10&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[servers.beta]</span></span><br><span class="line">  <span class="attr">ip</span> = <span class="string">&quot;10.0.0.2&quot;</span></span><br><span class="line">  <span class="attr">dc</span> = <span class="string">&quot;eqdc10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[clients]</span></span><br><span class="line"><span class="attr">data</span> = [ [<span class="string">&quot;gamma&quot;</span>, <span class="string">&quot;delta&quot;</span>], [<span class="number">1</span>, <span class="number">2</span>] ] <span class="comment"># just an update to make sure parsers support it</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Line breaks are OK when inside arrays</span></span><br><span class="line"><span class="attr">hosts</span> = [</span><br><span class="line">  <span class="string">&quot;alpha&quot;</span>,</span><br><span class="line">  <span class="string">&quot;omega&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/BurntSushi/toml&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tomlConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title   <span class="type">string</span></span><br><span class="line">    Owner   ownerInfo</span><br><span class="line">    DB      database <span class="string">`toml:&quot;database&quot;`</span> <span class="comment">// key in toml</span></span><br><span class="line">    Servers <span class="keyword">map</span>[<span class="type">string</span>]server</span><br><span class="line">    Clients clients</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ownerInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Org  <span class="type">string</span> <span class="string">`toml:&quot;organization&quot;`</span></span><br><span class="line">    Bio  <span class="type">string</span></span><br><span class="line">    DOB  time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">struct</span> &#123;</span><br><span class="line">    Server  <span class="type">string</span></span><br><span class="line">    Ports   []<span class="type">int</span></span><br><span class="line">    ConnMax <span class="type">int</span> <span class="string">`toml:&quot;connection_max&quot;`</span></span><br><span class="line">    Enabled <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">    IP <span class="type">string</span></span><br><span class="line">    DC <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> clients <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data  [][]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    Hosts []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> config tomlConfig</span><br><span class="line">    <span class="keyword">if</span> _, err := toml.DecodeFile(<span class="string">&quot;example.toml&quot;</span>, &amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Title: %s\n&quot;</span>, config.Title)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Owner: %s (%s, %s), Born: %s\n&quot;</span>,</span><br><span class="line">        config.Owner.Name, config.Owner.Org, config.Owner.Bio,</span><br><span class="line">        config.Owner.DOB)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Database: %s %v (Max conn. %d), Enabled? %v\n&quot;</span>,</span><br><span class="line">        config.DB.Server, config.DB.Ports, config.DB.ConnMax,</span><br><span class="line">        config.DB.Enabled)</span><br><span class="line">    <span class="keyword">for</span> serverName, server := <span class="keyword">range</span> config.Servers &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Server: %s (%s, %s)\n&quot;</span>, serverName, server.IP, server.DC)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Client data: %v\n&quot;</span>, config.Clients.Data)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Client hosts: %v\n&quot;</span>, config.Clients.Hosts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/BurntSushi/toml&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">        Age <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> outputs Config</span><br><span class="line">    outputs.Age = <span class="number">10</span> <span class="comment">// default value if user not set</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _, err := toml.Decode(<span class="string">&quot;&quot;</span>, &amp;outputs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;decode from encoded buffer(toml to struct): %+v\n&quot;</span>, outputs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>decode from encoded buffer(toml to struct): &#123;Age:10&#125;
</code></pre>
<h3 id="toml-encode"><a href="#toml-encode" class="headerlink" title="toml encode"></a>toml encode</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dst can be bytes.Buffer or File who implements io.Writer</span></span><br><span class="line">e := toml.NewEncoder(dst)</span><br><span class="line"><span class="comment">// inputs are struct which will be encode as toml as output to dst</span></span><br><span class="line">err := e.Encode(inputs)</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/BurntSushi/toml&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">        Age        <span class="type">int</span></span><br><span class="line">        Cats       []<span class="type">string</span></span><br><span class="line">        Pi         <span class="type">float64</span></span><br><span class="line">        Perfection []<span class="type">int</span></span><br><span class="line">        DOB        time.Time</span><br><span class="line">        Ipaddress  net.IP</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inputs = Config&#123;</span><br><span class="line">        <span class="number">13</span>,</span><br><span class="line">        []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;,</span><br><span class="line">        <span class="number">3.145</span>,</span><br><span class="line">        []<span class="type">int</span>&#123;<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        time.Now(),</span><br><span class="line">        net.ParseIP(<span class="string">&quot;192.168.59.254&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// log to console!!!</span></span><br><span class="line">    log.SetOutput(os.Stdout)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> firstBuffer bytes.Buffer</span><br><span class="line">    <span class="comment">// Encoder can be file or bytes.Buffer who implements io.Writer</span></span><br><span class="line">    e := toml.NewEncoder(&amp;firstBuffer)</span><br><span class="line">    err := e.Encode(inputs)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// encode inputs to firstBuffer</span></span><br><span class="line">        log.Println(<span class="string">&quot;encoded first buffer toml format:&quot;</span>, firstBuffer.String())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> outputs Config</span><br><span class="line">    <span class="comment">// decode from firstBuffer to outputs</span></span><br><span class="line">    <span class="keyword">if</span> _, err := toml.Decode(firstBuffer.String(), &amp;outputs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Could not decode:\n-----\n%s\n-----\n&quot;</span>,</span><br><span class="line">            firstBuffer.String())</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;decode from encoded buffer(toml to struct): %+v&quot;</span>, outputs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// could test each value individually, but I&#x27;m lazy</span></span><br><span class="line">    <span class="keyword">var</span> secondBuffer bytes.Buffer</span><br><span class="line">    e2 := toml.NewEncoder(&amp;secondBuffer)</span><br><span class="line">    <span class="comment">// encode outputs to secondBuffer</span></span><br><span class="line">    err = e2.Encode(outputs)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;encoded second buffer toml format:&quot;</span>, firstBuffer.String())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> firstBuffer.String() != secondBuffer.String() &#123;</span><br><span class="line">        log.Printf(</span><br><span class="line">            firstBuffer.String(),</span><br><span class="line">            <span class="string">&quot;\n\n is not identical to\n\n&quot;</span>,</span><br><span class="line">            secondBuffer.String())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>2022/07/01 17:23:30 encoded first buffer toml format: Age = 13
Cats = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
Pi = 3.145
Perfection = [11, 2, 3, 4]
DOB = 2022-07-01T17:23:30.172328016+08:00
Ipaddress = &quot;192.168.59.254&quot;

2022/07/01 17:23:30 decode from encoded buffer(toml to struct): &#123;Age:13 Cats:[one two three] Pi:3.145 Perfection:[11 2 3 4] DOB:2022-07-01 17:23:30.172328016 +0800 CST Ipaddress:192.168.59.254&#125;
2022/07/01 17:23:30 encoded second buffer toml format: Age = 13
Cats = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
Pi = 3.145
Perfection = [11, 2, 3, 4]
DOB = 2022-07-01T17:23:30.172328016+08:00
Ipaddress = &quot;192.168.59.254&quot;
</code></pre>
<h2 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h2><p><code>Only support 64 bits [0, 63].</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;k8s.io/kubernetes/pkg/kubelet/cm/topologymanager/bitmask&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bm1 := bitmask.NewEmptyBitMask()</span><br><span class="line">    bm1.Add(<span class="number">0</span>)</span><br><span class="line">    bm1.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bm1.IsEmpty() &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;bm1 is empty&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;bm1(0 as the first bit):&quot;</span>, bm1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bm2 := bitmask.NewEmptyBitMask()</span><br><span class="line">    bm2.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bm1.IsEqual(bm2) &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;bm1 and bm2 are equal&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;bm1 and bm2 are not equal&quot;</span>)</span><br><span class="line">        fmt.Println(<span class="string">&quot;bm1:&quot;</span>, bm1)</span><br><span class="line">        fmt.Println(<span class="string">&quot;bm2:&quot;</span>, bm2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bm1.Or(bm2)</span><br><span class="line">    fmt.Println(<span class="string">&quot;bm1=bm1|bm2:&quot;</span>, bm1)</span><br><span class="line"></span><br><span class="line">    bm1.Remove(<span class="number">3</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;bm1.Remove(3):&quot;</span>, bm1)</span><br><span class="line">    fmt.Println(<span class="string">&quot;bm1.GetBits:&quot;</span>, bm1.GetBits())</span><br><span class="line">    <span class="comment">// IterateBitMasks iterates all possible masks from a list of bits, issuing a callback on each mask.</span></span><br><span class="line">    <span class="string">&quot;    // [0, 1, 2], 瀵规瘡涓彲鑳界殑缁勫悎锛?璋冪敤func!!!\</span></span><br><span class="line"><span class="string">    &quot;</span>    <span class="comment">// 1, 10, 100   璁剧疆涓€浣?    &quot;    // 11, 101, 110 璁剧疆涓や綅</span></span><br><span class="line">    <span class="string">&quot;    // 111          璁剧疆涓変綅</span></span><br><span class="line"><span class="string">    bitmask.IterateBitMasks(bm1.GetBits(), func(mask bitmask.BitMask) &#123;</span></span><br><span class="line"><span class="string">        fmt.Println(mask)</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bm1(0 as the first bit): 0111</span><br><span class="line">bm1 and bm2 are not equal</span><br><span class="line">bm1: 0111</span><br><span class="line">bm2: 1000</span><br><span class="line">bm1=bm1|bm2: 1111</span><br><span class="line">bm1.Remove(3): 0111</span><br><span class="line">bm1.GetBits: [0 1 2]</span><br><span class="line">01</span><br><span class="line">10</span><br><span class="line">100</span><br><span class="line">11</span><br><span class="line">0101</span><br><span class="line">0110</span><br><span class="line">0111</span><br></pre></td></tr></table></figure>

<h2 id="encoding-protobuffer"><a href="#encoding-protobuffer" class="headerlink" title="encoding(protobuffer)"></a>encoding(protobuffer)</h2><p>A very simple “address book” application that can read and write people’s contact details to and from a file. Each person in the address book has a name, an ID, an email address, and a contact phone number.</p>
<p>How do you <code>serialize and retrieve structured data</code> like this? There are a few ways to solve this problem:</p>
<ul>
<li>Use <code>gobs to serialize Go data structures</code>. This is a good solution in a Go-specific environment, but it doesn’t work well if you need to share data with applications written for other platforms.</li>
<li>You can <code>invent an ad-hoc way to encode the data items into a single string</code> such as encoding 4 ints as “12:3:-23:67”. This is a simple and flexible approach, although it does require writing one-off encoding and parsing code, and the parsing imposes a small run-time cost. This works best for encoding very simple data.</li>
<li><code>Serialize the data to XML(or json)</code>. This approach can be very attractive since XML is (sort of) human readable and there are binding libraries for lots of languages. This can be a good choice if you want to share data with other applications&#x2F;projects. However, XML is notoriously space intensive, and encoding&#x2F;decoding it can impose a huge performance penalty on applications. Also, navigating an XML DOM tree is considerably more complicated than navigating simple fields in a class normally would be.</li>
</ul>
<p><code>Protocol buffers are the flexible, efficient, automated solution to solve exactly this problem</code>. With protocol buffers, you write a .proto description of the data structure you wish to store. From that, the protocol buffer compiler creates a class that implements automatic encoding and parsing of the protocol buffer data with an efficient binary format. The generated class provides getters and setters for the fields that make up a protocol buffer and takes care of the details of reading and writing the protocol buffer as a unit. Importantly, the protocol buffer format supports the idea of extending the format over time in such a way that the code can still read data encoded with the old format.</p>
<p><strong><font color='red'>Rules for compatibility</font></strong><br>Sooner or later after you release the code that uses your protocol buffer, you will undoubtedly want to “improve” the protocol buffer’s definition. If you want your <code>new buffers to be backwards-compatible, and your old buffers to be forward-compatible</code> and you almost certainly do want this then there are some rules you need to follow. In the new version of the protocol buffer:</p>
<ul>
<li>you <strong>must not change the tag numbers of any existing fields</strong>.</li>
<li>you may delete fields.</li>
<li>you may add new fields but you must use fresh tag numbers (i.e. tag numbers that were never used in this protocol buffer, not even by deleted fields).</li>
</ul>
<p>If you follow these rules, <code>old code will happily read new messages and simply ignore any new fields</code>. To the old code, singular fields that were deleted will simply have their default value, and deleted repeated fields will be empty. <code>New code will also transparently read old messages</code>.</p>
<p>However, keep in mind that <code>new fields will not be present in old messages</code>, so you will need to do something reasonable with the default value. A type-specific default value is used: for strings, the default value is the empty string. For booleans, the default value is false. For numeric types, the default value is zero.</p>
<h3 id="style"><a href="#style" class="headerlink" title="style"></a>style</h3><p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/style">style guide</a> gives suggestion how to write xx.proto file when define message and rpc, here is a summary from that.</p>
<p><strong>All files should be ordered in the following manner:</strong></p>
<ul>
<li>License header (if applicable)</li>
<li>File overview</li>
<li>Syntax(proto2 or proto3)</li>
<li>Package(used by proto to import message defined in other package)</li>
<li>Imports (sorted)(imports other protos)</li>
<li>File options(like option go_package &#x3D; “github.com&#x2F;xvrzhao&#x2F;pb-demo&#x2F;proto&#x2F;article”;)</li>
<li>Everything else<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line">package hello;</span><br><span class="line">import &quot;store/name.proto&quot;</span><br><span class="line">option go_package = &quot;github.com/jason/hello&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Message and field names</strong><br>Use CamelCase (with an initial capital) for message names for example, SongServerRequest. Use underscore_separated_names for field names (including oneof field and extension names) for example, song_name</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message SongServerRequest &#123;</span><br><span class="line">  optional string song_name = 1; // for go, generated code is SongName!!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Repeated fields</strong><br>Use pluralized names for repeated fields.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeated string keys = 1;</span><br></pre></td></tr></table></figure>

<p><strong>Enums</strong><br>Use CamelCase (with an initial capital) for enum type names and CAPITALS_WITH_UNDERSCORES for value names:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum FooBar &#123;</span><br><span class="line">  FOO_BAR_UNSPECIFIED = 0;</span><br><span class="line">  FOO_BAR_FIRST_VALUE = 1;</span><br><span class="line">  FOO_BAR_SECOND_VALUE = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Services</strong><br>Use CamelCase (with an initial capital) for both the service name and any RPC method names:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service FooService &#123;</span><br><span class="line">  rpc GetSomething(GetSomethingRequest) returns (GetSomethingResponse);</span><br><span class="line">  rpc ListSomething(ListSomethingRequest) returns (ListSomethingResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="proto3"><a href="#proto3" class="headerlink" title="proto3"></a>proto3</h3><p><strong>Default values:</strong></p>
<ul>
<li>For strings, the default value is the empty string.</li>
<li>For bytes, the default value is empty bytes.</li>
<li>For bools, the default value is false.</li>
<li>For numeric types, the default value is zero.</li>
<li>For enums, the default value is the first defined enum value, which must be 0.</li>
<li>For message fields, the field is not set. Its exact value is language-dependent. See the generated code guide for details.</li>
</ul>
<p><strong>go references</strong>  </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/gotutorial">proto3 go tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">proto3 go reference</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/google.golang.org/protobuf/proto">go API</a></li>
</ul>
<h4 id="build-proto3-of-go"><a href="#build-proto3-of-go" class="headerlink" title="build proto3 of go"></a>build proto3 of go</h4><p>In order to generate go code, you must have protoc and go plugins installed, here are steps to install them all.</p>
<p><strong>Prerequisite</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O ./protoc-3.15.8-linux-x86_64.zip https://github.com/protocolbuffers/protobuf/releases/download/v3.15.8/protoc-3.15.8-linux-x86_64.zip</span><br><span class="line">$ unzip protoc-3.15.8-linux-x86_64.zip -d /usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install the protocol compiler plugins for Go using the following commands</span></span><br><span class="line"><span class="comment"># protoc-gen-go: go plugin or gogo/protobuf</span></span><br><span class="line"><span class="comment"># proto-gen-go-grpc: go rpc plugin as protoc-gen-go does not provide it, hence needs this plugin</span></span><br><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1 <span class="comment"># this is not needed if no service!!!</span></span><br></pre></td></tr></table></figure>

<p><strong>gogo&#x2F;protobuf</strong><br>gogo&#x2F;protobuf is a fork of golang&#x2F;protobuf with extra code generation features, it provides several plugins for go code generate, <code>pick the right one for use</code></p>
<ul>
<li>protoc-gen-gofast(speed than protoc-gen-go)</li>
<li>protoc-gen-gogofast (same as gofast, but imports gogoprotobuf)</li>
<li>protoc-gen-gogofaster (same as gogofast, without XXX_unrecognized, less pointer fields)</li>
<li>protoc-gen-gogoslick (same as gogofaster, but with generated string, gostring and equal methods)</li>
<li>protoc-gen-gogo (Most Speed and most customization)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># basic way</span></span><br><span class="line">$ go get github.com/gogo/protobuf/protoc-gen-gofast</span><br><span class="line"></span><br><span class="line"><span class="comment"># others install protoc-gen-gogofast, protoc-gen-gogofaster, protoc-gen-gogoslick, protoc-gen-gogo</span></span><br><span class="line">$ go get github.com/gogo/protobuf/proto</span><br><span class="line">$ go get github.com/gogo/protobuf/jsonpb</span><br><span class="line">$ go get github.com/gogo/protobuf/&#123;binary&#125;</span><br><span class="line">$ go get github.com/gogo/protobuf/gogoproto</span><br><span class="line"></span><br><span class="line"><span class="comment"># just use one of them is enough!!!</span></span><br><span class="line">$ protoc --gofast_out=. --gofast_opt=paths=source_relative myproto.proto</span><br><span class="line">$ protoc --gogofast_out=. --gogofast_opt=paths=source_relative myproto.proto</span><br><span class="line">$ protoc --gogofaster_out=. --gogofaster_opt=paths=source_relative myproto.proto</span><br><span class="line">$ protoc --gogoslick_out=. --gogoslick_opt=paths=source_relative myproto.proto</span><br><span class="line"></span><br><span class="line"><span class="comment"># the best one to use!!!</span></span><br><span class="line">$ protoc --gogo_out=. --gogo_opt=paths=source_relative myproto.proto</span><br></pre></td></tr></table></figure>

<p>In order to generate Go code, the <strong>Go package’s import path must be provided for every .proto file</strong>). There are two ways to specify the Go import path:</p>
<ul>
<li><p>by declaring it within the .proto file<br>  <font color='green'>option go_package &#x3D; “example.com&#x2F;project&#x2F;protos&#x2F;fizz”;’</font></p>
</li>
<li><p>by declaring it on the command line when invoking protoc, by passing one or more <code>M$&#123;PROTO_FILE&#125;=$&#123;GO_IMPORT_PATH&#125;</code><br>  <font color='green'>$protoc –go_opt&#x3D;Mprotos&#x2F;buzz.proto&#x3D;example.com&#x2F;project&#x2F;protos&#x2F;fizz protos&#x2F;buzz.proto&#96;</font></p>
</li>
</ul>
<p><strong>compile proto</strong><br><strong>use cases for code generation of Go</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --go_out=. generate go code under this directory</span></span><br><span class="line"><span class="comment"># --go_opt=paths=source_relative generate go code same layout as its proto path under --go_out</span></span><br><span class="line"><span class="comment"># --go_opt=paths=import generate go code with go_package under --go_out</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/data/hello</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">cool/ protocols/</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate code in the same directory as its proto</span></span><br><span class="line">$ protoc --go_out=. --go_opt=paths=source_relative protocols/greet.proto</span><br><span class="line">$ protoc --go_out=. --go_opt=paths=source_relative protocols/*.proto</span><br><span class="line">$ <span class="built_in">ls</span> protocols/</span><br><span class="line">greet.pb.go  greet.proto</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate code with same layout as its proto but in different go_out</span></span><br><span class="line">$ protoc --go_out=cool --go_opt=paths=source_relative protocols/greet.proto</span><br><span class="line">$ <span class="built_in">ls</span> cool/protocols/ protocols/</span><br><span class="line">cool/protocols/:</span><br><span class="line">greet.pb.go</span><br><span class="line"></span><br><span class="line">protocols/:</span><br><span class="line">greet.proto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate code with package layout defined in proto in different go_out</span></span><br><span class="line">$ protoc --go_out=cool --go_opt=paths=import protocols/greet.proto</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">|-- cool</span><br><span class="line">|   `-- github.com</span><br><span class="line">|       `-- hello</span><br><span class="line">|           `-- runtime</span><br><span class="line">|               `-- protocols</span><br><span class="line">|                   `-- greet</span><br><span class="line">|                       `-- greet.pb.go</span><br><span class="line">`-- protocols</span><br><span class="line">    `-- greet.proto</span><br><span class="line"></span><br><span class="line">$ protoc --go_out=<span class="variable">$GOPATH</span>/src --go_opt=paths=import protocols/greet.proto</span><br><span class="line"></span><br><span class="line"><span class="comment"># as service will create a separate pb file that&#x27;s different with message</span></span><br><span class="line"><span class="comment"># use these option for rpc generation: --go-grpc_out=. --go-grpc_opt=paths=source_relative</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if proto imports other protos, add searching path: -I=other/proto/:.</span></span><br></pre></td></tr></table></figure>

<p><font color='red'>Most used one: put your source at $GOPATH&#x2F;src&#x2F;github.com </font><br><code>$ protoc --go_out=$GOPATH/src/ --go_opt=paths=import --go-grpc_out=$GOPATH/src/ --go-grpc_opt=paths=import protocols/greet.proto</code><br><code>$ protoc --gogo_out=. --gogo_opt=paths=source_relative --go-grpc_out=$GOPATH/src/ --go-grpc_opt=paths=import protocols/greet.proto</code></p>
<p><font color='red'>Most used one for testing</font><br><code>$ protoc --go_out=. --go_opt=paths=source_relative protocols/greet.proto</code><br><code>$ protoc --gogo_out=. --gogo_opt=paths=source_relative protocols/greet.proto</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@localhost hello]<span class="comment"># pwd</span></span><br><span class="line">/home/go/src/github.com/hello</span><br><span class="line">(base) [root@localhost hello]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">|-- protocols</span><br><span class="line">|   `-- greet.proto</span><br><span class="line">`-- runtime</span><br><span class="line">    `-- protocols</span><br><span class="line">        `-- greet</span><br><span class="line">            `-- greet.pb.go</span><br></pre></td></tr></table></figure>



<h4 id="generated-go-code"><a href="#generated-go-code" class="headerlink" title="generated go code"></a>generated go code</h4><p>greet.proto</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">package greet;</span><br><span class="line">//used by proto itself(independent with different language)</span><br><span class="line">// to prevent naming conflicts between different projects(protos).</span><br><span class="line">// import &quot;google/protobuf/timestamp.proto&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">option go_package = &quot;github.com/hello/runtime/protocols/greet&quot;;</span><br><span class="line">// used by protoc when generate go specific code</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  int32 id = 2;  // Unique ID number for this person.</span><br><span class="line">  string email = 3;</span><br><span class="line"></span><br><span class="line">  enum PhoneType &#123;</span><br><span class="line">    MOBILE = 0;</span><br><span class="line">    HOME = 1;</span><br><span class="line">    WORK = 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    string number = 1;</span><br><span class="line">    PhoneType type = 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones = 4;</span><br><span class="line"></span><br><span class="line">  google.protobuf.Timestamp last_updated = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Our address book file is just one of these.</span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For nested message, generated go code with its parent as prefix like <code>type Person_PhoneNumber struct</code></p>
<p><code>If a field value isn&#39;t set, a default value is used: zero for numeric types, the empty string for strings, false for bools</code>. For embedded messages, the default value is always the “default instance” or “prototype” of the message, which has none of its fields set. Calling the accessor to get the value of a field which has not been explicitly set always returns that field’s default value.</p>
<p><code>If a field is repeated, the field may be repeated any number of times (including zero</code>). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays. </p>
<p>There is <code>no correlation between the Go import path and the package specifier in the .proto file</code>. The latter is only relevant to the protobuf namespace, while the former is only relevant to the Go namespace. Also, there is <code>no correlation between the Go import path and the .proto import path</code>. </p>
<p>The generated Go field names <code>always use camel-case naming</code>, even if the field name in the .proto file uses lower-case with underscores (as it should). Thus, the proto field foo_bar_baz becomes FooBarBaz in Go.</p>
<p><strong>types mapping</strong>  </p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>Go Type</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td></td>
<td>float64</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float32</td>
</tr>
<tr>
<td>int32</td>
<td>Uses variable-length encoding. Inefficient for encoding negative numbers if your field is likely to have negative values, use sint32 instead.</td>
<td>int32</td>
</tr>
<tr>
<td>int64</td>
<td>Uses variable-length encoding. Inefficient for encoding negative numbers if your field is likely to have negative values, use sint64 instead.</td>
<td>int64</td>
</tr>
<tr>
<td>uint32</td>
<td>Uses variable-length encoding.</td>
<td>uint32</td>
</tr>
<tr>
<td>uint64</td>
<td>Uses variable-length encoding.</td>
<td>uint64</td>
</tr>
<tr>
<td>sint32</td>
<td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td>
<td>int32</td>
</tr>
<tr>
<td>sint64</td>
<td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td>
<td>int64</td>
</tr>
<tr>
<td>fixed32</td>
<td>Always four bytes. More efficient than uint32 if values are often greater than 2^28.</td>
<td>uint32</td>
</tr>
<tr>
<td>fixed64</td>
<td>Always eight bytes. More efficient than uint64 if values are often greater than 2^56.</td>
<td>uint64</td>
</tr>
<tr>
<td>sfixed32</td>
<td>Always four bytes.</td>
<td>int32</td>
</tr>
<tr>
<td>sfixed64</td>
<td>Always eight bytes.</td>
<td>int64</td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
</tr>
<tr>
<td>string</td>
<td>A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 2^32.</td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>May contain any arbitrary sequence of bytes no longer than 2^32.</td>
<td>[]byte</td>
</tr>
</tbody></table>
<p><strong>singular message field</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Baz &#123;</span><br><span class="line">  Bar foo = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x3D;&gt;&gt;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">        Foo *Bar <span class="comment">// it&#x27;s pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Repeated Fields</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Baz &#123;</span><br><span class="line">  repeated Bar foo = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x3D;&gt;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">        Foo  []*Bar</span><br><span class="line">&#125;</span><br><span class="line">baz := &amp;Baz&#123;</span><br><span class="line">  Foo: []*Bar&#123;</span><br><span class="line">    &#123;&#125;, <span class="comment">// First element. not &amp;?</span></span><br><span class="line">    &#123;&#125;, <span class="comment">// Second element.</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo := baz.GetFoo() <span class="comment">// foo type is []*Bar.</span></span><br><span class="line">b1 := foo[<span class="number">0</span>] <span class="comment">// b1 type is *Bar, the first element in foo.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Map Fields</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Bar &#123;&#125;</span><br><span class="line"></span><br><span class="line">message Baz &#123;</span><br><span class="line">  map&lt;string, Bar&gt; foo = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x3D;&gt;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">        Foo <span class="keyword">map</span>[<span class="type">string</span>]*Bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Enum</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  enum Corpus &#123;</span><br><span class="line">    UNIVERSAL = 0;</span><br><span class="line">    WEB = 1;</span><br><span class="line">    IMAGES = 2;</span><br><span class="line">    LOCAL = 3;</span><br><span class="line">    NEWS = 4;</span><br><span class="line">    PRODUCTS = 5;</span><br><span class="line">    VIDEO = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = 1;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x3D;&gt;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SearchRequest_Corpus <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        SearchRequest_UNIVERSAL SearchRequest_Corpus = <span class="number">0</span></span><br><span class="line">        SearchRequest_WEB       SearchRequest_Corpus = <span class="number">1</span></span><br><span class="line">        SearchRequest_IMAGES    SearchRequest_Corpus = <span class="number">2</span></span><br><span class="line">        SearchRequest_LOCAL     SearchRequest_Corpus = <span class="number">3</span></span><br><span class="line">        SearchRequest_NEWS      SearchRequest_Corpus = <span class="number">4</span></span><br><span class="line">        SearchRequest_PRODUCTS  SearchRequest_Corpus = <span class="number">5</span></span><br><span class="line">        SearchRequest_VIDEO     SearchRequest_Corpus = <span class="number">6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="use-generated-code"><a href="#use-generated-code" class="headerlink" title="use generated code"></a>use generated code</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">p := pb.Person&#123;</span><br><span class="line">        Id:    <span class="number">1234</span>,</span><br><span class="line">        Name:  <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">        Email: <span class="string">&quot;jdoe@example.com&quot;</span>,</span><br><span class="line">        Phones: []*pb.Person_PhoneNumber&#123;</span><br><span class="line">                &#123;Number: <span class="string">&quot;555-4321&quot;</span>, Type: pb.Person_HOME&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// writing message to file(serialized)</span></span><br><span class="line">book := &amp;pb.AddressBook&#123;&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the new address book back to disk.</span></span><br><span class="line">out, err := proto.Marshal(book)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Failed to encode address book:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(fname, out, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Failed to write address book:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reading message back to struct</span></span><br><span class="line">in, err := ioutil.ReadFile(fname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Error reading file:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">book := &amp;pb.AddressBook&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := proto.Unmarshal(in, book); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Failed to parse address book:&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pty"><a href="#pty" class="headerlink" title="pty"></a>pty</h2><p>By default, Unix-style tty (i.e. console) drivers will take input in <code>&quot;cooked mode&quot;</code>. In this mode, it provides a certain amount of command-line editing. The user can type in a line of input, possibly deleting and retyping some of it (but that doesn’t always work) and <strong><code>the program won&#39;t see it until the user hits enter</code>.</strong></p>
<p>In contrast, raw mode sets up the TTY driver to <code>pass every character to the program as it is typed</code>. Programs are <code>started in cooked mode by default and need to enable raw mode</code>. that means in raw mode, ctrl+c, ctrl+\ passed in as well, signal hanler is not called!!!, but in cooked mode, it’s handler is called, hence program exits!!!</p>
<p>Here is example how to enable raw mode in C <a target="_blank" rel="noopener" href="https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html">terminal in C</a> which calls ioctl to do this.</p>
<h3 id="go-package"><a href="#go-package" class="headerlink" title="go package"></a>go package</h3><p>Pty is a Go package for using unix pseudo-terminals.<br><code>go get github.com/creack/pty</code></p>
<h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p><strong>run bash in pty to create a new terminal</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/creack/pty&quot;</span></span><br><span class="line">    <span class="string">&quot;golang.org/x/term&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// Create arbitrary command.</span></span><br><span class="line">    c := exec.Command(<span class="string">&quot;bash&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the command with a pty.</span></span><br><span class="line">    <span class="comment">// run the command async(and cmd&#x27;s std set with pty file /dev/pts/x)</span></span><br><span class="line">    ptmx, err := pty.Start(c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make sure to close the pty at the end.</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = ptmx.Close() &#125;() <span class="comment">// Best effort.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle pty size.</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// window size change signal</span></span><br><span class="line">    signal.Notify(ch, syscall.SIGWINCH)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">range</span> ch &#123;</span><br><span class="line">            <span class="comment">// window size change, change ptmx to os.Stdin size</span></span><br><span class="line">            <span class="keyword">if</span> err := pty.InheritSize(os.Stdin, ptmx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">&quot;error resizing pty: %s&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    ch &lt;- syscall.SIGWINCH                        <span class="comment">// Initial resize.</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; signal.Stop(ch); <span class="built_in">close</span>(ch) &#125;() <span class="comment">// Cleanup signals when done.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set stdin in raw mode, key types is sent to pty directly without cookied</span></span><br><span class="line">    oldState, err := term.MakeRaw(<span class="type">int</span>(os.Stdin.Fd()))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = term.Restore(<span class="type">int</span>(os.Stdin.Fd()), oldState) &#125;() <span class="comment">// Best effort.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy stdin to the pty and the pty to stdout.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> The goroutine will keep reading until the next keystroke before returning.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// io.Copy blocks if no input</span></span><br><span class="line">        <span class="comment">// when run $ ls</span></span><br><span class="line">        <span class="comment">// 1. for each char, l and s Copy from StdIn, then Copy to Stdout</span></span><br><span class="line">        <span class="comment">// 2. if enter is pressed, ptmx gets the full input as cmd.Stdin set with ptmx, so cmd gets the input &#x27;ls&#x27;, runs it and writes output to cmd.Stdout which is ptmx</span></span><br><span class="line">        <span class="comment">// 2. Copy the ls output from ptmx to os.Stdout, so we can see it</span></span><br><span class="line">        _, _ = io.Copy(ptmx, os.Stdin)</span><br><span class="line">        <span class="comment">//ptmx implement Reader/Writer interface</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// blocks if no output from ptmx</span></span><br><span class="line">    _, _ = io.Copy(os.Stdout, ptmx)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := test(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/creack/pty&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// create a command, not run here</span></span><br><span class="line">    c := exec.Command(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;--color=auto&quot;</span>, <span class="string">&quot;bar&quot;</span>)</span><br><span class="line">    <span class="comment">// Start assigns a pseudo-terminal tty os.File to c.Stdin, c.Stdout,</span></span><br><span class="line">    <span class="comment">// and c.Stderr, calls c.Start, and returns the File of pty(/dev/pts/X)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set Stdxx of command: c.Stdin = c.Stdout = c.Stderr = os.File(/dev/pts/X)</span></span><br><span class="line">    <span class="comment">// then run command with c.Start()(async), when NO input, grep hangs for input</span></span><br><span class="line">    f, err := pty.Start(c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// File(/dev/pts/X) of corresponding pty</span></span><br><span class="line">        <span class="comment">// write to /dev/pts/X, like input from user, input to command grep</span></span><br><span class="line">        f.Write([]<span class="type">byte</span>(<span class="string">&quot;foo\n&quot;</span>))</span><br><span class="line">        f.Write([]<span class="type">byte</span>(<span class="string">&quot;bar\n&quot;</span>))</span><br><span class="line">        f.Write([]<span class="type">byte</span>(<span class="string">&quot;baz\n&quot;</span>))</span><br><span class="line">        f.Write([]<span class="type">byte</span>&#123;<span class="number">4</span>&#125;) <span class="comment">// EOT</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// as cmd&#x27;s Stdout set to f, hence grep writes output to file /dev/ptx/X</span></span><br><span class="line">    <span class="comment">// copy output from f(read from /dev/ptx/X) to os.Stdout!!!</span></span><br><span class="line">    io.Copy(os.Stdout, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>foo
bar
baz
</code></pre>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="use-io-pipe-or-channel"><a href="#use-io-pipe-or-channel" class="headerlink" title="use io.pipe or channel?"></a>use io.pipe or channel?</h2><p>It depends on the data that will be transmitted, if data is stream, use io.Pipe, if data is fixed type, use channel, as it’s like datagram!!</p>
<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ul>
<li><a target="_blank" rel="noopener" href="https://golang.org/pkg/#stdlib">standard library</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/">pkg repo</a></li>
</ul>

    </div>

    
    
    
      


    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="Jason WeChat Pay">
        <span>WeChat Pay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/30/go-advanced/" rel="prev" title="go-advanced">
                  <i class="fa fa-chevron-left"></i> go-advanced
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/03/libvirt-vnc-spice/" rel="next" title="libvirt-vnc-spice">
                  libvirt-vnc-spice <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cyun All rights reserved</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"jason-bj/blog","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
