<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <meta name="google-site-verification" content="xitt2fbphh1nTeWLiTWc0lCggHuxJ5heMcAzkHW2vno">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Microsoft+YaHei+UI:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"cyun.tech","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":10,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="overviewGo is a statically typed, compiled programming language designed at Google， Go is syntactically similar to C, but with memory safety, garbage collection, structural typing, concurrency.    Go">
<meta property="og:type" content="article">
<meta property="og:title" content="go-basic">
<meta property="og:url" content="http://cyun.tech/2021/07/29/go-basic/index.html">
<meta property="og:site_name" content="CYun">
<meta property="og:description" content="overviewGo is a statically typed, compiled programming language designed at Google， Go is syntactically similar to C, but with memory safety, garbage collection, structural typing, concurrency.    Go">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.stack.imgur.com/mwulG.png">
<meta property="og:image" content="https://i.stack.imgur.com/p2eqp.png">
<meta property="og:image" content="https://i.stack.imgur.com/7GnUF.png">
<meta property="article:published_time" content="2021-07-29T11:51:15.000Z">
<meta property="article:modified_time" content="2023-08-16T15:02:01.144Z">
<meta property="article:author" content="Jason">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.stack.imgur.com/mwulG.png">


<link rel="canonical" href="http://cyun.tech/2021/07/29/go-basic/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://cyun.tech/2021/07/29/go-basic/","path":"2021/07/29/go-basic/","title":"go-basic"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go-basic | CYun</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148730544-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-148730544-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?a510d1f580c8231f8f867d14f42bb8ea"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CYun</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#overview"><span class="nav-number">1.</span> <span class="nav-text">overview</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#naming-convention"><span class="nav-number">2.</span> <span class="nav-text">naming convention</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#printing"><span class="nav-number">3.</span> <span class="nav-text">printing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#builtin-API"><span class="nav-number">4.</span> <span class="nav-text">builtin API</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#constants"><span class="nav-number">5.</span> <span class="nav-text">constants</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#constant-type"><span class="nav-number">5.1.</span> <span class="nav-text">constant type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-deduction-type-inference"><span class="nav-number">5.2.</span> <span class="nav-text">type deduction(type inference)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constant-declaration-way"><span class="nav-number">5.3.</span> <span class="nav-text">constant declaration way</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Autocomplete-in-constant-declarations"><span class="nav-number">5.3.1.</span> <span class="nav-text">Autocomplete in constant declarations</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#variable"><span class="nav-number">6.</span> <span class="nav-text">variable</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#standard-way"><span class="nav-number">6.1.</span> <span class="nav-text">standard way</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#short-way"><span class="nav-number">6.2.</span> <span class="nav-text">short way</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#default-value-of-each-type-without-explicit-initialization"><span class="nav-number">6.3.</span> <span class="nav-text">default value of each type(without explicit initialization)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#variable-initialization-order"><span class="nav-number">6.4.</span> <span class="nav-text">variable initialization order</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pointer"><span class="nav-number">6.5.</span> <span class="nav-text">pointer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scope"><span class="nav-number">6.6.</span> <span class="nav-text">scope</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#types"><span class="nav-number">7.</span> <span class="nav-text">types</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#conversion"><span class="nav-number">7.1.</span> <span class="nav-text">conversion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string"><span class="nav-number">7.2.</span> <span class="nav-text">string</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#array-and-slice"><span class="nav-number">7.3.</span> <span class="nav-text">array and slice</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#slice"><span class="nav-number">7.3.1.</span> <span class="nav-text">slice</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-dict"><span class="nav-number">7.4.</span> <span class="nav-text">map(dict)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct"><span class="nav-number">7.5.</span> <span class="nav-text">struct</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#function"><span class="nav-number">8.</span> <span class="nav-text">function</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#defer"><span class="nav-number">8.1.</span> <span class="nav-text">defer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#function-object"><span class="nav-number">8.2.</span> <span class="nav-text">function object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#function-closure"><span class="nav-number">8.3.</span> <span class="nav-text">function closure</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#variadic-function-dynamic-parameters"><span class="nav-number">8.4.</span> <span class="nav-text">variadic function(dynamic parameters)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#function-type"><span class="nav-number">8.5.</span> <span class="nav-text">function type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#function-parameter"><span class="nav-number">8.6.</span> <span class="nav-text">function parameter</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#flow-control"><span class="nav-number">9.</span> <span class="nav-text">flow control</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#for"><span class="nav-number">9.1.</span> <span class="nav-text">for</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if"><span class="nav-number">9.2.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch"><span class="nav-number">9.3.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#goto"><span class="nav-number">9.4.</span> <span class="nav-text">goto</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break-x2F-continue"><span class="nav-number">9.5.</span> <span class="nav-text">break&#x2F;continue</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#system-env"><span class="nav-number">10.</span> <span class="nav-text">system env</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#small-tips"><span class="nav-number">11.</span> <span class="nav-text">small tips</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#return-local-var-from-stack-is-safe-in-GO"><span class="nav-number">11.1.</span> <span class="nav-text">return local var from stack is safe in GO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string-vs-byte"><span class="nav-number">11.2.</span> <span class="nav-text">string vs [] byte</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#what-does-empty-mean-for-each-type"><span class="nav-number">11.3.</span> <span class="nav-text">what does empty mean for each type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get-the-size-of-memory-for-each-type"><span class="nav-number">11.4.</span> <span class="nav-text">get the size of memory for each type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#when-should-I-use-new"><span class="nav-number">11.5.</span> <span class="nav-text">when should I use new()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#when-should-I-use-make"><span class="nav-number">11.6.</span> <span class="nav-text">when should I use make()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pointer-to-array-and-array-of-pointers"><span class="nav-number">11.7.</span> <span class="nav-text">pointer to array and array of pointers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#check-type-of-variable"><span class="nav-number">11.8.</span> <span class="nav-text">check type of variable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#variable-has-same-name-with-package"><span class="nav-number">11.9.</span> <span class="nav-text">variable has same name with package</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ref"><span class="nav-number">12.</span> <span class="nav-text">ref</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jason"
      src="/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">150</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">143</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">149</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jason-cyun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jason-cyun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jason_lkm@163.com" title="E-Mail → mailto:jason_lkm@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cyun.tech/2021/07/29/go-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="Jason">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CYun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="go-basic | CYun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go-basic
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-29 19:51:15" itemprop="dateCreated datePublished" datetime="2021-07-29T19:51:15+08:00">2021-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-16 23:02:01" itemprop="dateModified" datetime="2023-08-16T23:02:01+08:00">2023-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/program/" itemprop="url" rel="index"><span itemprop="name">program</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>Go is a <code>statically typed, compiled</code> programming language designed at Google， Go is <code>syntactically similar to C</code>, but with <strong>memory safety, garbage collection, structural typing, concurrency.</strong>  </p>
<p><strong><font color='red'> Go is influenced by C, but with an <code>emphasis on greater simplicity and safety</code>.</font></strong></p>
<ul>
<li><p>A syntax and environment adopting patterns more common in dynamic languages:</p>
<ul>
<li>Optional concise variable declaration and initialization through type inference (x :&#x3D; 0 instead of int x &#x3D; 0; or var x &#x3D; 0;).</li>
<li>Fast compilation.</li>
<li>Remote package management (go get) and online package documentation.</li>
</ul>
</li>
<li><p>Distinctive approaches to particular problems:</p>
<ul>
<li><strong>Built-in concurrency primitives</strong>: light-weight processes (goroutines), channels, and the select statement.</li>
<li>An interface system in place of virtual inheritance, and <code>type embedding</code> instead of non-virtual inheritance.</li>
<li>A toolchain that, <strong><code>by default, produces statically linked native binaries without external dependencies</code>.</strong></li>
</ul>
</li>
</ul>
<hr>
<span id="more"></span>

<p><strong><font color='red'>Syntax</font></strong><br>Go’s syntax includes changes <code>from C aimed at keeping code concise and readable</code>. A <code>combined declaration/initialization operator</code> was introduced that allows the programmer to write i :&#x3D; 3 or s :&#x3D; “Hello, world!”, <code>without specifying the types of variables used</code>. This contrasts with <code>C&#39;s int i = 3; and const char *s = &quot;Hello, world!&quot;</code>; <strong>Semicolons(;) still terminate statements,but are implicit when the end of a line occurs</strong>. Methods may <strong>return multiple values</strong>, and returning a result, err pair is the conventional way a method indicates an error to its caller in Go. Go adds literal syntaxes for <strong><code>initializing struct parameters by name</code></strong> and for initializing maps and slices. As an alternative to C’s three-statement for loop, <strong>Go’s <code>range</code> expressions <code>allow concise iteration over arrays, slices, strings, maps, and channels</code></strong>.</p>
<hr>
<p><strong><font color='red'>Built-in Types </font></strong></p>
<ul>
<li>bool</li>
<li>string</li>
<li>int  int8  int16  int32  int64</li>
<li>uint uint8 uint16 uint32 uint64 uintptr</li>
<li><font color='red'>byte &#x2F;&#x2F; alias for uint8, used as char like c，<code>&#39;a&#39; + 1 is valid it&#39;s &#39;b&#39;</code></font></li>
<li><font color='red'>rune &#x2F;&#x2F; alias for int32 represents a Unicode code point</font></li>
<li>float32 float64</li>
<li>complex64 complex128</li>
<li>pointer</li>
</ul>
<p><strong>The int, uint types are usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems, it depends on arch, different like C, int, uint are 32 bits(4 bytes) even on 64-bit machine</strong></p>
<hr>
<p><strong><font color='red'>Custom type</font></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// status and bool are two different types.</span></span><br><span class="line"><span class="keyword">type</span> status <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Some type alias declarations */</span></span><br><span class="line"><span class="comment">// boolean and bool denote the same type.</span></span><br><span class="line"><span class="keyword">type</span> boolean = <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong><font color='red'> NOT Supported </font></strong></p>
<ul>
<li>inheritance</li>
<li>assertions</li>
<li><strong>pointer arithmetic</strong></li>
<li><strong>implicit type conversions</strong></li>
<li>NO ~x but ^x in Go for integer.</li>
</ul>
<hr>
<p><strong><font color='red'> Tools</font></strong><br>The main Go distribution includes tools for building, testing, and analyzing code:</p>
<ul>
<li><code>go build</code>, which builds Go binaries using only information in the source files themselves, no separate makefiles</li>
<li><code>go test</code>, for unit testing and microbenchmarks</li>
<li><code>go fmt</code>, for formatting code</li>
<li><code>go get</code>, for retrieving and installing remote packages</li>
<li><code>go vet</code>, a static analyzer looking for potential errors in code</li>
<li><code>go run</code>, a shortcut for building and executing code, but not save binary to disk.</li>
<li><code>godoc</code>, for displaying documentation or serving it via HTTP</li>
</ul>
<p>An ecosystem of third-party tools adds to the standard distribution, such as <code>gocode</code>, which enables code autocompletion in many text editors, <code>goimports</code>, which automatically adds&#x2F;removes package imports as needed, and<code>errcheck</code>, which detects code that might unintentionally ignore errors. </p>
<hr>
<p><strong><font color='red'>single quote vs double quote</font> They are different</strong></p>
<p>To <code>declare either byte or rune we use single quote</code>. While <code>declaring byte we have to specify the type</code>. If we do not specify the type, then the default type is meant as a rune for <code>&#39;a&#39;</code>. <strong>A single quote will allow only one character</strong>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span><span class="comment">// must declare with type byte, otherwise it&#x27;s rune !!!</span></span><br><span class="line">    ch := <span class="type">byte</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    rc := <span class="string">&#x27;a&#x27;</span> <span class="comment">/* default it&#x27;s a rune */</span></span><br><span class="line">    rs := <span class="string">&quot;a&quot;</span> <span class="comment">/* it&#x27;s string */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><font color='red'><strong>NO -&gt; for pointer type like what we did in C, but works as C like <code>&amp;a, *p, **p, *p=</code></strong></font></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;a <span class="comment">// pointer type and get object address</span></span><br><span class="line">*p = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *Student = &amp;Student&#123;x: <span class="number">1</span>&#125;</span><br><span class="line">p.x = <span class="number">12</span> <span class="comment">// Go automatically convert it to (*p).x = 12 !!!</span></span><br></pre></td></tr></table></figure>

<p><strong>string, slice, map behave like pointer, but when assigning and passing as parameter, array, struct are different.</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    s2 := s1 <span class="comment">// both s2 and s1 points to same memory</span></span><br><span class="line">    </span><br><span class="line">    sc1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sc2 := sc1 <span class="comment">// both sc1 and sc2 points to same underlaying array</span></span><br><span class="line">    </span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="string">&quot;a&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;b&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m2 := m1 <span class="comment">// both m1 and m2 points to same memory</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*-----------------------------------------*/</span></span><br><span class="line">    <span class="keyword">var</span> a1 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    a2 := a1 <span class="comment">// a2 is a copy of a1, different memory!!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> st1 = <span class="keyword">struct</span> &#123;</span><br><span class="line">        x, y <span class="type">int</span></span><br><span class="line">    &#125;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    </span><br><span class="line">    st2 := st1 <span class="comment">//st2 is a copy of st1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><code>for/range</code> when loop array, slice, map, it’s copy of element, hence if change on that element, make sure use <code>s[i]</code> if element is not pointer.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// slice of Person</span></span><br><span class="line">    ps := []Person&#123;</span><br><span class="line">        &#123;name: <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> ps &#123;</span><br><span class="line">        p.name = <span class="string">&quot;b&quot;</span> <span class="comment">// p is copy of each element</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nothing changed</span></span><br><span class="line">    fmt.Println(ps)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ps); i++ &#123;</span><br><span class="line">        ps[i].name = <span class="string">&quot;b&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(ps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Go_programming_language">Go Wiki Overview</a></p>
<h1 id="naming-convention"><a href="#naming-convention" class="headerlink" title="naming convention"></a>naming convention</h1><p>Go is to use MixedCaps or mixedCaps rather than underscores to write <code>multiword names</code>. </p>
<p><strong>Files</strong>  </p>
<ul>
<li>Go follows a convention where source <code>files are all lower case with underscore separating multiple words</code>, <span style="color:red">client_log.go</span></li>
<li>Compound file names are separated with <code>_</code></li>
<li>Files with the suffix <code>_test.go</code> are only compiled and run by the go test tool.</li>
</ul>
<p><strong>Functions and Methods</strong>  </p>
<ul>
<li>Use camel case, <code>exported functions should start with uppercase</code></li>
<li>If a name consists of multiple words, each word after the first should be capitalized like this: <span style="color:red">empName, EmpAddress</span>, etc.</li>
<li>function names are case-sensitive (car, Car and CAR are three different variables).</li>
</ul>
<p><strong>Constants</strong>  </p>
<ul>
<li>Constant should be capitalized(<strong>camel case like Exported named</strong>). <span style="color:red"> WorldStdEncoding<span></li>
</ul>
<p><strong>Variables</strong>  </p>
<ul>
<li>shouldn’t include the name of your type in the name of your variable’s name, <code>tetMap</code></li>
<li>Generally, use relatively <strong>simple (short) name(lower case), camel case(NOT _ underscore for multiple worlds) long var</strong>.<ul>
<li><span style="color:red">user to u</span></li>
<li><span style="color:red">userID to uid</span></li>
<li><span style="color:red">serverListener</span></li>
<li><span style="color:red">lpcfg</span></li>
</ul>
</li>
<li>If variable type is bool, its name should start with Has, Is, Can or Allow, etc.</li>
<li>Single letter represents index: i, j, k</li>
</ul>
<p><strong>struct interface</strong>  </p>
<ul>
<li>Name of struct or interface <code>should be capitalized and camel case</code> <span style="color:red">type BJSchool struct{}<span></li>
<li><strong><code>method of interface and struct</code></strong> should be capitalized(exported) and camel case <span style="color:red">type School interface{ Name() string }<span></li>
<li><strong><code>field of struct</code></strong> should be low letter starts camel case if not exported, otherwise uppercase <span style="color:red">type School struct { regStudent int }<span></li>
</ul>
<p><strong>import package</strong></p>
<ul>
<li>package name should be lowercase, no camel case. like <span style="color:red">import xxx&#x2F;testhello</span></li>
</ul>
<p><strong>Non-exported struct fields can be accessed only in the same package, can not be accessed by other package.</strong></p>
<h1 id="printing"><a href="#printing" class="headerlink" title="printing"></a>printing</h1><p><strong><a target="_blank" rel="noopener" href="https://yourbasic.org/golang/fmt-printf-reference-cheat-sheet/">FMT Print cheat-sheet</a></strong>  </p>
<p>Package <code>fmt</code> implements formatted I&#x2F;O with functions analogous to C’s printf and scanf. The format ‘verbs’ are derived from C’s but are simpler. </p>
<p>In Golang we can use <strong><code>Printf with a special format code</code></strong>. This determines how a string or integer is formatted. <strong><code>Println does not require a format string</code>.</strong></p>
<ul>
<li><strong>Printf</strong>: Must provide the format and <strong><code>support explicit argument indexes, no auto newline</code>.</strong></li>
<li><strong>Println</strong>: <strong>No special format support, auto newline for each output, auto space between arguments</strong>, just use it’s default.</li>
<li><strong>Print</strong>: Print does <strong>not insert a newline after each call and no auto space between arguments</strong>, it just writes the data to the console with no trailing newline, except this, same as <strong>Println</strong>.</li>
</ul>
<p><strong>Above three prints to console while Sxx returns the formated result.</strong></p>
<ul>
<li><strong>Sprintf</strong>: Must provide the format and <strong><code>support explicit argument indexes, No auto newline</code>.</strong></li>
<li><strong>Sprintln</strong>: <code>No special format support, auto newline</code>, just use it’s default.</li>
<li><strong>Sprint</strong>: Print does not insert a newline after each call, it just writes the data to the console with no trailing newline, except this, same as <strong>Sprintln</strong>.</li>
</ul>
<p><strong>Above three prints returns the formated result, while <code>Fxx</code> writes data to io.Writer</strong></p>
<ul>
<li><strong>Fprintf</strong>: Must provide the format and <strong><code>support explicit argument indexes, No auto newline</code>.</strong></li>
<li><strong>Fprintln</strong>: <code>No special format support, auto newline</code>, just use it’s default.</li>
<li><strong>Fprint</strong>: Print does not insert a newline after each call, it just writes the data to the file with no trailing newline, except this, same as <strong>Fprintln</strong>.</li>
</ul>
<hr>
<p><strong>explicit argument index</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line">b := <span class="number">20</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %v\n&quot;</span>, a, b) <span class="comment">// 10 20</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%[2]v %[1]v\n&quot;</span>, a, b) <span class="comment">// 20 10 argument index</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>default format of each type</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">%c    print for byte and rune only</span><br><span class="line">%q    a single-quoted character literal safely escaped with Go syntax, used for byte,rune and string</span><br><span class="line">%v    the value in a default format</span><br><span class="line">      [when printing struct], the plus flag (%+v) adds field names---&gt;suggested way.</span><br><span class="line">      [when printing struct], the plus flag (%#v) adds field names and struct definition</span><br><span class="line">%T    a Go-syntax representation of the [type of the value] </span><br><span class="line"></span><br><span class="line">The default format for %v is:</span><br><span class="line"></span><br><span class="line">bool:                    %t</span><br><span class="line">int, int8, rune, byte:   %d</span><br><span class="line">uint, uint8 etc.:        %d</span><br><span class="line">float32, complex64, etc: %g</span><br><span class="line">string:                  %s</span><br><span class="line">chan:                    %p</span><br><span class="line">pointer:                 %p</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>print in multiple lines</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">`hello</span></span><br><span class="line"><span class="string">world`</span> <span class="comment">// auto enter!!! without \n needed</span></span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;hello\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>%q vs %c vs %s</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="type">byte</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, c)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, c)</span><br><span class="line"></span><br><span class="line">    s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line">a</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>More details refer to <a target="_blank" rel="noopener" href="https://golang.org/pkg/fmt/">fmt package</a>, <code>like C format, but more simpler to use.</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print_demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    b := <span class="number">20</span></span><br><span class="line">    s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    </span><br><span class="line">    fmt.Print(a, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    fmt.Print(<span class="string">&quot;Print: no auto space added between arg &quot;</span>, a, s) <span class="comment">// no space bettween each argument</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println()</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Println: each arg is separated by space automatically&quot;</span>, a, s)<span class="comment">//each argument is separated by space</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Println: not support special format:&quot;</span>, a, <span class="string">&quot;not cool&quot;</span>) <span class="comment">// auto new line</span></span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;Printf: support special format: %[2]v %[1]v\n&quot;</span>, a, s) <span class="comment">//argument must be at most right part, mannually new line</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    result := fmt.Sprintf(<span class="string">&quot;Sprintf: support special format: %[2]v %[1]v&quot;</span>, a, b) <span class="comment">// use argument index</span></span><br><span class="line">    fmt.Println(result)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* print array, slice, struct */</span></span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">999</span>, <span class="number">99</span>, <span class="number">9</span>&#125;</span><br><span class="line">    array := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    fmt.Println(slice)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, array)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="type">string</span></span><br><span class="line">        id <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> p1 Person = Person&#123;<span class="string">&quot;jason&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    fmt.Println(p1)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, p1)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, p1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// s = hello</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v %q\n&quot;</span>, s, s)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> s <span class="type">byte</span> = <span class="number">65</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v %q\n&quot;</span>, s, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_demo()</span><br></pre></td></tr></table></figure>

<pre><code>10
Print: no auto space added between arg 10hello
10
Println: each arg is separated by space automatically 10 hello
Println: not support special format: 10 not cool
Printf: support special format: hello 10
Sprintf: support special format: 20 10
[999 99 9]
[a b c]
&#123;jason 1&#125;
struct &#123; 𒀸name string; 𒀸id int &#125;&#123;𒀸name:&quot;jason&quot;, 𒀸id:1&#125;
&#123;𒀸name:jason 𒀸id:1&#125;
&#123;jason 1&#125;
hello &quot;hello&quot;
65 &#39;A&#39;
</code></pre>
<h1 id="builtin-API"><a href="#builtin-API" class="headerlink" title="builtin API"></a>builtin API</h1><p><code>func append(slice []Type, elems ...Type) []Type</code></p>
<blockquote>
<p>The append built-in function appends elements to <strong>the end of a slice</strong>. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it <strong>does not sufficient, a new underlying array will be allocated</strong></p>
</blockquote>
<p><code>func cap(v Type) int</code></p>
<blockquote>
<ol>
<li>Array: the number of elements in v (same as len(v)).<br>2.Pointer to array: the number of elements in *v (same as len(v)).<br>3.<code>Slice: the maximum length the slice can reach when resliced, may different with len(slice)</code><br>4.if v is nil, cap(v) is zero.<br>5.<code>Channel: the channel buffer capacity, in units of elements;</code></li>
</ol>
</blockquote>
<p><code>func close(c chan&lt;- Type)</code></p>
<blockquote>
<p>The close built-in function <strong>closes a channel not a file</strong>, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element</p>
</blockquote>
<p><code>func copy(dst, src []Type) int</code> shadow copy(only the top level is copied)</p>
<blockquote>
<p>The copy built-in function <strong>copies elements from a source slice into a destination slice</strong>. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst). </p>
</blockquote>
<p><code>func delete(m map[Type]Type1, key Type)</code>  </p>
<blockquote>
<p><strong>delete element specified by key from a map</strong></p>
</blockquote>
<p><code>func len(v Type) int</code></p>
<blockquote>
<p>1.Array: the number of elements in v.<br>2.Pointer to array: the number of elements in *v (even if v is nil).<br>3.Slice, or map: the number of elements in v; if v is nil, len(v) is zero.<br>4.<code>String: the number of bytes in v</code>.<br>5.<code>Channel: the number of elements queued (unread) in the channel buffer</code>;<br>6.if v is nil, len(v) is zero.</p>
</blockquote>
<p><code>func make(t Type, size ...IntegerType) Type</code></p>
<blockquote>
<p><strong>Can be used only for Slice, Map, Channel</strong>  </p>
</blockquote>
<pre><code>Slice: The size specifies the length. The capacity of the slice is
equal to its length. A second integer argument may be provided to
specify a different capacity; it must be no smaller than the
length. For example, make([]int, 0, 10) allocates an underlying array
of size 10 and returns a slice of length 0 and capacity 10 that is
backed by this underlying array.

Map: An empty map is allocated with enough space to hold the
specified number of elements. The size may be omitted, in which case
a small starting size is allocated.  

Channel: The channel&#39;s buffer is initialized with the specified
buffer capacity. If zero, or the size is omitted, the channel is
unbuffered. 

# for slice, can pass two parameters
s1 = make([]int, 4)   // len=4 and cap = 4
s1 = make([]int, 0, 4)// len=0 and cap = 4

# for map, no one needed
m1 = make(map[string]int)

# for channel, can pass one parameter
c1 = make(chan int)     // buffer size 0(unbuffered)
c2 = make(chan int, 10) // buffer size 10
                                                                                      
</code></pre>
<p><code>func new(Type) *Type</code></p>
<blockquote>
<p>The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type. <code>most of time, we does not use it at all</code>.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">builtin_demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(s1, s2)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">copy</span>(s2, s1)</span><br><span class="line">    fmt.Println(s1, s2)</span><br><span class="line">    </span><br><span class="line">    p := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    *p = <span class="number">12</span></span><br><span class="line">    fmt.Println(p, *p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">builtin_demo()</span><br></pre></td></tr></table></figure>

<pre><code>[1 2 3] [0 0 0 0]
[1 2 3] [1 2 3 0]
0xc0009190d0 12
</code></pre>
<h1 id="constants"><a href="#constants" class="headerlink" title="constants"></a>constants</h1><p><strong>untyped value has default type</strong><br>An untyped value means the type of the value has not been confirmed yet. For most untyped values, each of them has one default type, <code>All literal constants (unnamed constants) are untyped values</code>. most untyped values are literal constants and named constants.</p>
<hr>
<p><font color='red'>The default type of a literal constant is determined by its literal form.</font></p>
<ul>
<li>The default type of a string literal is string.</li>
<li>The default type of a boolean literal is bool.</li>
<li>The default type of an <code>integer literal is int.</code></li>
<li>The default type of a <code>rune literal is rune (a.k.a., int32)</code>.</li>
<li>The default type of a floating-point literal is float64.</li>
<li>If a literal contains an imaginary part, then its default type is complex128</li>
</ul>
<h2 id="constant-type"><a href="#constant-type" class="headerlink" title="constant type"></a>constant type</h2><p><strong>unnamed constant(literal constant)</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>named constant with untyped value</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><strong>named constant with typed value</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX <span class="type">int8</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<h2 id="type-deduction-type-inference"><a href="#type-deduction-type-inference" class="headerlink" title="type deduction(type inference)"></a>type deduction(type inference)</h2><p>Go supports type deduction. In other words, in many circumstances, programmers don’t need to explicitly specify the types of some values in code. Go compilers will deduce the types for these values by context.</p>
<p>In Go code, if a place needs a value of a certain type and <code>an untyped value (often a constant) is representable as a value of the certain type, then the untyped value can be used in the place</code>. Go compilers will view the untyped value as a typed value of the certain type. it can be viewed as <code>implicit conversions</code>.</p>
<h2 id="constant-declaration-way"><a href="#constant-declaration-way" class="headerlink" title="constant declaration way"></a>constant declaration way</h2><p><code>= not := for constant declaration</code></p>
<p><strong>untyped named constant</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare two individual constants. Yes,</span></span><br><span class="line"><span class="comment">// non-ASCII letters can be used in identifiers.</span></span><br><span class="line"><span class="keyword">const</span> π = <span class="number">3.1416</span></span><br><span class="line"><span class="keyword">const</span> Pi = π <span class="comment">// &lt;=&gt; const Pi = 3.1416</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare multiple constants in a group called constant specification can be different types.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	No         = !Yes</span><br><span class="line">	Yes        = <span class="literal">true</span></span><br><span class="line">	MaxDegrees = <span class="number">360</span></span><br><span class="line">	Unit       = <span class="string">&quot;radian&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Declare multiple constants in one line. can be different types!!!</span></span><br><span class="line">	<span class="keyword">const</span> TwoPi, HalfPi, Unit2 = π * <span class="number">2</span>, π * <span class="number">0.5</span>, <span class="string">&quot;degree&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>typed named constant</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> X <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	A, B <span class="type">int64</span>   = <span class="number">-3</span>, <span class="number">5</span> <span class="comment">// A and B are same type</span></span><br><span class="line">	Y    <span class="type">float32</span> = <span class="number">2.718</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If a basic value literal is bound to a typed constant, </span></span><br><span class="line"><span class="comment">// the basic value literal must be representable as a value of the type of the constant.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// error: 256 overflows uint8</span></span><br><span class="line"><span class="keyword">const</span> a <span class="type">uint8</span> = <span class="number">256</span></span><br><span class="line"><span class="keyword">const</span> MaxUint <span class="type">uint</span> = (<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span> <span class="comment">// error on 32-bit as (1 &lt;&lt; 64) - 1 is not representable as 32-bit values</span></span><br></pre></td></tr></table></figure>
<h3 id="Autocomplete-in-constant-declarations"><a href="#Autocomplete-in-constant-declarations" class="headerlink" title="Autocomplete in constant declarations"></a>Autocomplete in constant declarations</h3><p>In a group-style constant declaration, except the first constant specification, other constant specifications can be incomplete. An incomplete constant specification doesn’t contain the &#x3D; symbol. <strong><code>Compilers will autocomplete the incomplete lines for us by copying the missing part from the first preceding complete constant specification</code>.</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	X <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">	Y           <span class="comment">// here must be one identifier, Y has same like X.</span></span><br><span class="line"></span><br><span class="line">	A, B = <span class="string">&quot;Go&quot;</span>, <span class="string">&quot;language&quot;</span></span><br><span class="line">	C, _</span><br><span class="line">	<span class="comment">// In the above line, the blank identifier is required to be present.!!!</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>iota is a special value controlled by compiler, <strong>its value is reset to 0 for <code>each const keyword</code> the first constant line of group</strong>, and increased by 1 for each appearance before <code>next const keyword</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		k = <span class="number">3</span> <span class="comment">// now, iota == 0</span></span><br><span class="line"></span><br><span class="line">		m <span class="type">float32</span> = <span class="literal">iota</span> + <span class="number">.5</span> <span class="comment">// m float32 = 1 + .5</span></span><br><span class="line">		n                     <span class="comment">// n float32 = 2 + .5</span></span><br><span class="line"></span><br><span class="line">		p = <span class="number">9</span>             <span class="comment">// now, iota == 3</span></span><br><span class="line">		q = <span class="literal">iota</span> * <span class="number">2</span>      <span class="comment">// q = 4 * 2</span></span><br><span class="line">		_                 <span class="comment">// _ = 5 * 2</span></span><br><span class="line">		r                 <span class="comment">// r = 6 * 2</span></span><br><span class="line">		s, t = <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">// s, t = 7, 7   iota has the same vale on the same line</span></span><br><span class="line">		u, v              <span class="comment">// u, v = 8, 8</span></span><br><span class="line">		_, w              <span class="comment">// _, w = 9, 9</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> x = <span class="literal">iota</span> <span class="comment">// x = 0</span></span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		y = <span class="literal">iota</span> <span class="comment">// y = 0</span></span><br><span class="line">		z        <span class="comment">// z = 1</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// a == 1</span></span><br><span class="line">    b = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// b == 2</span></span><br><span class="line">    c = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// c == 4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same as above</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// a == 1</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Failed = <span class="literal">iota</span> - <span class="number">1</span> <span class="comment">// == -1</span></span><br><span class="line">	Unknown           <span class="comment">// == 0</span></span><br><span class="line">	Succeeded         <span class="comment">// == 1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>NOTE</strong>  </p>
<ul>
<li>Constants are declared like variables, but with the <code>const keyword</code>.</li>
<li>Constants can be <code>character, string, boolean, or numeric values</code>.</li>
<li>Constants <strong>can NOT be declared using the :&#x3D; syntax.</strong></li>
<li>This is <strong>no enum in GO, use const instead</strong></li>
<li>Constants can be declared both at package level and function bodies.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// like enum</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday = <span class="literal">iota</span> <span class="comment">// Sunday == 0</span></span><br><span class="line">    Monday        <span class="comment">// Monday == 1</span></span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">    numberOfDays</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constanDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;day %v\n&quot;</span>, Sunday)</span><br><span class="line">    <span class="keyword">const</span> World = <span class="string">&quot;world&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello&quot;</span>, World)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Happy&quot;</span>, Pi, <span class="string">&quot;Day&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Truth = <span class="literal">true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Go rules?&quot;</span>, Truth)</span><br><span class="line">    <span class="keyword">const</span> Ch <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Char&quot;</span>, Ch)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Char %c&quot;</span>, Ch)</span><br><span class="line">&#125;</span><br><span class="line">constanDemo()</span><br></pre></td></tr></table></figure>

<pre><code>day 0
Hello world
Happy 3.14 Day
Go rules? true
Char 97
Char a
</code></pre>
<h1 id="variable"><a href="#variable" class="headerlink" title="variable"></a>variable</h1><p>All variables are typed values. <code>When declaring a variable, there must be sufficient information provided for compilers to deduce the type of the variable</code></p>
<p>There are two basic variable declaration forms, the standard one and the short one. <code>The short form can only be used to declare local variables</code></p>
<hr>
<p><strong>NOTE</strong>  </p>
<ul>
<li><font color='red'>var is not needed for declaration like in struct, function parameter, function return value</font></li>
<li>var is a must when declare global variable, optional for local variable.</li>
<li>All variables are addressable and all constants are unaddressable</li>
<li>Go doesn’t support assignment chain, like this a &#x3D; b &#x3D; 123.</li>
</ul>
<hr>
<p><strong>Suggestion</strong></p>
<ul>
<li>constant, use <code>const statement not var statement</code></li>
<li>global variable, use <code>var statement</code></li>
<li>local variable, but <code>no need explicit initialization(default value), use var statement</code></li>
<li>local variable, <code>needs initialization, use := statement</code></li>
<li>with assignment at declaration, always use short way.</li>
</ul>
<p><font color='red'>As Go is compiled language, hence we must know the type of each variable at declaration either by explicit or implicit(assigned value), the type of variable is determined at declaration, can’t be change during running!!!</font></p>
<p><strong>When declaring a variable without specifying an explicit type (either by using the :&#x3D; syntax or var &#x3D; expression syntax), the variable’s type is inferred from the value on the right hand side</strong></p>
<h2 id="standard-way"><a href="#standard-way" class="headerlink" title="standard way"></a>standard way</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang, website <span class="type">string</span> = <span class="string">&quot;Go&quot;</span>, <span class="string">&quot;https://golang.org&quot;</span></span><br><span class="line"><span class="keyword">var</span> compiled, dynamic <span class="type">bool</span> = <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> announceYear <span class="type">int</span> = <span class="number">2009</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var of annymous struct type</span></span><br><span class="line"><span class="comment">// g is a variable of struct type who has one field.</span></span><br><span class="line"><span class="keyword">var</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var of function type</span></span><br><span class="line"><span class="keyword">var</span> g <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> g <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, d = <span class="number">1</span>, <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> next = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	lang, bornYear, compiled     = <span class="string">&quot;Go&quot;</span>, <span class="number">2007</span>, <span class="literal">true</span></span><br><span class="line">	announceAt, releaseAt    <span class="type">int</span> = <span class="number">2009</span>, <span class="number">2012</span></span><br><span class="line">	createdBy, website       <span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g <span class="comment">// error as no way to know the type at declaration</span></span><br><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line">a = b = <span class="number">123</span> <span class="comment">// syntax error, Go doesn&#x27;t support assignment chain</span></span><br></pre></td></tr></table></figure>
<h2 id="short-way"><a href="#short-way" class="headerlink" title="short way"></a>short way</h2><p>Short variable declarations can only be used to declare local variables.</p>
<p>There are several differences between short and standard variable declarations.</p>
<ul>
<li>In the short declaration form, the var keyword and variable types must be omitted.</li>
<li>The assignment sign must be :&#x3D; instead of &#x3D;.</li>
<li>In the short variable declaration, <code>old variables and new variables can mix at the left of :=. But there must be at least one new variable at the left.</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Both lang and year are newly declared.</span></span><br><span class="line">	lang, year := <span class="string">&quot;Go language&quot;</span>, <span class="number">2007</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Only createdBy is a new declared variable.</span></span><br><span class="line">	<span class="comment">// The year variable has already been</span></span><br><span class="line">	<span class="comment">// declared before, so here its value is just</span></span><br><span class="line">	<span class="comment">// modified, or we can say it is redeclared.</span></span><br><span class="line">	year, createdBy := <span class="number">2009</span>, <span class="string">&quot;Google Research&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="comment">// both month, year are new within this scope</span></span><br><span class="line">        month, year:=<span class="number">12</span>, <span class="number">2006</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(year) <span class="comment">// it&#x27;s still 2009!!!</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// This is a pure assignment.</span></span><br><span class="line">	lang, year = <span class="string">&quot;Go&quot;</span>, <span class="number">2012</span></span><br><span class="line">    </span><br><span class="line">    nextYear := year <span class="comment">// same type as year</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>NOTE :&#x3D; declare all new variables left, not part of it</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for scope</span></span><br><span class="line">    <span class="keyword">for</span> i, e := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="comment">// i is a new var with scope for!!!</span></span><br><span class="line">        fmt.Println(i, e)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;=================&quot;</span>)</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">go</span> run  test.<span class="keyword">go</span></span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br><span class="line">=================</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="default-value-of-each-type-without-explicit-initialization"><a href="#default-value-of-each-type-without-explicit-initialization" class="headerlink" title="default value of each type(without explicit initialization)"></a>default value of each type(without explicit initialization)</h2><p>Variables declared <code>without an explicit initial value</code> are given their <code>zero value</code>, you can access var with zero directly, one except is for map, <code>you can NOT modify nil map</code>!!</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="comment">// nil map</span></span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="number">12</span> <span class="comment">// panic!!!</span></span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125; <span class="comment">// empty map</span></span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="number">12</span> <span class="comment">// it&#x27;s ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> <span class="comment">// nil slice</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)<span class="comment">// it&#x27;s ok!!!</span></span><br><span class="line"></span><br><span class="line">s := []<span class="type">int</span>&#123;&#125; <span class="comment">// empty slice</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>) <span class="comment">// ok as well</span></span><br></pre></td></tr></table></figure>

<p><strong><code>zero</code> value for each type</strong>  </p>
<ul>
<li>0 for numeric types,</li>
<li>false for the boolean type</li>
<li>“” (the empty string) for string.</li>
<li>nil for pointer</li>
<li>nil for function type</li>
<li>nil, but len(map) &#x3D;&#x3D; 0</li>
<li>nil, but len(slice) &#x3D;&#x3D; 0</li>
<li>zero value for all fields for struct instance</li>
</ul>
<h2 id="variable-initialization-order"><a href="#variable-initialization-order" class="headerlink" title="variable initialization order"></a>variable initialization order</h2><p>When a variable depends on another variable b, b should be defined beforehand, else program won’t compile. <code>Go follows this rule inside functions</code>. <strong>but it’s not true for global variable.</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = b <span class="comment">// it&#x27;s ok</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c <span class="type">int</span> = d <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">var</span> d <span class="type">int</span> = <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pointer"><a href="#pointer" class="headerlink" title="pointer"></a>pointer</h2><p>The type <code>*T</code> is a pointer to a <code>T</code> type.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//The &amp; operator generates a pointer to its operand.</span></span><br><span class="line"></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br><span class="line"></span><br><span class="line">fmt.Println(*p) <span class="comment">// read i through the pointer p</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// set i through the pointer p</span></span><br></pre></td></tr></table></figure>

<h2 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h2><p>A variable or a named constant declared in an inner code block will shadow the variables and constants declared with the same name in outer code blocks.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y = <span class="number">789</span></span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// The x variable shadows the above declared</span></span><br><span class="line">	<span class="comment">// package-level variable x.</span></span><br><span class="line">	<span class="keyword">var</span> x = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// A nested code block.</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Here, the left x and y are both</span></span><br><span class="line">		<span class="comment">// new declared variable. The right</span></span><br><span class="line">		<span class="comment">// ones are declared in outer blocks.</span></span><br><span class="line">		x, y := x, y</span><br><span class="line"></span><br><span class="line">		<span class="comment">// In this code block, the just new</span></span><br><span class="line">		<span class="comment">// declared x and y shadow the outer</span></span><br><span class="line">		<span class="comment">// declared same-name identifiers.</span></span><br><span class="line">		x, z := !x, y/<span class="number">10</span> <span class="comment">// only z is new declared</span></span><br><span class="line">		y /= <span class="number">100</span></span><br><span class="line">		<span class="built_in">println</span>(x, y, z) <span class="comment">// false 7 78</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(x) <span class="comment">// true</span></span><br><span class="line">	<span class="built_in">println</span>(z) <span class="comment">// error: z is undefined.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ga, gb = <span class="number">1</span>, <span class="string">&quot;global b&quot;</span> <span class="comment">// implicit type</span></span><br><span class="line"><span class="keyword">var</span> gc, gd <span class="type">int</span>            <span class="comment">// must explicit type as no assignment</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">var_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    gc = <span class="number">10</span></span><br><span class="line">    gd = <span class="number">20</span></span><br><span class="line">    </span><br><span class="line">    la, lb := <span class="string">&quot;local a&quot;</span>, <span class="number">30</span>  <span class="comment">// implicit type</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lb = &quot;hi&quot; error as lb has type int!!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> lc <span class="type">string</span>            <span class="comment">// must explicit type as no assignment</span></span><br><span class="line">    lc = <span class="string">&quot;local c&quot;</span></span><br><span class="line">    fmt.Println(ga, gb, gc, gd, la, lb, lc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_demo()</span><br></pre></td></tr></table></figure>

<pre><code>1 global b 10 20 local a 30 local c
</code></pre>
<h1 id="types"><a href="#types" class="headerlink" title="types"></a>types</h1><p>Get Max value of integer, use <code>math</code> lib which provides Max of Int8, Int16, Int32, Int64, Int and unsigned version as well.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//do it by yourself</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MaxUint = ^<span class="type">uint</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="conversion"><a href="#conversion" class="headerlink" title="conversion"></a>conversion</h2><p><strong>Identical types, no need for conversion</strong></p>
<p>Two types are identical if their underlying type literals are structurally equivalent; that is, they have the same literal structure and corresponding components have identical types. In detail:</p>
<ul>
<li><p>Two array types are identical if they have identical element types and the same array length.</p>
</li>
<li><p>Two slice types are identical if they have identical element types.</p>
</li>
<li><p><code>Two struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags. Non-exported field names from different packages are always different.</code></p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A_ID <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    id A_ID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B_ID <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    id B_ID</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A and B are different type!!</span></span><br></pre></td></tr></table></figure>
<hr>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A and B are same type</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Two pointer types are identical if they have identical base types.</p>
</li>
<li><p><code>Two function types are identical if they have the same number of parameters and result values, corresponding parameter and result types are identical, and either both functions are variadic or neither is. Parameter and result names are not required to match</code>.</p>
</li>
<li><p>Two interface types are identical if they have the same set of methods with the same names and identical function types. Non-exported method names from different packages are always different. The order of the methods is irrelevant.</p>
</li>
<li><p>Two map types are identical if they have identical key and element types.</p>
</li>
<li><p>Two channel types are identical if they have identical element types and the same direction.</p>
</li>
</ul>
<p><strong>Different types</strong><br>Unlike in C, in Go <strong><code>assignment between different types(if possible) requires an explicit conversion</code></strong>, there are two ways to use explicit type conversion, other different types can NOT be converted.</p>
<hr>
<ul>
<li>number: int() uint()</li>
<li>number&lt;—&gt;string: <code>strconv.Atoi(&quot;12&quot;), strconv.Itoa(12)</code> Or <code>fmt.Sprintf(&quot;%v&quot;,12)</code></li>
</ul>
<p>you can <strong>Convert int to string in this way, the result may be not what you want <code> j := string(97), j is &quot;a&quot; not &quot;97&quot;</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testp</span><span class="params">(x *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//x is a pointer</span></span><br><span class="line">    *x = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// x is copy, value passed</span></span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">12</span></span><br><span class="line">    <span class="comment">// convert int to uint</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint</span> = <span class="type">uint</span>(a)</span><br><span class="line">    </span><br><span class="line">    s := strconv.Itoa(<span class="number">10</span>)</span><br><span class="line">    c, _ := strconv.Atoi(<span class="string">&quot;20&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(a, b, s, c)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    testp(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    test(a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeDemo()</span><br></pre></td></tr></table></figure>

<pre><code>12 12 10 20
20
20
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := A&#123;name: <span class="string">&quot;jack&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// B and A are same type, can convert to each other!!!</span></span><br><span class="line">    <span class="keyword">var</span> b B = B(a)</span><br><span class="line"></span><br><span class="line">    fmt.Println(b.name)</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>jack
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A_ID <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    id A_ID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B_ID <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    id B_ID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := A&#123;id: <span class="number">100</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> b B = B(a)</span><br><span class="line"></span><br><span class="line">    fmt.Println(b.id)</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>100
</code></pre>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p><font color='red'>A string is a struct that has a length and a pointer to a byte array</font>. When you pass a string to another function, it copies the length and the pointer. As a consequence, the new copied string points to the same underlying data.</p>
<p>each element of string is a <code>byte</code> like <code>s[0]</code>, <strong>string is immutable</strong>, <code>you can NOT modify it in place</code></p>
<hr style="border:1px solid gray"> </hr>

<p><strong>Create a string</strong></p>
<ul>
<li>var s string</li>
<li>var s &#x3D; “hello”</li>
<li>s :&#x3D; “hello”</li>
<li>var s &#x3D; strconv.Itoa(12): Int to string: “12”</li>
<li>string(97): 97 is “a”, so “a” is printed</li>
</ul>
<hr style="border:1px solid gray"> </hr>

<p><strong>Ops</strong></p>
<ul>
<li>s[0], s[0] is <code>byte</code> type!!!</li>
<li>last element <code>s[len(s)-1]</code>, <strong>s[-1] NOT supported</strong></li>
<li>s[0:3]</li>
<li>s +&#x3D; “extend it”</li>
<li>string([]byte{56,57}) &#x2F;&#x2F; convert byte slice to string, new memory is created!!!</li>
<li>string(slice)</li>
<li>support s1 &#x3D;&#x3D; s2</li>
<li><code>for _, c:= range s &#123;&#125;</code> c is rune type!!!</li>
</ul>
<hr style="border:1px solid gray"> </hr>

<ul>
<li><strong>string itself does not have method like <code>Find, Match</code> while  <code>strings</code> library provides ops for it</strong></li>
<li><strong>Can NOT convert array to string but slice is allowed.</strong>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ar :=[<span class="number">2</span>]<span class="type">byte</span>&#123;<span class="number">56</span>,<span class="number">57</span>&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(ar)) <span class="comment">//error</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(ar[:])) <span class="comment">// copy array to slice</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testp</span><span class="params">(s *<span class="type">string</span>)</span></span> &#123; <span class="comment">// string pointers points to argument</span></span><br><span class="line">    fmt.Println(s, *s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s <span class="type">string</span>)</span></span> &#123; <span class="comment">// no copy just like pointer, points to same memory</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    b := s  <span class="comment">// b and s points to same memory, but can NOT modified.</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c %s %v %v\n&quot;</span>, s[<span class="number">0</span>], s[<span class="number">0</span>:<span class="number">3</span>], &amp;s, &amp;b)</span><br><span class="line">    testp(&amp;b)</span><br><span class="line">    test(b)</span><br><span class="line">    </span><br><span class="line">    sc := []<span class="type">byte</span>(<span class="string">&quot;boy&quot;</span>) <span class="comment">// convert string to byte slice</span></span><br><span class="line">    </span><br><span class="line">    s = <span class="type">string</span>(sc) <span class="comment">// convert byte slice to a string</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">    s = <span class="string">`hello</span></span><br><span class="line"><span class="string">world`</span></span><br><span class="line">    <span class="comment">// multiple lines</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">    s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    s2 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> s1 == s2 &#123; <span class="comment">// compare two strings</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;string equal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// default format for rune is %d!!!</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T, %c, %v\n&quot;</span>,s1[<span class="number">1</span>], s1[<span class="number">1</span>], s1[<span class="number">1</span>])</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stringDemo()</span><br></pre></td></tr></table></figure>

<pre><code>h hel 0xc0004df3e0 0xc0004df400
0xc0004df400 hello
hello
boy
hello
world
string equal
uint8, e, 101
5
</code></pre>
<h2 id="array-and-slice"><a href="#array-and-slice" class="headerlink" title="array and slice"></a>array and slice</h2><p>Like C an array has an unique type, <strong>initialize with {}</strong>, <code>arrays cannot be resized, size is fixed at initialization</code>, index from 0 like C.  </p>
<ul>
<li>Arrays are values. <code>Assigning one array to another copies all its elements.</code></li>
<li>In particular, if you <strong><code>pass an array to a function, it will receive a copy of the array</code></strong>, not a pointer to it.</li>
<li>The size of an array is part of its type. The types <code>[10]int and [20]int are distinct type</code>.</li>
</ul>
<hr style="border:1px solid gray"> </hr>

<p><strong>slice and array conversion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------array to slice(no need to define slice firstly)--------------------                             </span></span><br><span class="line">  <span class="keyword">var</span> arr1 = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;                                                      </span><br><span class="line">   </span><br><span class="line">  <span class="comment">// ss is slice</span></span><br><span class="line">  ss := arr1[:] <span class="comment">// points to same memory!!!</span></span><br><span class="line">  ss[<span class="number">0</span>] = <span class="number">4</span>     <span class="comment">// arr1 changed as well.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy element from array to slice(new memory)</span></span><br><span class="line">  s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)                                                             </span><br><span class="line">  <span class="built_in">copy</span>(s[:], arr1[:]) <span class="comment">// s and arr1 points to different memory                    </span></span><br><span class="line">  <span class="comment">//copy(s[:], arr1[:1]), s does not extend even if arr1 is larger                </span></span><br><span class="line">  fmt.Println(s)                                                                  </span><br><span class="line">                                                                                  </span><br><span class="line"><span class="comment">//---------------slice to array(need to define array firstly)--------------------                             </span></span><br><span class="line">                                                                                  </span><br><span class="line">  sc := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;                                                            </span><br><span class="line">  <span class="keyword">var</span> arr2 [<span class="number">3</span>]<span class="type">int</span>                                                                 </span><br><span class="line">  <span class="built_in">copy</span>(arr2[:], sc[:]) <span class="comment">// copy all      </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//copy(arr2[:], sc[:2]) // copy part                                            </span></span><br><span class="line">  fmt.Println(arr2)                       </span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p><strong>Create an array</strong></p>
<ul>
<li>var arr [3]int: all zero</li>
<li>arr :&#x3D; [3]int{1, 2, 3}</li>
<li>arr :&#x3D; [3]int{}: all zero</li>
<li>var arr [3]interface{} &#x2F;&#x2F; array of any type</li>
<li><strong>arr :&#x3D; [3]interface{}{}</strong></li>
<li><strong>arr :&#x3D; [3]interface{}{“a”, 2, 1} array of any type</strong></li>
</ul>
<hr style="border:1px solid gray"> </hr>

<p><strong>array of maps</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each element of the array is a map.</span></span><br><span class="line"><span class="keyword">var</span> ts = [<span class="number">2</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#123;&#125;, &#123;&#125;&#125;</span><br><span class="line">ts[<span class="number">0</span>][<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//OR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ts [<span class="number">2</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// must create empty map</span></span><br><span class="line">ts[<span class="number">0</span>] = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">ts[<span class="number">1</span>] = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">ts[<span class="number">0</span>][<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr style="border:1px solid gray"> </hr>

<p><strong>Ops</strong></p>
<ul>
<li>arr[0]</li>
<li>last element: arr[len(arr) - 1]</li>
<li>arr[0:3] <strong>not include arr[3]</strong></li>
<li>for i, v :&#x3D; range arr {fmt.Println(v)}</li>
<li>arr &#x3D; append(arr, ‘a’, ‘b’) &#x2F;&#x2F;arr may point to new memory!!!</li>
<li>arr &#x3D; <strong>append(arr, another_arr…)</strong> &#x2F;&#x2F; link two arrays</li>
</ul>
<hr style="border:1px solid gray"> </hr>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>An array has <code>a fixed size must be provided at declaration</code>. A slice, on the other hand, <code>is a dynamically-sized, flexible view into the elements of an array</code>. In practice, slices are much more common than arrays.</p>
<p>A slice is formed by specifying two indexes, a low and high bound(<code>not included</code>), separated by a colon:<br><code>a[low:high]</code></p>
<p>you may omit the high or low bounds to use their defaults instead. <code>The default is zero for the low bound and the length of the slice for the high bound.</code></p>
<p><strong>These slice expressions are equivalent:</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>:<span class="number">10</span>] == a[:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:] == [:]</span><br></pre></td></tr></table></figure>

<p><strong>A slice does not store any data, it just describes a section of an underlying array</strong>, <font color='red'>Slices are like references to arrays</font></p>
<p>Changing the elements of a slice modifies the corresponding elements of its underlying array. </p>
<p>The <strong>underlying array is dynamic and can be enlarged(or reduced to smaller one)</strong> to a new larger array(may larger than real elements) if append to a slice, hence a slice has both a length and a capacity.</p>
<p><strong>The length of a slice is the number of elements it contains.</strong></p>
<p><strong>The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.</strong></p>
<p>The length and capacity of a slice s can be obtained using the expressions <code>len(s) and cap(s)</code>. </p>
<hr style="border:1px solid gray"> </hr>

<p><strong>Create a slice</strong></p>
<ul>
<li>var sc []int</li>
<li>sc :&#x3D; []int{1, 2}, nsc &#x3D; sc[:] &#x2F;&#x2F; nsc and sc point to same underlaying memory</li>
<li>sc :&#x3D; []byte(“hello”) &#x2F;&#x2F; byte slice from string</li>
<li>sc :&#x3D; make([]int, 0, 5)</li>
<li>arr :&#x3D; [10]int{}; sc :&#x3D; arr[1:5]; sc :&#x3D; arr[:], sc and arr points to same memory</li>
<li><strong>sc :&#x3D; []interface{}{}</strong></li>
<li><strong>sc :&#x3D; []interface{}{“a”, 1}</strong> slice of any type.</li>
<li><code>func test(sp *[] int)</code> pointer to slice!!!</li>
</ul>
<hr style="border:1px solid gray"> </hr>

<p><strong>Create a slice of map, each slice element is a map</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice with 0 element</span></span><br><span class="line"><span class="keyword">var</span> ts = []<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">//OR</span></span><br><span class="line">ts := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice with 1 map</span></span><br><span class="line">ts = <span class="built_in">append</span>(ts, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;)</span><br><span class="line">ts[<span class="number">0</span>][<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">// slice with 2 maps</span></span><br><span class="line">ts = <span class="built_in">append</span>(ts, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;)</span><br><span class="line">ts[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p><strong>Ops</strong></p>
<ul>
<li>sc[0]</li>
<li>last element: sc[len(sc) - 1]</li>
<li>sc[0:3]</li>
<li>for i, v :&#x3D; range sc {fmt.Println(v)}</li>
<li>sc &#x3D; append(sc, 12) &#x2F;&#x2F; sc may point to new memory!!!</li>
<li>sc &#x3D; append(sc, 12, 13) &#x2F;&#x2F; sc may point to new memory!!!</li>
<li>sc &#x3D; <strong>append(sc, another_sc…)</strong> &#x2F;&#x2F; sc may point to new memory!!!</li>
<li>inset element at index <code>sc = append(sc[:index+1], orig[sc:]...) orig[index] = value</code></li>
<li>remove element at index <code>sc = append(sc[:index], sc[index+1:]...)</code></li>
</ul>
<hr style="border:1px solid gray"> </hr>

<p><strong>Note</strong></p>
<ul>
<li>For append(), <strong><code>If the backing array of s is too small to fit all the given values a bigger array will be allocated</code></strong>. The <code>returned slice</code> will point to the <strong>newly allocated array</strong>.</li>
<li><strong>New element is put at the end of len, may overwrite underlaying array if it’s part of it</strong></li>
<li><strong>empty slice is nil with len &#x3D;&#x3D; 0 but len(s)&#x3D;&#x3D;0, s may be not nil</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">len</span>(s2) == <span class="number">0</span> <span class="comment">// but s2 is not nil!!</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr style="border:1px solid gray"> </hr>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    b := s[<span class="number">0</span>:<span class="number">3</span>] <span class="comment">// here b and s shared the same underlaying</span></span><br><span class="line"></span><br><span class="line">    b = <span class="built_in">append</span>(b, <span class="number">6</span>) <span class="comment">// append at b[3] as len of b is 3!!!</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(b) <span class="comment">// b and s still shares the same underlaying array, hence 4 is replaced with 6</span></span><br><span class="line">    </span><br><span class="line">	b = <span class="built_in">append</span>(b, <span class="number">7</span>)</span><br><span class="line">	fmt.Println(s)  <span class="comment">// b and s still shares the same underlaying array, hence 5 is replaced with 7</span></span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	</span><br><span class="line">	b = <span class="built_in">append</span>(b, <span class="number">8</span>) <span class="comment">// a new larger underlay array is created and returned</span></span><br><span class="line">	fmt.Println(s)   <span class="comment">// s still points to old underlaying array, b points to newly allocated array</span></span><br><span class="line">	fmt.Println(b)   </span><br><span class="line">    </span><br><span class="line">	b = <span class="built_in">append</span>(b, <span class="number">9</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p><font color='red' size=4><strong>how slice cap change</strong></font><br>every slice has an underlying array, an array may be shared among several slices. If the new slice’s length will exceed the array’s capacity, a new array will be created for the new slice. <strong>Usually new capacity will be two times old capacity</strong></p>
<p><code>cap(s), count elements from the beginning of slice to the end of underlay memory.</code></p>
<p><img src="https://i.stack.imgur.com/mwulG.png"></p>
<p><code>make([]byte, 5)</code><br><img src="https://i.stack.imgur.com/p2eqp.png"></p>
<p><code>s = s[2:4], cap(s) == 3</code></p>
<p><strong>Go only supports move start of underlaying array, but the end, the first two is dropped, memory is recycled!!!</strong></p>
<p><img src="https://i.stack.imgur.com/7GnUF.png"></p>
<p><code>s = s[:3], cap(s) == 5!!! </code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main                                                                    </span><br><span class="line">                                                                                  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>                                                                    </span><br><span class="line">                                                                                  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                                                                   </span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10</span>)                                                       </span><br><span class="line">    fmt.Println(<span class="built_in">cap</span>(b)) <span class="comment">//10                                                    </span></span><br><span class="line">    s1 := b[:<span class="number">5</span>]                                                                 </span><br><span class="line">    fmt.Println(<span class="built_in">cap</span>(s1)) <span class="comment">//10                                                   </span></span><br><span class="line">    s2 := s1[<span class="number">1</span>:]                                                                </span><br><span class="line">    fmt.Println(<span class="built_in">cap</span>(s2)) <span class="comment">//9                                                    </span></span><br><span class="line">    s3 := b[<span class="number">5</span>:]                                                                 </span><br><span class="line">    fmt.Println(<span class="built_in">cap</span>(s3)) <span class="comment">//5                                                    </span></span><br><span class="line">&#125;               </span><br></pre></td></tr></table></figure>

<hr>
<p><strong>NOTE</strong></p>
<ul>
<li>It’s ok to loop a nil slice, same thing for map as well<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n []<span class="type">int</span>                                                                 </span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;                                                       </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, i)<span class="comment">// nothing print as n is nil                                              </span></span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(sc [] <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// slice is refernece to array, </span></span><br><span class="line">    <span class="comment">// sc passed with its header(passed value) </span></span><br><span class="line">    <span class="comment">// which has a pointer to array memory and length field, append here will not be seen by caller as length is value passed.</span></span><br><span class="line">    sc[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySliceDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">    <span class="comment">//arr := [5]int&#123;2, 2, 3, 4, 5&#125;</span></span><br><span class="line">    fmt.Println(arr, arr[<span class="built_in">len</span>(arr)<span class="number">-1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// slice of array</span></span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span> = arr[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    s[<span class="number">0</span>] =<span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    b := s <span class="comment">// b and s shared the same underlaying array</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the underlaying array is changed as well</span></span><br><span class="line">    fmt.Println(arr, s, <span class="built_in">cap</span>(s), <span class="built_in">len</span>(s))</span><br><span class="line">    </span><br><span class="line">    s = []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line">    fmt.Println(s, <span class="built_in">cap</span>(s), <span class="built_in">len</span>(s))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// append supports add more value to slice</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">60</span>, <span class="number">70</span>) <span class="comment">// an new array is allocated and slice points to that</span></span><br><span class="line">    fmt.Println(s, <span class="built_in">cap</span>(s), <span class="built_in">len</span>(s))</span><br><span class="line">    </span><br><span class="line">    s = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)    <span class="comment">// len(a)=5, cap(a) = 5</span></span><br><span class="line">    fmt.Println(s, <span class="built_in">cap</span>(s), <span class="built_in">len</span>(s))</span><br><span class="line">    </span><br><span class="line">    s  = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)    <span class="comment">// len(a)=0, cap(a)=5</span></span><br><span class="line">    fmt.Println(s, <span class="built_in">cap</span>(s), <span class="built_in">len</span>(s))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// anonymous struct here.</span></span><br><span class="line">    s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        a <span class="type">int</span></span><br><span class="line">        b <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> Ver <span class="keyword">struct</span> &#123;</span><br><span class="line">        a <span class="type">int</span></span><br><span class="line">        b <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    s := []Ver&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// loop each element of a slice or an array</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Println(i, v) <span class="comment">// v is copy of each element(copy of pointer of object)!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="comment">// just the value, discard the index</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// another way to loop slice or array</span></span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        fmt.Println(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// array</span></span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    narr := arr <span class="comment">// not like slice, narr is a copy of arr!!!</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">6</span>  <span class="comment">// narr is unchanged, different with C language.</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(arr, narr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// slice</span></span><br><span class="line">    <span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    test(arr)</span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// an array of any type</span></span><br><span class="line">    an := [<span class="number">2</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>, <span class="string">&quot;hi&quot;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ab [<span class="number">2</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// interface&#123;&#125; is type!!!</span></span><br><span class="line">    ab[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">    ab[<span class="number">1</span>] = <span class="string">&quot;two&quot;</span></span><br><span class="line">    fmt.Println(an, ab)</span><br><span class="line">    </span><br><span class="line">    sc := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    nsc := <span class="built_in">append</span>(sc[:], []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;...)<span class="comment">// 3,4 append to new slice sc[:]!!!</span></span><br><span class="line">    fmt.Println(sc, nsc)<span class="comment">// sc is not changed!!!</span></span><br><span class="line">&#125;</span><br><span class="line">arraySliceDemo()</span><br></pre></td></tr></table></figure>

<pre><code>[1 2 3 4 5] 5
[1 2 3 4]
[10 2 3 4 5] [10 2 3 4] 5 4
[10 20 30 40 50] 5 5
[10 20 30 40 50 60 70] 10 7
[0 0 0 0 0] 5 5
[] 5 0
[&#123;1 2&#125; &#123;3 4&#125;]
[&#123;1 2&#125; &#123;3 4&#125;]
0 &#123;1 2&#125;
1 &#123;3 4&#125;
&#123;1 2&#125;
&#123;3 4&#125;
&#123;1 2&#125;
&#123;3 4&#125;
[6 2 3 4 5] [1 2 3 4 5]
[100 2]
[1 hi] [2 two]
[1 2] [1 2 3 4]
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice_demo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice the slice to give it zero length.</span></span><br><span class="line">    s = s[:<span class="number">0</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extend its length. why it&#x27;s extend!!???</span></span><br><span class="line">    s = s[:<span class="number">4</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice_demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">    s = s[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    s = s[:<span class="number">2</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    s = s[<span class="number">1</span>:]</span><br><span class="line">    printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slice_demo1()</span><br><span class="line">fmt.Println(<span class="string">&quot;demo&quot;</span>)</span><br><span class="line">slice_demo2()</span><br></pre></td></tr></table></figure>

<pre><code>len=6 cap=6 [2 3 5 7 11 13]
len=0 cap=6 []
len=4 cap=6 [2 3 5 7]
demo
len=3 cap=5 [3 5 7]
len=2 cap=5 [3 5]
len=1 cap=4 [5]
</code></pre>
<h2 id="map-dict"><a href="#map-dict" class="headerlink" title="map(dict)"></a>map(dict)</h2><p><code>Key of map can be of any type for which the equality operator is defined</code>, such as <code>integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays</code>. Slices cannot be used as map keys, because equality is not defined on them, <code>value can by any type like int, string, slice, function etc</code></p>
<hr style="border:1px solid gray"> </hr>

<p><strong>Create a map</strong></p>
<ul>
<li>var m map[string]int: <code>map[string]int sits at right side when assigning values</code></li>
<li>m :&#x3D; map[string]int{}  &#x2F;&#x2F; empty map</li>
<li>m :&#x3D; map[string]int{“a”: 1, “b”: 2}</li>
<li>m :&#x3D; make(map[string]int)</li>
<li><strong>m :&#x3D; map[string]interface{}{}</strong></li>
<li><strong>m :&#x3D; map[string]interface{}{“a”: 1, “b”: “b”} key must be quoted when it’s string literal</strong></li>
<li><strong>m :&#x3D; map[string]func(i string){}</strong> map of function object.</li>
</ul>
<hr style="border:1px solid gray"> </hr>

<p><strong>create map whose value is a slice</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>&#123;&#125; <span class="comment">// empty map</span></span><br><span class="line"><span class="comment">//OR</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = []<span class="type">int</span>&#123;&#125; <span class="comment">// create a new slice</span></span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="built_in">append</span>(m[<span class="string">&quot;a&quot;</span>], <span class="number">1</span>)</span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="built_in">append</span>(m[<span class="string">&quot;a&quot;</span>], <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;b&quot;</span>] = []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p><strong>create map whose value is func object</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(m <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">string</span>)</span></span>&#123;&#125;</span><br><span class="line">    m[<span class="string">&quot;a&quot;</span>] = hello</span><br><span class="line">    m[<span class="string">&quot;a&quot;</span>](<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p><strong>Ops</strong></p>
<ul>
<li>m[“c”]&#x3D; 3</li>
<li>elem, ok &#x3D; m[key]</li>
<li>delete(m, “c”): It’s safe to do even if the key is absent from the map</li>
</ul>
<hr style="border:1px solid gray"> </hr>

<p><font color='red'>you <strong>CAN NOT assign value for nil map, you must create it first!!!</strong></font></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mt <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="comment">// nil map</span></span><br><span class="line">mt[<span class="string">&quot;cool&quot;</span>] = <span class="number">12</span> ERROR!!!</span><br><span class="line"></span><br><span class="line">mt := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125; <span class="comment">// map is created</span></span><br><span class="line">mt := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// map is created</span></span><br></pre></td></tr></table></figure>

<p><strong>But it’s ok to loop a nil map</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>                                                             </span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;                                                       </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, i)<span class="comment">// nothing print as n is nil                                              </span></span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p><strong>Note</strong></p>
<ul>
<li><strong>Access map by map[key] NOT map.key</strong></li>
<li><strong>The key of map must be same type</strong>, but the value can be any type when use <code>interface&#123;&#125;</code> as value type.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;f&quot;</span>] = <span class="number">100</span></span><br><span class="line">    <span class="comment">// m[12] = &quot;hi&quot; // ERROR!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// literal maps</span></span><br><span class="line">    <span class="comment">// &#123;&#125; is initializer</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> m1 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123; <span class="comment">// &#123;&quot;a&quot;:1, &quot;b&quot;:2 &#125; is initializer same line, , can be omitted</span></span><br><span class="line">        <span class="string">&quot;a&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="comment">// each element must end with ,!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//m3 and m1 points to same memory, like pointer!!!</span></span><br><span class="line">    m3 := m1</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// change map</span></span><br><span class="line">    test(m3)</span><br><span class="line">    </span><br><span class="line">    m1[<span class="string">&quot;e&quot;</span>] = <span class="number">15</span></span><br><span class="line">    </span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">        <span class="string">&quot;c&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">&quot;d&quot;</span>: <span class="number">4</span>, <span class="comment">// each element must end with even the last one if at different line!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;<span class="string">&quot;c&quot;</span>: <span class="number">3</span>, <span class="string">&quot;d&quot;</span>: <span class="number">4</span>&#125; <span class="comment">// the last , can be omitted if at same line with &#125;</span></span><br><span class="line">    m2[<span class="string">&quot;e&quot;</span>] = <span class="number">13</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">delete</span>(m2, <span class="string">&quot;e&quot;</span>)</span><br><span class="line">    fmt.Println(m1, m3, m2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mutating Maps</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// var mt map[string]int</span></span><br><span class="line">    <span class="comment">// mt[&quot;cool&quot;] = 12 ERROR!!!</span></span><br><span class="line">    </span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// map without element</span></span><br><span class="line"></span><br><span class="line">    m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">42</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">    m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">48</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">    v, ok := m[<span class="string">&quot;Answer&quot;</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;The value:&quot;</span>, v, <span class="string">&quot;Present?&quot;</span>, ok)</span><br><span class="line">    m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">    m[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">    fmt.Println(m)</span><br><span class="line">    <span class="comment">// loop a map</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> mn = <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    mn[<span class="string">&quot;a&quot;</span>] = <span class="number">12</span></span><br><span class="line">    mn[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&quot;hi&quot;</span></span><br><span class="line">    fmt.Println(mn, mn[<span class="string">&quot;a&quot;</span>], mn[<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mapDemo()</span><br></pre></td></tr></table></figure>

<pre><code>map[a:1 b:2 e:15 f:100] map[a:1 b:2 e:15 f:100] map[c:3 d:4]
The value: 42
The value: 48
The value: 0
The value: 0 Present? false
map[a:1 b:2]
a 1
b 2
map[a:12 b:hi] 12 hi
</code></pre>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>Struct fields can be accessed by struct instance or <strong>through a struct pointer which uses <code>. NOT -&gt;</code> like what did in C</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="type">int</span> <span class="comment">//NOT var x int!!!  </span></span><br><span class="line">    <span class="comment">//as it&#x27;s lowercase, non-exported field!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr style="border:1px solid gray"> </hr>

<p><strong>Create a struct instance</strong></p>
<ul>
<li>var st Vertex</li>
<li>st :&#x3D; Vertex{1, 2} &#x2F;&#x2F; <strong>unamed assignment, must provide all values!!!</strong></li>
<li>st :&#x3D; &amp;Vertex{x: 1} &#x2F;&#x2F; named assignment, can provide part of values!!!</li>
<li><strong>st :&#x3D; Vertex{x: 1, y: 2} NOT “x” or “y” when use named index!!!</strong></li>
<li>st :&#x3D; Vertex{}</li>
</ul>
<hr style="border:1px solid gray"> </hr>

<p><strong>Ops</strong></p>
<ul>
<li>st.x &#x3D; 10</li>
<li>p :&#x3D; &amp;st</li>
<li>p.x &#x3D; 10 <code>not p-&gt;x</code></li>
</ul>
<hr style="border:1px solid gray"> </hr>

<p><strong>Note</strong></p>
<ul>
<li><strong>Access field of struct by st.field_name not st[“field_name”] like what we do for map</strong></li>
<li><strong>pointer still uses p.field_name to access filed which is converted to <code>(*p).field</code> by Go automatically</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y, z <span class="type">int</span> <span class="comment">//no var </span></span><br><span class="line">    <span class="comment">//as it&#x27;s lowercase, non-exported field!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// has type Vertex</span></span><br><span class="line">    v2 = Vertex&#123;y: <span class="number">1</span>&#125;  <span class="comment">// x:0 is implicit, set named field, error for unamed setting Vertex&#123;1&#125;</span></span><br><span class="line">    v3 = Vertex&#123;&#125;      <span class="comment">// x:0 and y:0 and z:0 if unset fields!!!</span></span><br><span class="line">    p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// has type *Vertex</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pt *Vertex</span><br><span class="line">    <span class="comment">// as pt is pointer, must use &amp; </span></span><br><span class="line">    pt = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="comment">// , is needed if &#125; is at newline!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    fmt.Println(v1, p, v2, v3, *pt)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// array of struct</span></span><br><span class="line">    <span class="keyword">var</span> pa []*Vertex</span><br><span class="line">    pa = []*Vertex &#123;<span class="comment">// type of each element</span></span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, <span class="comment">//  not &amp; even it&#x27;s pointer type!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(v1, p, v2, v3, *pt, *pa[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">structDemo()</span><br></pre></td></tr></table></figure>

<pre><code>&#123;1 2 3&#125; &amp;&#123;1 2 3&#125; &#123;0 1 0&#125; &#123;0 0 0&#125; &#123;1 3 4&#125;
&#123;1 2 3&#125; &amp;&#123;1 2 3&#125; &#123;0 1 0&#125; &#123;0 0 0&#125; &#123;1 3 4&#125; &#123;4 5 6&#125;
</code></pre>
<h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><p>Always remember Go is compiled language, hence, each parameter and return value must have a type, <code>NO default value supported for parameter func test(x=12, y)</code>, <code>Unsupported named parameter call like test(y=12, x=13)</code>.</p>
<p><strong>function can return any number of results</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// omit type if use the same type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// named return value, like declared a var z at top of the function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// use z directly</span></span><br><span class="line">	z = x + y</span><br><span class="line">    <span class="keyword">return</span>  <span class="comment">// no explicit, return named value, but return directive is a must!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return two values</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">	z = x + y</span><br><span class="line">    <span class="keyword">return</span> z, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p><strong>A defer statement defers the execution of a function until the surrounding function returns.</strong></p>
<p><strong>The deferred call’s arguments are evaluated immediately, but the function call is not executed until the surrounding function returns</strong>. <font color='red'>deferred function calls are pushed onto a stack</font>. When a function returns, <code>its deferred calls are executed in last-in-first-out order</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        i = i + <span class="number">10</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Get())</span><br><span class="line">&#125;</span><br><span class="line">..</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p><strong>Note</strong>  </p>
<ul>
<li><strong><font color='red'>defer GetPerson().GetName() only the last call <code>GetName(</code>) is deferred, GetPerson() is called immediately!!!</font></strong></li>
<li>deferred call’s <code>arguments are evaluated immediately</code></li>
<li><code>deferred function should no return</code>, if wants return value, use channel, if deferred function has return value, it’s not captured!!!</li>
<li>deferred function executes after return statement!!!</li>
<li>As go is compile, hence deferred may not be pushed to stack, if code not reach it!!!.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    resCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        resCh &lt;- a + b</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resCh := add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    res := &lt;-resCh</span><br><span class="line">    fmt.Println(<span class="string">&quot;1 + 2 =&quot;</span>, res)</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>1 + 2 = 3
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(cool <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> cool &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;defer %v\n&quot;</span>, cool)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="literal">true</span>) <span class="comment">// no defer executes as cool is true!!!</span></span><br><span class="line">    test(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>defer false
</code></pre>
<h2 id="function-object"><a href="#function-object" class="headerlink" title="function object"></a>function object</h2><p><code>Function is an object, so it can be used as argument or return value</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// unnamed function</span></span><br><span class="line"><span class="keyword">var</span> hadd = <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// func(int, int) int: is (function) type!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(test(add))</span><br><span class="line">fmt.Println(test(hadd))</span><br></pre></td></tr></table></figure>

<h2 id="function-closure"><a href="#function-closure" class="headerlink" title="function closure"></a>function closure</h2><p>function closure is a function that returns another function, but you <strong><code>can NOT define a function in another function like this</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">embed</span><span class="params">()</span></span> &#123; <span class="comment">// Compile Error!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hembed := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// OK as hembed is a variable which points to unnamed function</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>closure Return unnamed function</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// return value is a function</span></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// unnamed function</span></span><br><span class="line">		sum += x <span class="comment">// always access var defined at its wrapper which is like a static variable!!!</span></span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hello is function wrapper which takes wrapped function as parameter</span></span><br><span class="line"><span class="comment">// return the wapper function which is used by caller</span></span><br><span class="line"><span class="comment">// inside the wrapper, add internal logical, then call wrapped function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">string</span>)</span></span> <span class="type">error</span>) <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">&quot;wrapper: &quot;</span>)</span><br><span class="line">        fn(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>, name)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wp := hello(greet)</span><br><span class="line">    wp(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>wrapper: hello tom
</code></pre>
<h2 id="variadic-function-dynamic-parameters"><a href="#variadic-function-dynamic-parameters" class="headerlink" title="variadic function(dynamic parameters)"></a>variadic function(dynamic parameters)</h2><p>In Go, a function that can accept a dynamic number of arguments is called a Variadic function. Below is the syntax for variadic function. Three dots are used as a prefix before type.</p>
<p><strong>dynamic parameters with same type</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// same type, ... is closer to type, it&#x27;s a new type ...int</span></span><br><span class="line"><span class="comment">// numbers behaves like a slice, packed parameters</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(numbers ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// must be the last parameter of a function!!!</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> numbers &#123; <span class="comment">// numbers is like a slice</span></span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numbers := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;</span><br><span class="line">add(numbers...) <span class="comment">// call with slice, expand slice, same as add(2, 3, 5), unpacked parameter</span></span><br></pre></td></tr></table></figure>

<p><strong>dynamic parameters for different types</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handle(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    handle(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;xyz&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    handle(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface&#123;&#125; for any type as it has no method defined</span></span><br><span class="line"><span class="comment">// ...interface&#123;&#125; behaves like a new type</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(params ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Handle func called with parameters:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, param := <span class="keyword">range</span> params &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, param) <span class="comment">// print the value of special type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function as an argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function as return value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// unnamed function</span></span><br><span class="line">        sum += x</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// defer function</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;boy&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;girl&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// declare a function object</span></span><br><span class="line">    hadd := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(test(hadd))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// closure</span></span><br><span class="line">    f1 := adder() <span class="comment">// f1 has its own copy of sum, all call f1 shares the same sum.</span></span><br><span class="line">    fmt.Println(f1(<span class="number">1</span>))</span><br><span class="line">    fmt.Println(f1(<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    f2 := adder() <span class="comment">// f2 has its own copy of sum</span></span><br><span class="line">    fmt.Println(f2(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcDemo()</span><br></pre></td></tr></table></figure>

<pre><code>hello
3
1
2
1
girl
boy
</code></pre>
<h2 id="function-type"><a href="#function-type" class="headerlink" title="function type"></a>function type</h2><p><code>Think function signature(without name) as a type</code>, you can declare variable, parameter, new type based on function signature.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new type based on function type</span></span><br><span class="line"><span class="keyword">type</span> HelloFn <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parameter with function type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">string</span>)</span></span> <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// declare a function var</span></span><br><span class="line">    <span class="keyword">var</span> pn <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line">    pn = fn</span><br><span class="line">    pn(<span class="string">&quot;jason&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// declare a function var</span></span><br><span class="line">    <span class="keyword">var</span> pn1 HelloFn</span><br><span class="line">    pn1 = fn</span><br><span class="line">    pn1(<span class="string">&quot;jason&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>, name)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hello(greet)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>hello jason
hello jason
</code></pre>
<h2 id="function-parameter"><a href="#function-parameter" class="headerlink" title="function parameter"></a>function parameter</h2><p><strong>Parameter passing is same like C except for array, for array it’s copy of the whole array, not array pointer is passed!!!</strong> </p>
<p>For slice even <code>pointer</code> is passed in function, if you <strong>append new element in that slice, the caller does not know either, see below explanations</strong></p>
<ul>
<li><code>the underlying array reached its capacity, a new slice created to replace the origin one, obviously the origin slice will not be modified.</code></li>
<li><code>the underlying array has not reached its capacity, and was modified. BUT the field len of the slice was not overwritten because the slice was passed by value</code>. As a result, the origin slice will not aware its len was modified, which result in the slice not modified.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_slice</span><span class="params">(s []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_slice2</span><span class="params">(s []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// append means add an element at last, same like s[len(s)] = &quot;c&quot;</span></span><br><span class="line">    <span class="comment">// if cap is smaller, a new underlay memory is created.</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    fmt.Println(s, <span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">    test_slice(s)</span><br><span class="line">    fmt.Println(s, <span class="built_in">len</span>(s))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as now len(s) = 2</span></span><br><span class="line">    test_slice2(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s does not see the &#x27;c&#x27; as it&#x27;s added to a new larger slice!!!</span></span><br><span class="line">    <span class="comment">// new memory is not returned</span></span><br><span class="line">    fmt.Println(s, <span class="built_in">len</span>(s))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================</span></span><br><span class="line">    s1 := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    s1 = <span class="built_in">append</span>(s1, <span class="string">&quot;x&quot;</span>)</span><br><span class="line">    <span class="comment">// no new memory is created, but you still not see &#x27;c&#x27;</span></span><br><span class="line">    <span class="comment">// because the len is not update, as it&#x27;s passed by value!!!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* imagin slice as</span></span><br><span class="line"><span class="comment">        Slice &#123;</span></span><br><span class="line"><span class="comment">            int len;</span></span><br><span class="line"><span class="comment">            char *s; // underlay memory pointer</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    test_slice2(s1)</span><br><span class="line">    fmt.Println(s1, <span class="built_in">len</span>(s1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>[a b] 2
[a b c] 3
[a b] 2
[x c] 2
[x] 1
</code></pre>
<h1 id="flow-control"><a href="#flow-control" class="headerlink" title="flow control"></a>flow control</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Go has <strong>only one looping construct, the <code>for</code> loop, <code>NO while, until</code> etc.</strong></p>
<p>The basic for loop has three components <code>separated by semicolons</code>:</p>
<ul>
<li>the init statement: executed before the first iteration</li>
<li>the condition expression: evaluated before every iteration</li>
<li>the post statement: executed at the end of every iteration</li>
</ul>
<p>*<strong>Note</strong></p>
<ul>
<li>Unlike other languages like C, Java, or JavaScript. For Go there are <strong>no parentheses surrounding the three components of the for statement but the braces { } are always required</strong>.</li>
</ul>
<hr style="border:1px solid gray"> </hr>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; <span class="comment">// is is only visible in this loop</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">8</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; &#123; <span class="comment">// is is only visible in this loop</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">8</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++&#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">8</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p><strong>use <code>for as while</code> as init and post statements are optional</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">100</span>; &#123;</span><br><span class="line">    sum += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// short way, same like while in C</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">100</span> &#123;</span><br><span class="line">    sum += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p><strong>infinite loop</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>multiple assignments</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(a) - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>range with for</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ps := []Person&#123;</span><br><span class="line">        &#123;name: <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> ps &#123;</span><br><span class="line">        p.name = <span class="string">&quot;b&quot;</span> <span class="comment">// p is copy of each element</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nothing changed</span></span><br><span class="line">    fmt.Println(ps)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ps); i++ &#123;</span><br><span class="line">        ps[i].name = <span class="string">&quot;b&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(ps)</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">go</span> run test.<span class="keyword">go</span> </span><br><span class="line">[&#123;a&#125;]</span><br><span class="line">[&#123;b&#125;]</span><br></pre></td></tr></table></figure>

<p><strong>NOTE: when reach the loop end, the index is different!!!</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">        <span class="comment">// i == 3 when out of range</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;out loop index: %d\n&quot;</span>, i)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, _ = <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="comment">// i == 2 when out of range</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;out loop index: %d\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="keyword">go</span> run test.<span class="keyword">go</span></span><br><span class="line">out loop index: <span class="number">3</span></span><br><span class="line">out loop index: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>Go’s <code>if</code> statements is like its <code>for</code> loops; the <code>expression may not be surrounded by parentheses ( ) but the braces &#123; &#125; are required.</code></p>
<p>The <code>if</code> statement <code>can start with a short statement to execute before the condition</code>.</p>
<p><strong>Variables declared by the statement are only in scope until the end of the <code>if</code></strong>.<br><font color="red" size=4> it’s also available inside any of the <code>else</code> blocks.</font></p>
<hr style="border:1px solid gray"> </hr>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i := <span class="number">0</span>; i == <span class="number">0</span> &#123; <span class="comment">// scope of i is block, after if, it&#x27;s out of scope</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> &#123; <span class="comment">// compile error!!! as 1 is not bool type</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>NOTE</strong></p>
<ul>
<li><strong>non-boolean type can NOT be used as if condition!!!</strong></li>
</ul>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>The expressions <code>need not to be constants or even integers</code>, the cases are evaluated top to bottom until a match is found, and if the switch has no expression it switches on true.</p>
<p>Go’s switch is like the one in C, C++, Java, JavaScript, and PHP, except that <code>Go only runs the selected case (implicit break at the end)</code>, not all the cases that follow. In effect, <strong>the break statement that is needed at the end of each case in those languages is provided automatically <code>in Go but if you want to break in the middle of this case, break is required</code></strong>. Another important difference is that <strong>Go’s switch cases need not be constants, and the values involved need not be integers.</strong></p>
<hr style="border:1px solid gray"> </hr>

<p><strong>Switch cases evaluate cases from top to bottom, stopping when a case succeeds, auto break if matched</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// auto break</span></span><br><span class="line"><span class="keyword">case</span> f(): <span class="comment">//does not call f if i==0</span></span><br><span class="line">    <span class="keyword">break</span> <span class="comment">// break at end no effect as if there is no break here!!!</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span> &gt;<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// break here below does not run</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;reach end of case&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr style="border:1px solid gray"> </hr>

<p><strong>Switch without condition</strong><br>Switch <code>without a condition is the same as switch true</code>.</p>
<p>This construct can be a clean way to write <strong><code>long if-then-else chains</code>.</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">t := <span class="number">15</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t &gt; <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">case</span> t &gt; <span class="number">5</span>:</span><br><span class="line">    fmt.Println(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">case</span> t &gt; <span class="number">3</span>:</span><br><span class="line">    <span class="comment">// with fallthrough, the next case condtion is not checked.</span></span><br><span class="line">    <span class="keyword">fallthrough</span> <span class="comment">// if t==4, fallthrough next one, no matter next condition matches or not, print 18 !!!</span></span><br><span class="line"><span class="keyword">case</span> t &gt; <span class="number">18</span>:</span><br><span class="line">    fmt.Println(<span class="number">18</span>) <span class="comment">// break here if no other fallthrough</span></span><br><span class="line"><span class="keyword">case</span> t &gt;= <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// different cases has the same action</span></span><br><span class="line">n := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>,<span class="number">3</span>:</span><br><span class="line">    <span class="comment">// do something directly here</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>,<span class="number">6</span>:</span><br><span class="line">    <span class="comment">// call do_something() to share the same action</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    HERE:</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> HERE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="break-x2F-continue"><a href="#break-x2F-continue" class="headerlink" title="break&#x2F;continue"></a>break&#x2F;continue</h2><p>By default, <code>break, continue</code> work for inner loop, but if you want to take effect of outer loop, use <code>label</code> for <code>break, continue</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for loop</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">8</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Print(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;\n-------------------------&quot;</span>)    </span><br><span class="line">    <span class="comment">// switch, from top to bottom</span></span><br><span class="line">    <span class="keyword">switch</span> i := <span class="string">&quot;hello&quot;</span>; i &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;boy&quot;</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;boy&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> greet():</span><br><span class="line">            fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// always put default at last one!!!</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;\n-------------------------&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// use break/continue with label on outer loop</span></span><br><span class="line">here:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;i=&quot;</span>, i)</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;j=&quot;</span>,j)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> here <span class="comment">// continue the out loop, even here is out, i is initialized for only once!!!!</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;\n-------------------------&quot;</span>)</span><br><span class="line">there:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(j)</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> there <span class="comment">// break out, no outer next loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flowDemo()</span><br></pre></td></tr></table></figure>

<pre><code>0123467
-------------------------
hello

-------------------------
i= 0
j= 1
i= 1
j= 2

-------------------------
2
</code></pre>
<h1 id="system-env"><a href="#system-env" class="headerlink" title="system env"></a>system env</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">envDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// os.Environ() reutrn a map</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> os.Environ() &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    os.Setenv(<span class="string">&quot;GO&quot;</span>, <span class="string">&quot;/tmp/go&quot;</span>)</span><br><span class="line">    fmt.Println(os.Getenv(<span class="string">&quot;GO&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">envDemo()</span><br></pre></td></tr></table></figure>

<pre><code>PATH=/home/data/Anaconda3/envs/py3.9/bin:/opt/llvm/bin:/home/data/Anaconda3/envs/py3.9/bin:/home/data/Anaconda3/condabin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/home/go:/home/go/bin:/root/.yarn_pkg/bin:/usr/lib64:/usr/local/go/bin:/home/data/Anaconda3/envs/py3.9/libexec/git-core:/root/bin:/root/.yarn_pkg/bin:/home/go/bin:/home/go:/usr/local/go/bin
PWD=/
LANG=en_US.UTF-8
SHLVL=1
_=/usr/bin/env
GO111MODULE=on
GOMODCACHE=/home/go/pkg/mod
GOCACHE=/root/.cache/go-build
GOPATH=/home/go
PYDEVD_USE_FRAME_EVAL=NO
JPY_PARENT_PID=1797
GO=/tmp/go
/tmp/go
</code></pre>
<h1 id="small-tips"><a href="#small-tips" class="headerlink" title="small tips"></a>small tips</h1><h2 id="return-local-var-from-stack-is-safe-in-GO"><a href="#return-local-var-from-stack-is-safe-in-GO" class="headerlink" title="return local var from stack is safe in GO"></a>return local var from stack is safe in GO</h2><p>Returning an address of a local variable is also safe. </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">int</span> = <span class="number">12</span></span><br><span class="line">    <span class="keyword">return</span> &amp;s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = test()</span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure>

<h2 id="string-vs-byte"><a href="#string-vs-byte" class="headerlink" title="string vs [] byte"></a>string vs [] byte</h2><p>string is the set of <code>byte</code>, <code>conventionally but not necessarily representing UTF-8-encoded text</code>. A string may be empty, but not nil.  </p>
<ul>
<li><code>Values of string type are immutable</code>   </li>
<li><code>Values of []byte are mutable</code></li>
</ul>
<p><strong>conversion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">b := []<span class="type">byte</span>(s1) <span class="comment">// new memory allocated!!!</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// []byte to string</span></span><br><span class="line">s2 := <span class="type">string</span>(b) <span class="comment">// new memory allocated!!!</span></span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;你好&quot;</span> <span class="comment">//string</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> s = [] <span class="type">rune</span>(<span class="string">&quot;你好&quot;</span>) <span class="comment">// as rune = int32, henc two elements for 你好</span></span><br><span class="line">    fmt.Println(s, <span class="built_in">len</span>(s), <span class="type">string</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<pre><code>6
[20320 22909] 2 你好
</code></pre>
<h2 id="what-does-empty-mean-for-each-type"><a href="#what-does-empty-mean-for-each-type" class="headerlink" title="what does empty mean for each type"></a>what does empty mean for each type</h2><p>let’s focus on these types, <code>string, integer(int, uint etc), pointer, array, slice, map)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">emptyDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/* default value for each type is empty</span></span><br><span class="line"><span class="comment">     * &quot;&quot;      ---&gt;string</span></span><br><span class="line"><span class="comment">     * 0       ---&gt;number</span></span><br><span class="line"><span class="comment">     * nil     ---&gt;pointer</span></span><br><span class="line"><span class="comment">     * nil     ---&gt;slice</span></span><br><span class="line"><span class="comment">     * nil     ---&gt;map</span></span><br><span class="line"><span class="comment">     * nil     ---&gt;function type like function type: &#x27;type CallBack func()&#x27;</span></span><br><span class="line"><span class="comment">     * NO empty for array as it&#x27;s has fixed size, must be set at delcaration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> str <span class="type">string</span>          <span class="comment">// str := &quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span>               <span class="comment">// n := 0</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span>              <span class="comment">// var p *int = nil</span></span><br><span class="line">    <span class="keyword">var</span> sc []<span class="type">int</span>            <span class="comment">// sc := []int&#123;&#125;</span></span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>    <span class="comment">// here m is nil can NOT add new element in it</span></span><br><span class="line">    <span class="comment">// m := map[string]ing&#123;&#125; m NOT nill, can add new element, like m[&quot;a&quot;] = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> str == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;string default value: %q \n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;int default value: 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;pointer default value: nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sc == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;slice defautl value: nil  ([], cap=%d, len=%d)\n&quot;</span>, <span class="built_in">cap</span>(sc), <span class="built_in">len</span>(sc))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;map defautl value: nil  (&#123;&#125; len=%d)\n&quot;</span>, <span class="built_in">len</span>(m))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emptyDemo()</span><br></pre></td></tr></table></figure>

<pre><code>string default value: &quot;&quot; 
int default value: 0
pointer default value: nil
slice defautl value: nil  ([], cap=0, len=0)
map defautl value: nil  (&#123;&#125; len=0)
</code></pre>
<h2 id="get-the-size-of-memory-for-each-type"><a href="#get-the-size-of-memory-for-each-type" class="headerlink" title="get the size of memory for each type"></a>get the size of memory for each type</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="type">int16</span>(<span class="number">32</span>)</span><br><span class="line">    b := <span class="number">12</span>          <span class="comment">//int 8 bytes on 64-bit machine</span></span><br><span class="line">    c := <span class="string">&quot;h&quot;</span>         <span class="comment">//not like C strlen.</span></span><br><span class="line">    d := <span class="string">&#x27;h&#x27;</span>         <span class="comment">//int32</span></span><br><span class="line">    <span class="keyword">var</span> e <span class="type">byte</span> = <span class="string">&#x27;h&#x27;</span> <span class="comment">//uint8</span></span><br><span class="line">    f := &amp;b</span><br><span class="line">    <span class="comment">// f := b + 1       // f is &#x27;i&#x27;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;sizeof(%T)=%v\n&quot;</span>, a, unsafe.Sizeof(a))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;sizeof(%T)=%v\n&quot;</span>, b, unsafe.Sizeof(b))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;sizeof(%T)=%v\n&quot;</span>, c, unsafe.Sizeof(c))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;sizeof(%T)=%v\n&quot;</span>, d, unsafe.Sizeof(d))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;sizeof(%T)=%v\n&quot;</span>, e, unsafe.Sizeof(e))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;sizeof(%T)=%v\n&quot;</span>, f, unsafe.Sizeof(f))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sizeof(<span class="type">int16</span>)=<span class="number">2</span></span><br><span class="line">sizeof(<span class="type">int</span>)=<span class="number">8</span></span><br><span class="line"><span class="comment">// it&#x27;s always 16 bytes, no matter how long it&#x27;s, as for string, sizeof(s)==sizeof(s.len)+sizeof(s.pointer)</span></span><br><span class="line">sizeof(<span class="type">string</span>)=<span class="number">16</span></span><br><span class="line">sizeof(<span class="type">int32</span>)=<span class="number">4</span></span><br><span class="line">sizeof(<span class="type">uint8</span>)=<span class="number">1</span></span><br><span class="line">sizeof(*<span class="type">int</span>)=<span class="number">8</span></span><br></pre></td></tr></table></figure>

<h2 id="when-should-I-use-new"><a href="#when-should-I-use-new" class="headerlink" title="when should I use new()"></a>when should I use new()</h2><p>new(T) allocates <code>zeroed storage</code> for a new item of type T and returns its address, a value of type *T.</p>
<p>Suggestion, <strong>use it as less as possible</strong>, as new(T) and &amp;T{} can do the same thing. Both allocate a zero T and return a pointer to this allocated memory. The only difference is, that <strong>&amp;T{} doesn’t work for builtin types like int; you can only do new(int).</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// without new only form is different!!</span></span><br><span class="line">i: = <span class="number">10</span></span><br><span class="line">p :=  &amp;i</span><br><span class="line"></span><br><span class="line"><span class="comment">//with new, it&#x27;s one statement</span></span><br><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// without new</span></span><br><span class="line">p := &amp;Person &#123;name: <span class="string">&quot;jason&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// with new</span></span><br><span class="line">p := <span class="built_in">new</span>(Person)</span><br><span class="line">Person.name = <span class="string">&quot;jason&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="when-should-I-use-make"><a href="#when-should-I-use-make" class="headerlink" title="when should I use make()"></a>when should I use make()</h2><p><strong>It creates slices, maps, and channels only</strong>, and it returns an <code>initialized (not zeroed) value of type T (not *T)</code>. The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. <code>A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the length, and the capacity</code>, and until those items are initialized, the slice is nil. <strong><code>For slices, maps, and channels, make initializes the internal data structure and prepares the value for use</code></strong></p>
<hr>
<p>The make built-in function <code>allocates and initializes</code> an object of type slice, map, or chan (only), can be used only for Slice, Map, Channel</p>
<ul>
<li><p>Slice: The size specifies the length. The capacity of the slice is equal to its length. A second integer argument may be provided to specify a different capacity; it must be no smaller than the<br>length. For example, <code>make([]int, 0, 10) allocates an underlying array of size 10 and returns a slice of length 0 and capacity 10 that is backed by this underlying array</code>.  </p>
</li>
<li><p>Map: An <strong>empty map(not equal nil)</strong> is allocated <strong>with enough space</strong> to hold the specified number of elements. The size may be omitted, in which case a small starting size is allocated.    </p>
</li>
<li><p>Channel: The channel’s buffer is initialized with the specified buffer capacity. If zero, or <code>the size is omitted, the channel is unbuffered</code>.</p>
</li>
</ul>
<hr>
<p><strong>Suggestion</strong>  </p>
<ul>
<li><strong>If you know the estimated size of slice or map</strong>, use make() to preallocate enough memory</li>
<li><strong>Always use <code>make() for channel</code></strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>) <span class="comment">// new underlaying array is allocated.</span></span><br><span class="line"></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="comment">// cap = 2, len = 0</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>) <span class="comment">// no new array is allocated.</span></span><br></pre></td></tr></table></figure>

<h2 id="pointer-to-array-and-array-of-pointers"><a href="#pointer-to-array-and-array-of-pointers" class="headerlink" title="pointer to array and array of pointers"></a>pointer to array and array of pointers</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad way never use this, use slice instead</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updatearray</span><span class="params">(funarr *[5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good way</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateslice</span><span class="params">(funarr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad way, use slice of pointers instead</span></span><br><span class="line"><span class="keyword">var</span> ptr [MAX]*<span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good way</span></span><br><span class="line"><span class="keyword">var</span> ptr []*<span class="type">int</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pc []*Person</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    pc = []*Person&#123;</span><br><span class="line">        &amp;Person&#123;Name: <span class="string">&quot;tom&quot;</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">&quot;jack&quot;</span>&#125;, <span class="comment">//shortway</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// after initialization</span></span><br><span class="line">    pc = <span class="built_in">append</span>(pc, &amp;Person&#123;Name: <span class="string">&quot;hak&quot;</span>&#125;)</span><br><span class="line">    fmt.Println(pc[<span class="number">0</span>].Name, pc[<span class="number">1</span>].Name, pc[<span class="number">2</span>].Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<pre><code>tom jack hak
</code></pre>
<h2 id="check-type-of-variable"><a href="#check-type-of-variable" class="headerlink" title="check type of variable"></a>check type of variable</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var1 := <span class="number">12</span></span><br><span class="line"><span class="comment">// only print it type</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;var1 = %T\n&quot;</span>, var1)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;var1 = &quot;</span>, reflect.TypeOf(var1))</span><br></pre></td></tr></table></figure>

<h2 id="variable-has-same-name-with-package"><a href="#variable-has-same-name-with-package" class="headerlink" title="variable has same name with package"></a>variable has same name with package</h2><p>In such case, error happens.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;coding.xx.com/agent/src/server/conf/xml&quot;</span>    <span class="comment">// package name is xml</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// variable name is xml</span></span><br><span class="line">    xml, err := ioutil.ReadFile(<span class="string">&quot;./vm.xml&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// error!!!!</span></span><br><span class="line">    df := &amp;xml.Domain&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = df.Unmarshal(xml); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a target="_blank" rel="noopener" href="https://tour.golang.org/list">A Tour of Go</a></li>
<li><a target="_blank" rel="noopener" href="https://devhints.io/go">Go cheatsheet</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/a8m/golang-cheat-sheet">Go basic</a></li>
<li><a target="_blank" rel="noopener" href="https://learnxinyminutes.com/docs/go/">Learn GO in Y Minutes</a></li>
<li><a target="_blank" rel="noopener" href="https://gobyexample.com/">Go examples</a></li>
<li><a target="_blank" rel="noopener" href="https://studygolang.gitbook.io/">StudyGo ZH</a></li>
</ul>

    </div>

    
    
    
      


    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="Jason WeChat Pay">
        <span>WeChat Pay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/14/yum-rpm-pkg/" rel="prev" title="yum-rpm-pkg">
                  <i class="fa fa-chevron-left"></i> yum-rpm-pkg
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/03/encode-toml/" rel="next" title="encode-toml">
                  encode-toml <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cyun All rights reserved</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"jason-bj/blog","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
